Index: inc/Dependencies/Minify/CSS.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n/**\n * CSS Minifier\n *\n * Please report bugs on https://github.com/matthiasmullie/minify/issues\n *\n * @author Matthias Mullie <minify@mullie.eu>\n * @copyright Copyright (c) 2012, Matthias Mullie. All rights reserved\n * @license MIT License\n */\n\nnamespace WP_Rocket\\Dependencies\\Minify;\n\nuse WP_Rocket\\Dependencies\\Minify\\Exceptions\\FileImportException;\nuse WP_Rocket\\Dependencies\\PathConverter\\ConverterInterface;\nuse WP_Rocket\\Dependencies\\PathConverter\\Converter;\n\n/**\n * CSS minifier\n *\n * Please report bugs on https://github.com/matthiasmullie/minify/issues\n *\n * @package Minify\n * @author Matthias Mullie <minify@mullie.eu>\n * @author Tijs Verkoyen <minify@verkoyen.eu>\n * @copyright Copyright (c) 2012, Matthias Mullie. All rights reserved\n * @license MIT License\n */\nclass CSS extends Minify\n{\n\t/**\n\t * @var int maximum inport size in kB\n\t */\n\tprotected $maxImportSize = 5;\n\n\t/**\n\t * @var string[] valid import extensions\n\t */\n\tprotected $importExtensions = array(\n\t\t'gif' => 'data:image/gif',\n\t\t'png' => 'data:image/png',\n\t\t'jpe' => 'data:image/jpeg',\n\t\t'jpg' => 'data:image/jpeg',\n\t\t'jpeg' => 'data:image/jpeg',\n\t\t'svg' => 'data:image/svg+xml',\n\t\t'woff' => 'data:application/x-font-woff',\n\t\t'tif' => 'image/tiff',\n\t\t'tiff' => 'image/tiff',\n\t\t'xbm' => 'image/x-xbitmap',\n\t);\n\n\t/**\n\t * Set the maximum size if files to be imported.\n\t *\n\t * Files larger than this size (in kB) will not be imported into the CSS.\n\t * Importing files into the CSS as data-uri will save you some connections,\n\t * but we should only import relatively small decorative images so that our\n\t * CSS file doesn't get too bulky.\n\t *\n\t * @param int $size Size in kB\n\t */\n\tpublic function setMaxImportSize($size)\n\t{\n\t\t$this->maxImportSize = $size;\n\t}\n\n\t/**\n\t * Set the type of extensions to be imported into the CSS (to save network\n\t * connections).\n\t * Keys of the array should be the file extensions & respective values\n\t * should be the data type.\n\t *\n\t * @param string[] $extensions Array of file extensions\n\t */\n\tpublic function setImportExtensions(array $extensions)\n\t{\n\t\t$this->importExtensions = $extensions;\n\t}\n\n\t/**\n\t * Move any import statements to the top.\n\t *\n\t * @param string $content Nearly finished CSS content\n\t *\n\t * @return string\n\t */\n\tprotected function moveImportsToTop($content)\n\t{\n\t\tif (preg_match_all('/(;?)(@import (?<url>url\\()?(?P<quotes>[\"\\']?).+?(?P=quotes)(?(url)\\)));?/', $content, $matches)) {\n\t\t\t// remove from content\n\t\t\tforeach ($matches[0] as $import) {\n\t\t\t\t$content = str_replace($import, '', $content);\n\t\t\t}\n\n\t\t\t// add to top\n\t\t\t$content = implode(';', $matches[2]).';'.trim($content, ';');\n\t\t}\n\n\t\treturn $content;\n\t}\n\n\t/**\n\t * Combine CSS from import statements.\n\t *\n\t * @import's will be loaded and their content merged into the original file,\n\t * to save HTTP requests.\n\t *\n\t * @param string   $source  The file to combine imports for\n\t * @param string   $content The CSS content to combine imports for\n\t * @param string[] $parents Parent paths, for circular reference checks\n\t *\n\t * @return string\n\t *\n\t * @throws FileImportException\n\t */\n\tprotected function combineImports($source, $content, $parents)\n\t{\n\t\t$importRegexes = array(\n\t\t\t// @import url(xxx)\n\t\t\t'/\n\t\t\t# import statement\n\t\t\t@import\n\n\t\t\t# whitespace\n\t\t\t\\s+\n\n\t\t\t\t# open url()\n\t\t\t\turl\\(\n\n\t\t\t\t\t# (optional) open path enclosure\n\t\t\t\t\t(?P<quotes>[\"\\']?)\n\n\t\t\t\t\t\t# fetch path\n\t\t\t\t\t\t(?P<path>.+?)\n\n\t\t\t\t\t# (optional) close path enclosure\n\t\t\t\t\t(?P=quotes)\n\n\t\t\t\t# close url()\n\t\t\t\t\\)\n\n\t\t\t\t# (optional) trailing whitespace\n\t\t\t\t\\s*\n\n\t\t\t\t# (optional) media statement(s)\n\t\t\t\t(?P<media>[^;]*)\n\n\t\t\t\t# (optional) trailing whitespace\n\t\t\t\t\\s*\n\n\t\t\t# (optional) closing semi-colon\n\t\t\t;?\n\n\t\t\t/ix',\n\n\t\t\t// @import 'xxx'\n\t\t\t'/\n\n\t\t\t# import statement\n\t\t\t@import\n\n\t\t\t# whitespace\n\t\t\t\\s+\n\n\t\t\t\t# open path enclosure\n\t\t\t\t(?P<quotes>[\"\\'])\n\n\t\t\t\t\t# fetch path\n\t\t\t\t\t(?P<path>.+?)\n\n\t\t\t\t# close path enclosure\n\t\t\t\t(?P=quotes)\n\n\t\t\t\t# (optional) trailing whitespace\n\t\t\t\t\\s*\n\n\t\t\t\t# (optional) media statement(s)\n\t\t\t\t(?P<media>[^;]*)\n\n\t\t\t\t# (optional) trailing whitespace\n\t\t\t\t\\s*\n\n\t\t\t# (optional) closing semi-colon\n\t\t\t;?\n\n\t\t\t/ix',\n\t\t);\n\n\t\t// find all relative imports in css\n\t\t$matches = array();\n\t\tforeach ($importRegexes as $importRegex) {\n\t\t\tif (preg_match_all($importRegex, $content, $regexMatches, PREG_SET_ORDER)) {\n\t\t\t\t$matches = array_merge($matches, $regexMatches);\n\t\t\t}\n\t\t}\n\n\t\t$search = array();\n\t\t$replace = array();\n\n\t\t// loop the matches\n\t\tforeach ($matches as $match) {\n\t\t\t// get the path for the file that will be imported\n\t\t\t$importPath = dirname($source).'/'.$match['path'];\n\n\t\t\t// only replace the import with the content if we can grab the\n\t\t\t// content of the file\n\t\t\tif (!$this->canImportByPath($match['path']) || !$this->canImportFile($importPath)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// check if current file was not imported previously in the same\n\t\t\t// import chain.\n\t\t\tif (in_array($importPath, $parents)) {\n\t\t\t\tthrow new FileImportException('Failed to import file \"'.$importPath.'\": circular reference detected.');\n\t\t\t}\n\n\t\t\t// grab referenced file & minify it (which may include importing\n\t\t\t// yet other @import statements recursively)\n\t\t\t$minifier = new self($importPath);\n\t\t\t$minifier->setMaxImportSize($this->maxImportSize);\n\t\t\t$minifier->setImportExtensions($this->importExtensions);\n\t\t\t$importContent = $minifier->execute($source, $parents);\n\n\t\t\t// check if this is only valid for certain media\n\t\t\tif (!empty($match['media'])) {\n\t\t\t\t$importContent = '@media '.$match['media'].'{'.$importContent.'}';\n\t\t\t}\n\n\t\t\t// add to replacement array\n\t\t\t$search[] = $match[0];\n\t\t\t$replace[] = $importContent;\n\t\t}\n\n\t\t// replace the import statements\n\t\treturn str_replace($search, $replace, $content);\n\t}\n\n\t/**\n\t * Import files into the CSS, base64-ized.\n\t *\n\t * @url(image.jpg) images will be loaded and their content merged into the\n\t * original file, to save HTTP requests.\n\t *\n\t * @param string $source  The file to import files for\n\t * @param string $content The CSS content to import files for\n\t *\n\t * @return string\n\t */\n\tprotected function importFiles($source, $content)\n\t{\n\t\t$regex = '/url\\(([\"\\']?)(.+?)\\\\1\\)/i';\n\t\tif ($this->importExtensions && preg_match_all($regex, $content, $matches, PREG_SET_ORDER)) {\n\t\t\t$search = array();\n\t\t\t$replace = array();\n\n\t\t\t// loop the matches\n\t\t\tforeach ($matches as $match) {\n\t\t\t\t$extension = substr(strrchr($match[2], '.'), 1);\n\t\t\t\tif ($extension && !array_key_exists($extension, $this->importExtensions)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// get the path for the file that will be imported\n\t\t\t\t$path = $match[2];\n\t\t\t\t$path = dirname($source).'/'.$path;\n\n\t\t\t\t// only replace the import with the content if we're able to get\n\t\t\t\t// the content of the file, and it's relatively small\n\t\t\t\tif ($this->canImportFile($path) && $this->canImportBySize($path)) {\n\t\t\t\t\t// grab content && base64-ize\n\t\t\t\t\t$importContent = $this->load($path);\n\t\t\t\t\t$importContent = base64_encode($importContent);\n\n\t\t\t\t\t// build replacement\n\t\t\t\t\t$search[] = $match[0];\n\t\t\t\t\t$replace[] = 'url('.$this->importExtensions[$extension].';base64,'.$importContent.')';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// replace the import statements\n\t\t\t$content = str_replace($search, $replace, $content);\n\t\t}\n\n\t\treturn $content;\n\t}\n\n\t/**\n\t * Minify the data.\n\t * Perform CSS optimizations.\n\t *\n\t * @param string[optional] $path    Path to write the data to\n\t * @param string[]         $parents Parent paths, for circular reference checks\n\t *\n\t * @return string The minified data\n\t */\n\tpublic function execute($path = null, $parents = array())\n\t{\n\t\t$content = '';\n\n\t\t// loop CSS data (raw data and files)\n\t\tforeach ($this->data as $source => $css) {\n\t\t\t/*\n\t\t\t * Let's first take out strings & comments, since we can't just\n\t\t\t * remove whitespace anywhere. If whitespace occurs inside a string,\n\t\t\t * we should leave it alone. E.g.:\n\t\t\t * p { content: \"a   test\" }\n\t\t\t */\n\t\t\t$this->extractStrings();\n\t\t\t$this->stripComments();\n\t\t\t$this->extractMath();\n\t\t\t$this->extractCustomProperties();\n\t\t\t$css = $this->replace($css);\n\n\t\t\t$css = $this->stripWhitespace($css);\n\t\t\t$css = $this->shortenColors($css);\n\t\t\t$css = $this->shortenZeroes($css);\n\t\t\t$css = $this->shortenFontWeights($css);\n\t\t\t$css = $this->stripEmptyTags($css);\n\n\t\t\t// restore the string we've extracted earlier\n\t\t\t$css = $this->restoreExtractedData($css);\n\n\t\t\t$source = is_int($source) ? '' : $source;\n\t\t\t$parents = $source ? array_merge($parents, array($source)) : $parents;\n\t\t\t$css = $this->combineImports($source, $css, $parents);\n\t\t\t$css = $this->importFiles($source, $css);\n\n\t\t\t/*\n\t\t\t * If we'll save to a new path, we'll have to fix the relative paths\n\t\t\t * to be relative no longer to the source file, but to the new path.\n\t\t\t * If we don't write to a file, fall back to same path so no\n\t\t\t * conversion happens (because we still want it to go through most\n\t\t\t * of the move code, which also addresses url() & @import syntax...)\n\t\t\t */\n\t\t\t$converter = $this->getPathConverter($source, $path ?: $source);\n\t\t\t$css = $this->move($converter, $css);\n\n\t\t\t// combine css\n\t\t\t$content .= $css;\n\t\t}\n\n\t\t$content = $this->moveImportsToTop($content);\n\n\t\treturn $content;\n\t}\n\n\t/**\n\t * Moving a css file should update all relative urls.\n\t * Relative references (e.g. ../images/image.gif) in a certain css file,\n\t * will have to be updated when a file is being saved at another location\n\t * (e.g. ../../images/image.gif, if the new CSS file is 1 folder deeper).\n\t *\n\t * @param ConverterInterface $converter Relative path converter\n\t * @param string             $content   The CSS content to update relative urls for\n\t *\n\t * @return string\n\t */\n\tprotected function move(ConverterInterface $converter, $content)\n\t{\n\t\t/*\n\t\t * Relative path references will usually be enclosed by url(). @import\n\t\t * is an exception, where url() is not necessary around the path (but is\n\t\t * allowed).\n\t\t * This *could* be 1 regular expression, where both regular expressions\n\t\t * in this array are on different sides of a |. But we're using named\n\t\t * patterns in both regexes, the same name on both regexes. This is only\n\t\t * possible with a (?J) modifier, but that only works after a fairly\n\t\t * recent PCRE version. That's why I'm doing 2 separate regular\n\t\t * expressions & combining the matches after executing of both.\n\t\t */\n\t\t$relativeRegexes = array(\n\t\t\t// url(xxx)\n\t\t\t'/\n\t\t\t# open url()\n\t\t\turl\\(\n\n\t\t\t\t\\s*\n\n\t\t\t\t# open path enclosure\n\t\t\t\t(?P<quotes>[\"\\'])?\n\n\t\t\t\t\t# fetch path\n\t\t\t\t\t(?P<path>.+?)\n\n\t\t\t\t# close path enclosure\n\t\t\t\t(?(quotes)(?P=quotes))\n\n\t\t\t\t\\s*\n\n\t\t\t# close url()\n\t\t\t\\)\n\n\t\t\t/ix',\n\n\t\t\t// @import \"xxx\"\n\t\t\t'/\n\t\t\t# import statement\n\t\t\t@import\n\n\t\t\t# whitespace\n\t\t\t\\s+\n\n\t\t\t\t# we don\\'t have to check for @import url(), because the\n\t\t\t\t# condition above will already catch these\n\n\t\t\t\t# open path enclosure\n\t\t\t\t(?P<quotes>[\"\\'])\n\n\t\t\t\t\t# fetch path\n\t\t\t\t\t(?P<path>.+?)\n\n\t\t\t\t# close path enclosure\n\t\t\t\t(?P=quotes)\n\n\t\t\t/ix',\n\t\t);\n\n\t\t// find all relative urls in css\n\t\t$matches = array();\n\t\tforeach ($relativeRegexes as $relativeRegex) {\n\t\t\tif (preg_match_all($relativeRegex, $content, $regexMatches, PREG_SET_ORDER)) {\n\t\t\t\t$matches = array_merge($matches, $regexMatches);\n\t\t\t}\n\t\t}\n\n\t\t$search = array();\n\t\t$replace = array();\n\n\t\t// loop all urls\n\t\tforeach ($matches as $match) {\n\t\t\t// determine if it's a url() or an @import match\n\t\t\t$type = (strpos($match[0], '@import') === 0 ? 'import' : 'url');\n\n\t\t\t$url = $match['path'];\n\t\t\tif ($this->canImportByPath($url)) {\n\t\t\t\t// attempting to interpret GET-params makes no sense, so let's discard them for awhile\n\t\t\t\t$params = strrchr($url, '?');\n\t\t\t\t$url = $params ? substr($url, 0, -strlen($params)) : $url;\n\n\t\t\t\t// fix relative url\n\t\t\t\t$url = $converter->convert($url);\n\n\t\t\t\t// now that the path has been converted, re-apply GET-params\n\t\t\t\t$url .= $params;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Urls with control characters above 0x7e should be quoted.\n\t\t\t * According to Mozilla's parser, whitespace is only allowed at the\n\t\t\t * end of unquoted urls.\n\t\t\t * Urls with `)` (as could happen with data: uris) should also be\n\t\t\t * quoted to avoid being confused for the url() closing parentheses.\n\t\t\t * And urls with a # have also been reported to cause issues.\n\t\t\t * Urls with quotes inside should also remain escaped.\n\t\t\t *\n\t\t\t * @see https://developer.mozilla.org/nl/docs/Web/CSS/url#The_url()_functional_notation\n\t\t\t * @see https://hg.mozilla.org/mozilla-central/rev/14abca4e7378\n\t\t\t * @see https://github.com/matthiasmullie/minify/issues/193\n\t\t\t */\n\t\t\t$url = trim($url);\n\t\t\tif (preg_match('/[\\s\\)\\'\"#\\x{7f}-\\x{9f}]/u', $url)) {\n\t\t\t\t$url = $match['quotes'] . $url . $match['quotes'];\n\t\t\t}\n\n\t\t\t// build replacement\n\t\t\t$search[] = $match[0];\n\t\t\tif ($type === 'url') {\n\t\t\t\t$replace[] = 'url('.$url.')';\n\t\t\t} elseif ($type === 'import') {\n\t\t\t\t$replace[] = '@import \"'.$url.'\"';\n\t\t\t}\n\t\t}\n\n\t\t// replace urls\n\t\treturn str_replace($search, $replace, $content);\n\t}\n\n\t/**\n\t * Shorthand hex color codes.\n\t * #FF0000 -> #F00.\n\t *\n\t * @param string $content The CSS content to shorten the hex color codes for\n\t *\n\t * @return string\n\t */\n\tprotected function shortenColors($content)\n\t{\n\t\t$content = preg_replace('/(?<=[: ])#([0-9a-z])\\\\1([0-9a-z])\\\\2([0-9a-z])\\\\3(?:([0-9a-z])\\\\4)?(?=[; }])/i', '#$1$2$3$4', $content);\n\n\t\t// remove alpha channel if it's pointless...\n\t\t$content = preg_replace('/(?<=[: ])#([0-9a-z]{6})ff?(?=[; }])/i', '#$1', $content);\n\t\t$content = preg_replace('/(?<=[: ])#([0-9a-z]{3})f?(?=[; }])/i', '#$1', $content);\n\n\t\t$colors = array(\n\t\t\t// we can shorten some even more by replacing them with their color name\n\t\t\t'#F0FFFF' => 'azure',\n\t\t\t'#F5F5DC' => 'beige',\n\t\t\t'#A52A2A' => 'brown',\n\t\t\t'#FF7F50' => 'coral',\n\t\t\t'#FFD700' => 'gold',\n\t\t\t'#808080' => 'gray',\n\t\t\t'#008000' => 'green',\n\t\t\t'#4B0082' => 'indigo',\n\t\t\t'#FFFFF0' => 'ivory',\n\t\t\t'#F0E68C' => 'khaki',\n\t\t\t'#FAF0E6' => 'linen',\n\t\t\t'#800000' => 'maroon',\n\t\t\t'#000080' => 'navy',\n\t\t\t'#808000' => 'olive',\n\t\t\t'#CD853F' => 'peru',\n\t\t\t'#FFC0CB' => 'pink',\n\t\t\t'#DDA0DD' => 'plum',\n\t\t\t'#800080' => 'purple',\n\t\t\t'#F00' => 'red',\n\t\t\t'#FA8072' => 'salmon',\n\t\t\t'#A0522D' => 'sienna',\n\t\t\t'#C0C0C0' => 'silver',\n\t\t\t'#FFFAFA' => 'snow',\n\t\t\t'#D2B48C' => 'tan',\n\t\t\t'#FF6347' => 'tomato',\n\t\t\t'#EE82EE' => 'violet',\n\t\t\t'#F5DEB3' => 'wheat',\n\t\t\t// or the other way around\n\t\t\t'WHITE' => '#fff',\n\t\t\t'BLACK' => '#000',\n\t\t);\n\n\t\treturn preg_replace_callback(\n\t\t\t'/(?<=[: ])('.implode('|', array_keys($colors)).')(?=[; }])/i',\n\t\t\tfunction ($match) use ($colors) {\n\t\t\t\treturn $colors[strtoupper($match[0])];\n\t\t\t},\n\t\t\t$content\n\t\t);\n\t}\n\n\t/**\n\t * Shorten CSS font weights.\n\t *\n\t * @param string $content The CSS content to shorten the font weights for\n\t *\n\t * @return string\n\t */\n\tprotected function shortenFontWeights($content)\n\t{\n\t\t$weights = array(\n\t\t\t'normal' => 400,\n\t\t\t'bold' => 700,\n\t\t);\n\n\t\t$callback = function ($match) use ($weights) {\n\t\t\treturn $match[1].$weights[$match[2]];\n\t\t};\n\n\t\treturn preg_replace_callback('/(font-weight\\s*:\\s*)('.implode('|', array_keys($weights)).')(?=[;}])/', $callback, $content);\n\t}\n\n\t/**\n\t * Shorthand 0 values to plain 0, instead of e.g. -0em.\n\t *\n\t * @param string $content The CSS content to shorten the zero values for\n\t *\n\t * @return string\n\t */\n\tprotected function shortenZeroes($content)\n\t{\n\t\t// we don't want to strip units in `calc()` expressions:\n\t\t// `5px - 0px` is valid, but `5px - 0` is not\n\t\t// `10px * 0` is valid (equates to 0), and so is `10 * 0px`, but\n\t\t// `10 * 0` is invalid\n\t\t// we've extracted calcs earlier, so we don't need to worry about this\n\n\t\t// reusable bits of code throughout these regexes:\n\t\t// before & after are used to make sure we don't match lose unintended\n\t\t// 0-like values (e.g. in #000, or in http://url/1.0)\n\t\t// units can be stripped from 0 values, or used to recognize non 0\n\t\t// values (where wa may be able to strip a .0 suffix)\n\t\t$before = '(?<=[:(, ])';\n\t\t$after = '(?=[ ,);}])';\n\t\t$units = '(em|ex|%|px|cm|mm|in|pt|pc|ch|rem|vh|vw|vmin|vmax|vm)';\n\n\t\t// strip units after zeroes (0px -> 0)\n\t\t// NOTE: it should be safe to remove all units for a 0 value, but in\n\t\t// practice, Webkit (especially Safari) seems to stumble over at least\n\t\t// 0%, potentially other units as well. Only stripping 'px' for now.\n\t\t// @see https://github.com/matthiasmullie/minify/issues/60\n\t\t$content = preg_replace('/'.$before.'(-?0*(\\.0+)?)(?<=0)px'.$after.'/', '\\\\1', $content);\n\n\t\t// strip 0-digits (.0 -> 0)\n\t\t$content = preg_replace('/'.$before.'\\.0+'.$units.'?'.$after.'/', '0\\\\1', $content);\n\t\t// strip trailing 0: 50.10 -> 50.1, 50.10px -> 50.1px\n\t\t$content = preg_replace('/'.$before.'(-?[0-9]+\\.[0-9]+)0+'.$units.'?'.$after.'/', '\\\\1\\\\2', $content);\n\t\t// strip trailing 0: 50.00 -> 50, 50.00px -> 50px\n\t\t$content = preg_replace('/'.$before.'(-?[0-9]+)\\.0+'.$units.'?'.$after.'/', '\\\\1\\\\2', $content);\n\t\t// strip leading 0: 0.1 -> .1, 01.1 -> 1.1\n\t\t$content = preg_replace('/'.$before.'(-?)0+([0-9]*\\.[0-9]+)'.$units.'?'.$after.'/', '\\\\1\\\\2\\\\3', $content);\n\n\t\t// strip negative zeroes (-0 -> 0) & truncate zeroes (00 -> 0)\n\t\t$content = preg_replace('/'.$before.'-?0+'.$units.'?'.$after.'/', '0\\\\1', $content);\n\n\t\t// IE doesn't seem to understand a unitless flex-basis value (correct -\n\t\t// it goes against the spec), so let's add it in again (make it `%`,\n\t\t// which is only 1 char: 0%, 0px, 0 anything, it's all just the same)\n\t\t// @see https://developer.mozilla.org/nl/docs/Web/CSS/flex\n\t\t$content = preg_replace('/flex:([0-9]+\\s[0-9]+\\s)0([;\\}])/', 'flex:${1}0%${2}', $content);\n\t\t$content = preg_replace('/flex-basis:0([;\\}])/', 'flex-basis:0%${1}', $content);\n\n\t\treturn $content;\n\t}\n\n\t/**\n\t * Strip empty tags from source code.\n\t *\n\t * @param string $content\n\t *\n\t * @return string\n\t */\n\tprotected function stripEmptyTags($content)\n\t{\n\t\t$content = preg_replace('/(?<=^)[^\\{\\};]+\\{\\s*\\}/', '', $content);\n\t\t$content = preg_replace('/(?<=(\\}|;))[^\\{\\};]+\\{\\s*\\}/', '', $content);\n\n\t\treturn $content;\n\t}\n\n\t/**\n\t * Strip comments from source code.\n\t */\n\tprotected function stripComments()\n\t{\n\t\t// PHP only supports $this inside anonymous functions since 5.4\n\t\t$minifier = $this;\n\t\t$callback = function ($match) use ($minifier) {\n\t\t\t$count = count($minifier->extracted);\n\t\t\t$placeholder = '/*'.$count.'*/';\n\t\t\t$minifier->extracted[$placeholder] = $match[0];\n\n\t\t\treturn $placeholder;\n\t\t};\n\t\t$this->registerPattern('/\\n?\\/\\*(!|.*?@license|.*?@preserve).*?\\*\\/\\n?/s', $callback);\n\n\t\t$this->registerPattern('/\\/\\*.*?\\*\\//s', '');\n\t}\n\n\t/**\n\t * Strip whitespace.\n\t *\n\t * @param string $content The CSS content to strip the whitespace for\n\t *\n\t * @return string\n\t */\n\tprotected function stripWhitespace($content)\n\t{\n\t\t// remove leading & trailing whitespace\n\t\t$content = preg_replace('/^\\s*/m', '', $content);\n\t\t$content = preg_replace('/\\s*$/m', '', $content);\n\n\t\t// replace newlines with a single space\n\t\t$content = preg_replace('/\\s+/', ' ', $content);\n\n\t\t// remove whitespace around meta characters\n\t\t// inspired by stackoverflow.com/questions/15195750/minify-compress-css-with-regex\n\t\t$content = preg_replace('/\\s*([\\*$~^|]?+=|[{};,>~]|!important\\b)\\s*/', '$1', $content);\n\t\t$content = preg_replace('/([\\[(:>\\+])\\s+/', '$1', $content);\n\t\t$content = preg_replace('/\\s+([\\]\\)>\\+])/', '$1', $content);\n\t\t$content = preg_replace('/\\s+(:)(?![^\\}]*\\{)/', '$1', $content);\n\n\t\t// whitespace around + and - can only be stripped inside some pseudo-\n\t\t// classes, like `:nth-child(3+2n)`\n\t\t// not in things like `calc(3px + 2px)`, shorthands like `3px -2px`, or\n\t\t// selectors like `div.weird- p`\n\t\t$pseudos = array('nth-child', 'nth-last-child', 'nth-last-of-type', 'nth-of-type');\n\t\t$content = preg_replace('/:('.implode('|', $pseudos).')\\(\\s*([+-]?)\\s*(.+?)\\s*([+-]?)\\s*(.*?)\\s*\\)/', ':$1($2$3$4$5)', $content);\n\n\t\t// remove semicolon/whitespace followed by closing bracket\n\t\t$content = str_replace(';}', '}', $content);\n\n\t\treturn trim($content);\n\t}\n\n\t/**\n\t * Replace all occurrences of functions that may contain math, where\n\t * whitespace around operators needs to be preserved (e.g. calc, clamp)\n\t */\n\tprotected function extractMath()\n\t{\n\t\t$functions = array('calc', 'clamp', 'min', 'max');\n\t\t$pattern = '/\\b('. implode('|', $functions) .')(\\(.+?)(?=$|;|})/m';\n\n\t\t// PHP only supports $this inside anonymous functions since 5.4\n\t\t$minifier = $this;\n\t\t$callback = function ($match) use ($minifier, $pattern, &$callback) {\n\t\t\t$function = $match[1];\n\t\t\t$length = strlen($match[2]);\n\t\t\t$expr = '';\n\t\t\t$opened = 0;\n\n\t\t\t// the regular expression for extracting math has 1 significant problem:\n\t\t\t// it can't determine the correct closing parenthesis...\n\t\t\t// instead, it'll match a larger portion of code to where it's certain that\n\t\t\t// the calc() musts have ended, and we'll figure out which is the correct\n\t\t\t// closing parenthesis here, by counting how many have opened\n\t\t\tfor ($i = 0; $i < $length; $i++) {\n\t\t\t\t$char = $match[2][$i];\n\t\t\t\t$expr .= $char;\n\t\t\t\tif ($char === '(') {\n\t\t\t\t\t$opened++;\n\t\t\t\t} elseif ($char === ')' && --$opened === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now that we've figured out where the calc() starts and ends, extract it\n\t\t\t$count = count($minifier->extracted);\n\t\t\t$placeholder = 'math('.$count.')';\n\t\t\t$minifier->extracted[$placeholder] = $function.'('.trim(substr($expr, 1, -1)).')';\n\n\t\t\t// and since we've captured more code than required, we may have some leftover\n\t\t\t// calc() in here too - go recursive on the remaining but of code to go figure\n\t\t\t// that out and extract what is needed\n\t\t\t$rest = \"\";\n\t\t\t$pos  = strpos($match[0], $function.$expr);\n\t\t\tif ($pos !== false) {\n\t\t\t\t$rest = substr_replace($match[0], '', $pos, strlen($function.$expr));\n\t\t\t}\n\t\t\t$rest = preg_replace_callback($pattern, $callback, $rest);\n\n\t\t\treturn $placeholder.$rest;\n\t\t};\n\n\t\t$this->registerPattern($pattern, $callback);\n\t}\n\n\t/**\n\t * Replace custom properties, whose values may be used in scenarios where\n\t * we wouldn't want them to be minified (e.g. inside calc)\n\t */\n\tprotected function extractCustomProperties()\n\t{\n\t\t// PHP only supports $this inside anonymous functions since 5.4\n\t\t$minifier = $this;\n\t\t$this->registerPattern(\n\t\t\t'/(?<=^|[;}])\\s*(--[^:;{}\"\\'\\s]+)\\s*:([^;{}]+)/m',\n\t\t\tfunction ($match) use ($minifier) {\n\t\t\t\t$placeholder = '--custom-'. count($minifier->extracted) . ':0';\n\t\t\t\t$minifier->extracted[$placeholder] = $match[1] .':'. trim($match[2]);\n\t\t\t\treturn $placeholder;\n\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Check if file is small enough to be imported.\n\t *\n\t * @param string $path The path to the file\n\t *\n\t * @return bool\n\t */\n\tprotected function canImportBySize($path)\n\t{\n\t\treturn ($size = @filesize($path)) && $size <= $this->maxImportSize * 1024;\n\t}\n\n\t/**\n\t * Check if file a file can be imported, going by the path.\n\t *\n\t * @param string $path\n\t *\n\t * @return bool\n\t */\n\tprotected function canImportByPath($path)\n\t{\n\t\treturn preg_match('/^(data:|https?:|\\\\/)/', $path) === 0;\n\t}\n\n\t/**\n\t * Return a converter to update relative paths to be relative to the new\n\t * destination.\n\t *\n\t * @param string $source\n\t * @param string $target\n\t *\n\t * @return ConverterInterface\n\t */\n\tprotected function getPathConverter($source, $target)\n\t{\n\t\treturn new Converter($source, $target);\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/Minify/CSS.php b/inc/Dependencies/Minify/CSS.php
--- a/inc/Dependencies/Minify/CSS.php	(revision 1894bcd4ece464661acf0f8d25ce23109ace6bd7)
+++ b/inc/Dependencies/Minify/CSS.php	(date 1675335508460)
@@ -740,7 +740,7 @@
 		// PHP only supports $this inside anonymous functions since 5.4
 		$minifier = $this;
 		$this->registerPattern(
-			'/(?<=^|[;}])\s*(--[^:;{}"\'\s]+)\s*:([^;{}]+)/m',
+			'/(?<=^|[;}{])\s*(--[^:;{}"\'\s]+)\s*:([^;{}]+)/m',
 			function ($match) use ($minifier) {
 				$placeholder = '--custom-'. count($minifier->extracted) . ':0';
 				$minifier->extracted[$placeholder] = $match[1] .':'. trim($match[2]);
Index: assets/css/wpr-modal.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>.wpr-modal {\n\tdisplay: none;\n}\n\n.wpr-modal.is-open {\n\tdisplay: block;\n}\n\n.wpr-modal-overlay {\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tbottom: 0;\n\tbackground: rgba(0,0,0,0.6);\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n}\n\n.wpr-modal-container {\n\tbackground-color: #fff;\n\tpadding: 30px;\n\tmax-width: 645px;\n\tmax-height: 100vh;\n\toverflow-y: auto;\n\tbox-sizing: border-box;\n}\n\n.wpr-modal-header,\n.wpr-modal-footer {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\talign-items: center;\n}\n\n.wpr-modal-title {\n\tfont-size: 26px;\n\tfont-weight: 600;\n\tline-height: 1.2;\n\tmargin: 0;\n}\n\n.wpr-modal-footer {\n\tmargin-top: 40px;\n}\n\n.wpr-modal-button {\n\tborder-radius: 4px;\n\tcursor: pointer;\n\tpadding: 8px 20px;\n\ttext-transform: uppercase;\n}\n\n.wpr-modal-cancel {\n\tbackground: transparent;\n\tborder: 1px solid #000;\n}\n\n.wpr-modal-confirm {\n\tbackground: #F56F46;\n\tborder: none;\n\tbox-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);\n\tcolor: #fff;\n\ttransition: box-shadow 500ms ease-in;\n}\n\n.wpr-modal-confirm:hover {\n\tbox-shadow: none;\n}\n\n.wpr-modal .wpr-sub-list {\n\tpadding-left: 25px;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/assets/css/wpr-modal.css b/assets/css/wpr-modal.css
--- a/assets/css/wpr-modal.css	(revision 1894bcd4ece464661acf0f8d25ce23109ace6bd7)
+++ b/assets/css/wpr-modal.css	(date 1675335559036)
@@ -72,3 +72,6 @@
 .wpr-modal .wpr-sub-list {
 	padding-left: 25px;
 }
+.wpr-modal .wpr-sub-list {
+	padding-left: 25px;
+}
Index: inc/Dependencies/RocketLazyload/Image.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\ndeclare(strict_types=1);\n\n/**\n * Handles lazyloading of images\n *\n * @package WP_Rocket\\Dependencies\\RocketLazyload\n */\n\nnamespace WP_Rocket\\Dependencies\\RocketLazyload;\n\n/**\n * A class to provide the methods needed to lazyload images in WP Rocket and Lazyload by WP Rocket\n */\nclass Image {\n\n\t/**\n\t * Finds the images to be lazyloaded and call the callback method to replace them.\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @param bool   $use_native Use native lazyload.\n\t * @return string\n\t */\n\tpublic function lazyloadImages( $html, $buffer, $use_native = true ) {\n\t\tif ( ! preg_match_all( '#<img(?<atts>\\s.+)\\s?/?>#iUs', $buffer, $images, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$images = array_unique( $images, SORT_REGULAR );\n\n\t\tforeach ( $images as $image ) {\n\t\t\t$image = $this->canLazyload( $image );\n\n\t\t\tif ( ! $image ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$image_lazyload = $this->replaceImage( $image, $use_native );\n\n\t\t\tif ( ! $use_native ) {\n\t\t\t\t$image_lazyload .= $this->noscript( $image[0] );\n\t\t\t}\n\n\t\t\t$html = str_replace( $image[0], $image_lazyload, $html );\n\n\t\t\tunset( $image_lazyload );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Applies lazyload on background images defined in style attributes\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @return string\n\t */\n\tpublic function lazyloadBackgroundImages( $html, $buffer ) {\n\t\tif ( ! preg_match_all( '#<(?<tag>div|figure|section|span|li|a)\\s+(?<before>[^>]+[\\'\"\\s])?style\\s*=\\s*([\\'\"])(?<styles>.*?)\\3(?<after>[^>]*)>#is', $buffer, $elements, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\tforeach ( $elements as $element ) {\n\t\t\tif ( $this->isExcluded( $element['before'] . $element['after'], $this->getExcludedAttributes() ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ! preg_match( '#background-image\\s*:\\s*(?<attr>\\s*url\\s*\\((?<url>[^)]+)\\))\\s*;?#is', $element['styles'], $url ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( preg_match( '#data:image#is', $url['url'], $img ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$url['url'] = esc_url(\n\t\t\t\ttrim(\n\t\t\t\t\twp_strip_all_tags(\n\t\t\t\t\t\thtml_entity_decode(\n\t\t\t\t\t\t\t$url['url'],\n\t\t\t\t\t\t\tENT_QUOTES | ENT_HTML5\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\t'\\'\" '\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tif ( $this->isExcluded( $url['url'], $this->getExcludedSrc() ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$lazy_bg = $this->addLazyCLass( $element[0] );\n\t\t\t$lazy_bg = str_replace( $url[0], '', $lazy_bg );\n\t\t\t$lazy_bg = str_replace( '<' . $element['tag'], '<' . $element['tag'] . ' data-bg=\"' . esc_attr( $url['url'] ) . '\"', $lazy_bg );\n\n\t\t\t$html = str_replace( $element[0], $lazy_bg, $html );\n\t\t\tunset( $lazy_bg );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Add the identifier class to the element\n\t *\n\t * @param string $element Element to add the class to.\n\t * @return string\n\t */\n\tprivate function addLazyClass( $element ) {\n\t\t$class = $this->getClasses( $element );\n\t\tif ( empty( $class ) ) {\n\t\t\treturn preg_replace( '#<(img|div|figure|section|li|span|a)([^>]*)>#is', '<\\1 class=\"rocket-lazyload\"\\2>', $element );\n\t\t}\n\n\t\tif ( empty( $class['attribute'] ) || empty( $class['classes'] ) ) {\n\t\t\treturn str_replace( $class['attribute'], 'class=\"rocket-lazyload\"', $element );\n\t\t}\n\n\t\t$quotes  = $this->getAttributeQuotes( $class['classes'] );\n\t\t$classes = $this->trimOuterQuotes( $class['classes'], $quotes );\n\n\t\tif ( empty( $classes ) ) {\n\t\t\treturn str_replace( $class['attribute'], 'class=\"rocket-lazyload\"', $element );\n\t\t}\n\n\t\t$classes .= ' rocket-lazyload';\n\n\t\treturn str_replace(\n\t\t\t$class['attribute'],\n\t\t\t'class=' . $this->normalizeClasses( $classes, $quotes ),\n\t\t\t$element\n\t\t);\n\t}\n\n\t/**\n\t * Gets the attribute value's outer quotation mark, if one exists, i.e. \" or '.\n\t *\n\t * @param string $attribute_value The target attribute's value.\n\t *\n\t * @return bool|string quotation character; else false when no quotation mark.\n\t */\n\tprivate function getAttributeQuotes( $attribute_value ) {\n\t\t$attribute_value = trim( $attribute_value );\n\t\t$first_char      = $attribute_value[0];\n\n\t\tif ( '\"' === $first_char || \"'\" === $first_char ) {\n\t\t\treturn $first_char;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Gets the class attribute and values from the given element, if it exists.\n\t *\n\t * @param string $element Given HTML element to extract classes from.\n\t *\n\t * @return bool|string[] {\n\t *      @type string $attribute Class attribute and value, e.g. class=\"value\"\n\t *      @type string $classes   String of class attribute's value(s)\n\t * }; else, false when no class attribute exists.\n\t */\n\tprivate function getClasses( $element ) {\n\t\tif ( ! preg_match( '#class\\s*=\\s*(?<classes>[\"\\'].*?[\"\\']|[^\\s]+)#is', $element, $class ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $class ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! isset( $class['classes'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn [\n\t\t\t'attribute' => $class[0],\n\t\t\t'classes'   => $class['classes'],\n\t\t];\n\t}\n\n\t/**\n\t * Removes outer single or double quotations.\n\t *\n\t * @param string $string String to strip quotes from.\n\t * @param string $quotes The outer quotes to remove.\n\t *\n\t * @return string string without quotes.\n\t */\n\tprivate function trimOuterQuotes( $string, $quotes ) {\n\t\t$string = trim( $string );\n\t\tif ( empty( $string ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif ( empty( $quotes ) ) {\n\t\t\treturn $string;\n\t\t}\n\n\t\t$string = ltrim( $string, $quotes );\n\t\t$string = rtrim( $string, $quotes );\n\t\treturn trim( $string );\n\t}\n\n\t/**\n\t * Normalizes the class attribute values to ensure well-formed.\n\t *\n\t * @param string      $classes String of class attribute value(s).\n\t * @param string|bool $quotes  Optional. Quotation mark to wrap around the classes.\n\t *\n\t * @return string well-formed class attributes.\n\t */\n\tprivate function normalizeClasses( $classes, $quotes = '\"' ) {\n\t\t$array_of_classes = $this->stringToArray( $classes );\n\t\t$classes          = implode( ' ', $array_of_classes );\n\n\t\tif ( false === $quotes ) {\n\t\t\t$quotes = '\"';\n\t\t}\n\n\t\treturn $quotes . $classes . $quotes;\n\t}\n\n\t/**\n\t * Converts the given string into an array of strings.\n\t *\n\t * Note:\n\t *  1. Removes empties.\n\t *  2. Trims each string.\n\t *\n\t * @param string $string    The target string to convert.\n\t * @param string $delimiter Optional. Default: ' ' empty string.\n\t *\n\t * @return array An array of trimmed strings.\n\t */\n\tprivate function stringToArray( $string, $delimiter = ' ' ) {\n\t\tif ( empty( $string ) ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t$array = explode( $delimiter, $string );\n\t\t$array = array_map( 'trim', $array );\n\n\t\t// Remove empties.\n\t\treturn array_filter( $array );\n\t}\n\n\t/**\n\t * Applies lazyload on picture elements found in the HTML.\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @return string\n\t */\n\tpublic function lazyloadPictures( $html, $buffer ) {\n\t\tif ( ! preg_match_all( '#<picture(?:.*)?>(?<sources>.*)</picture>#iUs', $buffer, $pictures, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$pictures = array_unique( $pictures, SORT_REGULAR );\n\t\t$excluded = array_merge( $this->getExcludedAttributes(), $this->getExcludedSrc() );\n\n\t\tforeach ( $pictures as $picture ) {\n\t\t\tif ( $this->isExcluded( $picture[0], $excluded ) ) {\n\t\t\t\tif ( ! preg_match( '#<img(?<atts>\\s.+)\\s?/?>#iUs', $picture[0], $img ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$img = $this->canLazyload( $img );\n\n\t\t\t\tif ( ! $img ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$nolazy_picture = str_replace( '<img', '<img data-no-lazy=\"\"', $picture[0] );\n\t\t\t\t$html           = str_replace( $picture[0], $nolazy_picture, $html );\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( preg_match_all( '#<source(?<atts>\\s.+)>#iUs', $picture['sources'], $sources, PREG_SET_ORDER ) ) {\n\t\t\t\t$lazy_sources = 0;\n\t\t\t\t$sources      = array_unique( $sources, SORT_REGULAR );\n\t\t\t\t$lazy_picture = $picture[0];\n\n\t\t\t\tforeach ( $sources as $source ) {\n\t\t\t\t\t$lazyload_srcset = preg_replace( '/([\\s\"\\'])srcset/i', '\\1data-lazy-srcset', $source[0] );\n\t\t\t\t\t$lazy_picture    = str_replace( $source[0], $lazyload_srcset, $lazy_picture );\n\n\t\t\t\t\tunset( $lazyload_srcset );\n\t\t\t\t\t$lazy_sources++;\n\t\t\t\t}\n\n\t\t\t\tif ( 0 === $lazy_sources ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$html = str_replace( $picture[0], $lazy_picture, $html );\n\t\t\t}\n\n\t\t\tif ( ! preg_match( '#<img(?<atts>\\s.+)\\s?/?>#iUs', $picture[0], $img ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$img = $this->canLazyload( $img );\n\n\t\t\tif ( ! $img ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$img_lazy  = $this->replaceImage( $img, false );\n\t\t\t$img_lazy .= $this->noscript( $img[0] );\n\t\t\t$safe_img  = str_replace( '/', '\\/', preg_quote( $img[0], '#' ) );\n\t\t\t$html      = preg_replace( '#<noscript[^>]*>.*' . $safe_img . '.*<\\/noscript>(*SKIP)(*FAIL)|' . $safe_img . '#i', $img_lazy, $html );\n\n\t\t\tunset( $img_lazy );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Checks if the image can be lazyloaded\n\t *\n\t * @param Array $image Array of image data coming from Regex.\n\t * @return bool|Array\n\t */\n\tprivate function canLazyload( $image ) {\n\t\tif ( $this->isExcluded( $image['atts'], $this->getExcludedAttributes() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Given the previous regex pattern, $image['atts'] starts with a whitespace character.\n\t\tif ( ! preg_match( '@\\ssrc\\s*=\\s*(\\'|\")(?<src>.*)\\1@iUs', $image['atts'], $atts ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$image['src'] = trim( $atts['src'] );\n\n\t\tif ( '' === $image['src'] ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( $this->isExcluded( $image['src'], $this->getExcludedSrc() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $image;\n\t}\n\n\t/**\n\t * Checks if the provided string matches with the provided excluded patterns\n\t *\n\t * @param string $string          String to check.\n\t * @param array  $excluded_values Patterns to match against.\n\t * @return boolean\n\t */\n\tpublic function isExcluded( $string, $excluded_values ) {\n\t\tif ( ! is_array( $excluded_values ) ) {\n\t\t\t$excluded_values = (array) $excluded_values;\n\t\t}\n\n\t\tif ( empty( $excluded_values ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tforeach ( $excluded_values as $excluded_value ) {\n\t\t\tif ( strpos( $string, $excluded_value ) !== false ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the list of excluded attributes\n\t *\n\t * @return array\n\t */\n\tpublic function getExcludedAttributes() {\n\t\t/**\n\t\t * Filters the attributes used to prevent lazylad from being applied\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param array $excluded_attributes An array of excluded attributes.\n\t\t */\n\t\treturn apply_filters(\n\t\t\t'rocket_lazyload_excluded_attributes',\n\t\t\t[\n\t\t\t\t'data-src=',\n\t\t\t\t'data-no-lazy=',\n\t\t\t\t'data-lazy-original=',\n\t\t\t\t'data-lazy-src=',\n\t\t\t\t'data-lazysrc=',\n\t\t\t\t'data-lazyload=',\n\t\t\t\t'data-bgposition=',\n\t\t\t\t'data-envira-src=',\n\t\t\t\t'fullurl=',\n\t\t\t\t'lazy-slider-img=',\n\t\t\t\t'data-srcset=',\n\t\t\t\t'class=\"ls-l',\n\t\t\t\t'class=\"ls-bg',\n\t\t\t\t'soliloquy-image',\n\t\t\t\t'loading=\"eager\"',\n\t\t\t\t'swatch-img',\n\t\t\t\t'data-height-percentage',\n\t\t\t\t'data-large_image',\n\t\t\t\t'avia-bg-style-fixed',\n\t\t\t\t'data-skip-lazy',\n\t\t\t\t'skip-lazy',\n\t\t\t\t'image-compare__',\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Returns the list of excluded src\n\t *\n\t * @return array\n\t */\n\tpublic function getExcludedSrc() {\n\t\t/**\n\t\t * Filters the src used to prevent lazylad from being applied\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param array $excluded_src An array of excluded src.\n\t\t */\n\t\treturn apply_filters(\n\t\t\t'rocket_lazyload_excluded_src',\n\t\t\t[\n\t\t\t\t'/wpcf7_captcha/',\n\t\t\t\t'timthumb.php?src',\n\t\t\t\t'woocommerce/assets/images/placeholder.png',\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Replaces the original image by the lazyload one\n\t *\n\t * @param array $image Array of matches elements.\n\t * @param bool  $use_native Use native lazyload.\n\t *\n\t * @return string\n\t */\n\tprivate function replaceImage( $image, $use_native = true ) {\n\t\tif ( empty( $image ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$native_pattern = '@\\sloading\\s*=\\s*(\\'|\")(?:lazy|auto)\\1@i';\n\t\t$image_lazyload = $image[0];\n\n\t\tif ( $use_native ) {\n\t\t\tif ( preg_match( $native_pattern, $image[0] ) ) {\n\t\t\t\treturn $image[0];\n\t\t\t}\n\n\t\t\t$image_lazyload = str_replace( '<img', '<img loading=\"lazy\"', $image_lazyload );\n\t\t} else {\n\t\t\t$width  = 0;\n\t\t\t$height = 0;\n\n\t\t\tif ( preg_match( '@[\\s\"\\']width\\s*=\\s*(\\'|\")(?<width>.*)\\1@iUs', $image['atts'], $atts ) ) {\n\t\t\t\t$width = absint( $atts['width'] );\n\t\t\t}\n\n\t\t\tif ( preg_match( '@[\\s\"\\']height\\s*=\\s*(\\'|\")(?<height>.*)\\1@iUs', $image['atts'], $atts ) ) {\n\t\t\t\t$height = absint( $atts['height'] );\n\t\t\t}\n\n\t\t\t$placeholder_atts = preg_replace( '@\\ssrc\\s*=\\s*(\\'|\")(?<src>.*)\\1@iUs', ' src=\"' . $this->getPlaceholder( $width, $height ) . '\"', $image['atts'] );\n\n\t\t\t$image_lazyload = str_replace( $image['atts'], $placeholder_atts . ' data-lazy-src=\"' . $image['src'] . '\"', $image_lazyload );\n\n\t\t\tif ( preg_match( $native_pattern, $image_lazyload ) ) {\n\t\t\t\t$image_lazyload = preg_replace( $native_pattern, '', $image_lazyload );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filter the LazyLoad HTML output\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param string $html Output that will be printed\n\t\t */\n\t\t$image_lazyload = apply_filters( 'rocket_lazyload_html', $image_lazyload );\n\n\t\treturn $image_lazyload;\n\t}\n\n\t/**\n\t * Returns the HTML tag wrapped inside noscript tags\n\t *\n\t * @param string $element Element to wrap.\n\t * @return string\n\t */\n\tprivate function noscript( $element ) {\n\t\treturn '<noscript>' . $element . '</noscript>';\n\t}\n\n\t/**\n\t * Applies lazyload on srcset and sizes attributes\n\t *\n\t * @param string $html HTML image tag.\n\t * @return string\n\t */\n\tpublic function lazyloadResponsiveAttributes( $html ) {\n\t\t$html = preg_replace( '/[\\s|\"|\\'](srcset)\\s*=\\s*(\"|\\')([^\"|\\']+)\\2/i', ' data-lazy-$1=$2$3$2', $html );\n\t\t$html = preg_replace( '/[\\s|\"|\\'](sizes)\\s*=\\s*(\"|\\')([^\"|\\']+)\\2/i', ' data-lazy-$1=$2$3$2', $html );\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Finds patterns matching smiley and call the callback method to replace them with the image\n\t *\n\t * @param string $text Content to search in.\n\t * @return string\n\t */\n\tpublic function convertSmilies( $text ) {\n\t\tglobal $wp_smiliessearch;\n\n\t\tif ( empty( $text ) || ! is_string( $text ) ) {\n\t\t\treturn $text;\n\t\t}\n\n\t\tif ( ! get_option( 'use_smilies' ) || empty( $wp_smiliessearch ) ) {\n\t\t\treturn $text;\n\t\t}\n\n\t\t$output = '';\n\t\t// HTML loop taken from texturize function, could possible be consolidated.\n\t\t$textarr = preg_split( '/(<.*>)/U', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // capture the tags as well as in between.\n\t\t$stop    = count( $textarr );// loop stuff.\n\n\t\t// Ignore proessing of specific tags.\n\t\t$tags_to_ignore       = 'code|pre|style|script|textarea';\n\t\t$ignore_block_element = '';\n\n\t\tfor ( $i = 0; $i < $stop; $i++ ) {\n\t\t\t$content = $textarr[ $i ];\n\n\t\t\t// If we're in an ignore block, wait until we find its closing tag.\n\t\t\tif ( '' === $ignore_block_element && preg_match( '/^<(' . $tags_to_ignore . ')>/', $content, $matches ) ) {\n\t\t\t\t$ignore_block_element = $matches[1];\n\t\t\t}\n\n\t\t\t// If it's not a tag and not in ignore block.\n\t\t\tif ( '' === $ignore_block_element && strlen( $content ) > 0 && '<' !== $content[0] ) {\n\t\t\t\t$content = preg_replace_callback( $wp_smiliessearch, [ $this, 'translateSmiley' ], $content );\n\t\t\t}\n\n\t\t\t// did we exit ignore block.\n\t\t\tif ( '' !== $ignore_block_element && '</' . $ignore_block_element . '>' === $content ) {\n\t\t\t\t$ignore_block_element = '';\n\t\t\t}\n\n\t\t\t$output .= $content;\n\t\t}\n\n\t\treturn $output;\n\t}\n\n\t/**\n\t * Replace matches by smiley image, lazyloaded\n\t *\n\t * @param array $matches Array of matches.\n\t * @return string\n\t */\n\tprivate function translateSmiley( $matches ) {\n\t\tglobal $wpsmiliestrans;\n\n\t\tif ( count( $matches ) === 0 ) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$smiley = trim( reset( $matches ) );\n\t\t$img    = $wpsmiliestrans[ $smiley ];\n\n\t\t$matches    = [];\n\t\t$ext        = preg_match( '/\\.([^.]+)$/', $img, $matches ) ? strtolower( $matches[1] ) : false;\n\t\t$image_exts = [ 'jpg', 'jpeg', 'jpe', 'gif', 'png' ];\n\n\t\t// Don't convert smilies that aren't images - they're probably emoji.\n\t\tif ( ! in_array( $ext, $image_exts, true ) ) {\n\t\t\treturn $img;\n\t\t}\n\n\t\t/**\n\t\t * Filter the Smiley image URL before it's used in the image element.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param string $smiley_url URL for the smiley image.\n\t\t * @param string $img        Filename for the smiley image.\n\t\t * @param string $site_url   Site URL, as returned by site_url().\n\t\t */\n\t\t$src_url = apply_filters( 'smilies_src', includes_url( \"images/smilies/$img\" ), $img, site_url() ); // phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedHooknameFound\n\n\t\t// Don't LazyLoad if process is stopped for these reasons.\n\t\tif ( is_feed() || is_preview() ) {\n\t\t\treturn sprintf( ' <img src=\"%s\" alt=\"%s\" class=\"wp-smiley\" /> ', esc_url( $src_url ), esc_attr( $smiley ) );\n\t\t}\n\n\t\treturn sprintf( ' <img src=\"%s\" data-lazy-src=\"%s\" alt=\"%s\" class=\"wp-smiley\" /> ', $this->getPlaceholder(), esc_url( $src_url ), esc_attr( $smiley ) );\n\t}\n\n\t/**\n\t * Returns the placeholder for the src attribute\n\t *\n\t * @since 1.2\n\t *\n\t * @param int $width  Width of the placeholder image. Default 0.\n\t * @param int $height Height of the placeholder image. Default 0.\n\t * @return string\n\t */\n\tpublic function getPlaceholder( $width = 0, $height = 0 ) {\n\t\t$width  = 0 === $width ? 0 : absint( $width );\n\t\t$height = 0 === $height ? 0 : absint( $height );\n\n\t\t$placeholder = str_replace( ' ', '%20', \"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 $width $height'%3E%3C/svg%3E\" );\n\t\t/**\n\t\t * Filter the image lazyLoad placeholder on src attribute\n\t\t *\n\t\t * @since 1.1\n\t\t *\n\t\t * @param string $placeholder Placeholder that will be printed.\n\t\t * @param int    $width Placeholder width.\n\t\t * @param int    $height Placeholder height.\n\t\t */\n\t\treturn apply_filters( 'rocket_lazyload_placeholder', $placeholder, $width, $height );\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/RocketLazyload/Image.php b/inc/Dependencies/RocketLazyload/Image.php
--- a/inc/Dependencies/RocketLazyload/Image.php	(revision 1894bcd4ece464661acf0f8d25ce23109ace6bd7)
+++ b/inc/Dependencies/RocketLazyload/Image.php	(date 1675335559048)
@@ -67,7 +67,18 @@
 				continue;
 			}
 
-			if ( ! preg_match( '#background-image\s*:\s*(?<attr>\s*url\s*\((?<url>[^)]+)\))\s*;?#is', $element['styles'], $url ) ) {
+			/**
+			 * Regex to detect bg images inside CSS.
+			 * @param string $regex regex to detect.
+			 * @return string
+			 */
+			$regex = apply_filters( 'rocket_lazyload_bg_images_regex', 'background-image\s*:\s*(?<attr>\s*url\s*\((?<url>[^)]+)\))\s*;?' );
+
+			if( @preg_match( "#$regex#is", '' ) === false ) {
+				$regex =  'background-image\s*:\s*(?<attr>\s*url\s*\((?<url>[^)]+)\))\s*;?' ;
+			}
+
+			if ( ! preg_match( "#$regex#is", $element['styles'], $url ) ) {
 				continue;
 			}
 
