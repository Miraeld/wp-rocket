Index: inc/Dependencies/ActionScheduler/classes/ActionScheduler_Exception.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * ActionScheduler Exception Interface.\n *\n * Facilitates catching Exceptions unique to Action Scheduler.\n *\n * @package ActionScheduler\n * @since 2.1.0\n */\ninterface ActionScheduler_Exception {}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_Exception.php b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_Exception.php
--- a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_Exception.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_Exception.php	(date 1675081217861)
@@ -6,6 +6,6 @@
  * Facilitates catching Exceptions unique to Action Scheduler.
  *
  * @package ActionScheduler
- * @since 2.1.0
+ * @since %VERSION%
  */
 interface ActionScheduler_Exception {}
Index: inc/Dependencies/ActionScheduler/classes/ActionScheduler_ListTable.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Implements the admin view of the actions.\n * @codeCoverageIgnore\n */\nclass ActionScheduler_ListTable extends ActionScheduler_Abstract_ListTable {\n\n\t/**\n\t * The package name.\n\t *\n\t * @var string\n\t */\n\tprotected $package = 'action-scheduler';\n\n\t/**\n\t * Columns to show (name => label).\n\t *\n\t * @var array\n\t */\n\tprotected $columns = array();\n\n\t/**\n\t * Actions (name => label).\n\t *\n\t * @var array\n\t */\n\tprotected $row_actions = array();\n\n\t/**\n\t * The active data stores\n\t *\n\t * @var ActionScheduler_Store\n\t */\n\tprotected $store;\n\n\t/**\n\t * A logger to use for getting action logs to display\n\t *\n\t * @var ActionScheduler_Logger\n\t */\n\tprotected $logger;\n\n\t/**\n\t * A ActionScheduler_QueueRunner runner instance (or child class)\n\t *\n\t * @var ActionScheduler_QueueRunner\n\t */\n\tprotected $runner;\n\n\t/**\n\t * Bulk actions. The key of the array is the method name of the implementation:\n\t *\n\t *     bulk_<key>(array $ids, string $sql_in).\n\t *\n\t * See the comments in the parent class for further details\n\t *\n\t * @var array\n\t */\n\tprotected $bulk_actions = array();\n\n\t/**\n\t * Flag variable to render our notifications, if any, once.\n\t *\n\t * @var bool\n\t */\n\tprotected static $did_notification = false;\n\n\t/**\n\t * Array of seconds for common time periods, like week or month, alongside an internationalised string representation, i.e. \"Day\" or \"Days\"\n\t *\n\t * @var array\n\t */\n\tprivate static $time_periods;\n\n\t/**\n\t * Sets the current data store object into `store->action` and initialises the object.\n\t *\n\t * @param ActionScheduler_Store $store\n\t * @param ActionScheduler_Logger $logger\n\t * @param ActionScheduler_QueueRunner $runner\n\t */\n\tpublic function __construct( ActionScheduler_Store $store, ActionScheduler_Logger $logger, ActionScheduler_QueueRunner $runner ) {\n\n\t\t$this->store  = $store;\n\t\t$this->logger = $logger;\n\t\t$this->runner = $runner;\n\n\t\t$this->table_header = __( 'Scheduled Actions', 'action-scheduler' );\n\n\t\t$this->bulk_actions = array(\n\t\t\t'delete' => __( 'Delete', 'action-scheduler' ),\n\t\t);\n\n\t\t$this->columns = array(\n\t\t\t'hook'        => __( 'Hook', 'action-scheduler' ),\n\t\t\t'status'      => __( 'Status', 'action-scheduler' ),\n\t\t\t'args'        => __( 'Arguments', 'action-scheduler' ),\n\t\t\t'group'       => __( 'Group', 'action-scheduler' ),\n\t\t\t'recurrence'  => __( 'Recurrence', 'action-scheduler' ),\n\t\t\t'schedule'    => __( 'Scheduled Date', 'action-scheduler' ),\n\t\t\t'log_entries' => __( 'Log', 'action-scheduler' ),\n\t\t);\n\n\t\t$this->sort_by = array(\n\t\t\t'schedule',\n\t\t\t'hook',\n\t\t\t'group',\n\t\t);\n\n\t\t$this->search_by = array(\n\t\t\t'hook',\n\t\t\t'args',\n\t\t\t'claim_id',\n\t\t);\n\n\t\t$request_status = $this->get_request_status();\n\n\t\tif ( empty( $request_status ) ) {\n\t\t\t$this->sort_by[] = 'status';\n\t\t} elseif ( in_array( $request_status, array( 'in-progress', 'failed' ) ) ) {\n\t\t\t$this->columns  += array( 'claim_id' => __( 'Claim ID', 'action-scheduler' ) );\n\t\t\t$this->sort_by[] = 'claim_id';\n\t\t}\n\n\t\t$this->row_actions = array(\n\t\t\t'hook' => array(\n\t\t\t\t'run' => array(\n\t\t\t\t\t'name'  => __( 'Run', 'action-scheduler' ),\n\t\t\t\t\t'desc'  => __( 'Process the action now as if it were run as part of a queue', 'action-scheduler' ),\n\t\t\t\t),\n\t\t\t\t'cancel' => array(\n\t\t\t\t\t'name'  => __( 'Cancel', 'action-scheduler' ),\n\t\t\t\t\t'desc'  => __( 'Cancel the action now to avoid it being run in future', 'action-scheduler' ),\n\t\t\t\t\t'class' => 'cancel trash',\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tself::$time_periods = array(\n\t\t\tarray(\n\t\t\t\t'seconds' => YEAR_IN_SECONDS,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s year', '%s years', 'action-scheduler' ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'seconds' => MONTH_IN_SECONDS,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s month', '%s months', 'action-scheduler' ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'seconds' => WEEK_IN_SECONDS,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s week', '%s weeks', 'action-scheduler' ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'seconds' => DAY_IN_SECONDS,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s day', '%s days', 'action-scheduler' ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'seconds' => HOUR_IN_SECONDS,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s hour', '%s hours', 'action-scheduler' ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'seconds' => MINUTE_IN_SECONDS,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s minute', '%s minutes', 'action-scheduler' ),\n\t\t\t),\n\t\t\tarray(\n\t\t\t\t'seconds' => 1,\n\t\t\t\t/* translators: %s: amount of time */\n\t\t\t\t'names'   => _n_noop( '%s second', '%s seconds', 'action-scheduler' ),\n\t\t\t),\n\t\t);\n\n\t\tparent::__construct(\n\t\t\tarray(\n\t\t\t\t'singular' => 'action-scheduler',\n\t\t\t\t'plural'   => 'action-scheduler',\n\t\t\t\t'ajax'     => false,\n\t\t\t)\n\t\t);\n\n\t\tadd_screen_option(\n\t\t\t'per_page',\n\t\t\tarray(\n\t\t\t\t'default' => $this->items_per_page,\n\t\t\t)\n\t\t);\n\n\t\tadd_filter( 'set_screen_option_' . $this->get_per_page_option_name(), array( $this, 'set_items_per_page_option' ), 10, 3 );\n\t\tset_screen_options();\n\t}\n\n\t/**\n\t * Handles setting the items_per_page option for this screen.\n\t *\n\t * @param mixed  $status Default false (to skip saving the current option).\n\t * @param string $option Screen option name.\n\t * @param int    $value  Screen option value.\n\t * @return int\n\t */\n\tpublic function set_items_per_page_option( $status, $option, $value ) {\n\t\treturn $value;\n\t}\n\t/**\n\t * Convert an interval of seconds into a two part human friendly string.\n\t *\n\t * The WordPress human_time_diff() function only calculates the time difference to one degree, meaning\n\t * even if an action is 1 day and 11 hours away, it will display \"1 day\". This function goes one step\n\t * further to display two degrees of accuracy.\n\t *\n\t * Inspired by the Crontrol::interval() function by Edward Dale: https://wordpress.org/plugins/wp-crontrol/\n\t *\n\t * @param int $interval A interval in seconds.\n\t * @param int $periods_to_include Depth of time periods to include, e.g. for an interval of 70, and $periods_to_include of 2, both minutes and seconds would be included. With a value of 1, only minutes would be included.\n\t * @return string A human friendly string representation of the interval.\n\t */\n\tprivate static function human_interval( $interval, $periods_to_include = 2 ) {\n\n\t\tif ( $interval <= 0 ) {\n\t\t\treturn __( 'Now!', 'action-scheduler' );\n\t\t}\n\n\t\t$output = '';\n\n\t\tfor ( $time_period_index = 0, $periods_included = 0, $seconds_remaining = $interval; $time_period_index < count( self::$time_periods ) && $seconds_remaining > 0 && $periods_included < $periods_to_include; $time_period_index++ ) {\n\n\t\t\t$periods_in_interval = floor( $seconds_remaining / self::$time_periods[ $time_period_index ]['seconds'] );\n\n\t\t\tif ( $periods_in_interval > 0 ) {\n\t\t\t\tif ( ! empty( $output ) ) {\n\t\t\t\t\t$output .= ' ';\n\t\t\t\t}\n\t\t\t\t$output .= sprintf( _n( self::$time_periods[ $time_period_index ]['names'][0], self::$time_periods[ $time_period_index ]['names'][1], $periods_in_interval, 'action-scheduler' ), $periods_in_interval );\n\t\t\t\t$seconds_remaining -= $periods_in_interval * self::$time_periods[ $time_period_index ]['seconds'];\n\t\t\t\t$periods_included++;\n\t\t\t}\n\t\t}\n\n\t\treturn $output;\n\t}\n\n\t/**\n\t * Returns the recurrence of an action or 'Non-repeating'. The output is human readable.\n\t *\n\t * @param ActionScheduler_Action $action\n\t *\n\t * @return string\n\t */\n\tprotected function get_recurrence( $action ) {\n\t\t$schedule = $action->get_schedule();\n\t\tif ( $schedule->is_recurring() ) {\n\t\t\t$recurrence = $schedule->get_recurrence();\n\n\t\t\tif ( is_numeric( $recurrence ) ) {\n\t\t\t\t/* translators: %s: time interval */\n\t\t\t\treturn sprintf( __( 'Every %s', 'action-scheduler' ), self::human_interval( $recurrence ) );\n\t\t\t} else {\n\t\t\t\treturn $recurrence;\n\t\t\t}\n\t\t}\n\n\t\treturn __( 'Non-repeating', 'action-scheduler' );\n\t}\n\n\t/**\n\t * Serializes the argument of an action to render it in a human friendly format.\n\t *\n\t * @param array $row The array representation of the current row of the table\n\t *\n\t * @return string\n\t */\n\tpublic function column_args( array $row ) {\n\t\tif ( empty( $row['args'] ) ) {\n\t\t\treturn apply_filters( 'action_scheduler_list_table_column_args', '', $row );\n\t\t}\n\n\t\t$row_html = '<ul>';\n\t\tforeach ( $row['args'] as $key => $value ) {\n\t\t\t$row_html .= sprintf( '<li><code>%s => %s</code></li>', esc_html( var_export( $key, true ) ), esc_html( var_export( $value, true ) ) );\n\t\t}\n\t\t$row_html .= '</ul>';\n\n\t\treturn apply_filters( 'action_scheduler_list_table_column_args', $row_html, $row );\n\t}\n\n\t/**\n\t * Prints the logs entries inline. We do so to avoid loading Javascript and other hacks to show it in a modal.\n\t *\n\t * @param array $row Action array.\n\t * @return string\n\t */\n\tpublic function column_log_entries( array $row ) {\n\n\t\t$log_entries_html = '<ol>';\n\n\t\t$timezone = new DateTimezone( 'UTC' );\n\n\t\tforeach ( $row['log_entries'] as $log_entry ) {\n\t\t\t$log_entries_html .= $this->get_log_entry_html( $log_entry, $timezone );\n\t\t}\n\n\t\t$log_entries_html .= '</ol>';\n\n\t\treturn $log_entries_html;\n\t}\n\n\t/**\n\t * Prints the logs entries inline. We do so to avoid loading Javascript and other hacks to show it in a modal.\n\t *\n\t * @param ActionScheduler_LogEntry $log_entry\n\t * @param DateTimezone $timezone\n\t * @return string\n\t */\n\tprotected function get_log_entry_html( ActionScheduler_LogEntry $log_entry, DateTimezone $timezone ) {\n\t\t$date = $log_entry->get_date();\n\t\t$date->setTimezone( $timezone );\n\t\treturn sprintf( '<li><strong>%s</strong><br/>%s</li>', esc_html( $date->format( 'Y-m-d H:i:s O' ) ), esc_html( $log_entry->get_message() ) );\n\t}\n\n\t/**\n\t * Only display row actions for pending actions.\n\t *\n\t * @param array  $row         Row to render\n\t * @param string $column_name Current row\n\t *\n\t * @return string\n\t */\n\tprotected function maybe_render_actions( $row, $column_name ) {\n\t\tif ( 'pending' === strtolower( $row[ 'status_name' ] ) ) {\n\t\t\treturn parent::maybe_render_actions( $row, $column_name );\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Renders admin notifications\n\t *\n\t * Notifications:\n\t *  1. When the maximum number of tasks are being executed simultaneously.\n\t *  2. Notifications when a task is manually executed.\n\t *  3. Tables are missing.\n\t */\n\tpublic function display_admin_notices() {\n\t\tglobal $wpdb;\n\n\t\tif ( ( is_a( $this->store, 'ActionScheduler_HybridStore' ) || is_a( $this->store, 'ActionScheduler_DBStore' ) ) && apply_filters( 'action_scheduler_enable_recreate_data_store', true ) ) {\n\t\t\t$table_list = array(\n\t\t\t\t'actionscheduler_actions',\n\t\t\t\t'actionscheduler_logs',\n\t\t\t\t'actionscheduler_groups',\n\t\t\t\t'actionscheduler_claims',\n\t\t\t);\n\n\t\t\t$found_tables = $wpdb->get_col( \"SHOW TABLES LIKE '{$wpdb->prefix}actionscheduler%'\" ); // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared\n\t\t\tforeach ( $table_list as $table_name ) {\n\t\t\t\tif ( ! in_array( $wpdb->prefix . $table_name, $found_tables ) ) {\n\t\t\t\t\t$this->admin_notices[] = array(\n\t\t\t\t\t\t'class'   => 'error',\n\t\t\t\t\t\t'message' => __( 'It appears one or more database tables were missing. Attempting to re-create the missing table(s).' , 'action-scheduler' ),\n\t\t\t\t\t);\n\t\t\t\t\t$this->recreate_tables();\n\t\t\t\t\tparent::display_admin_notices();\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->runner->has_maximum_concurrent_batches() ) {\n\t\t\t$claim_count           = $this->store->get_claim_count();\n\t\t\t$this->admin_notices[] = array(\n\t\t\t\t'class'   => 'updated',\n\t\t\t\t'message' => sprintf(\n\t\t\t\t\t/* translators: %s: amount of claims */\n\t\t\t\t\t_n(\n\t\t\t\t\t\t'Maximum simultaneous queues already in progress (%s queue). No additional queues will begin processing until the current queues are complete.',\n\t\t\t\t\t\t'Maximum simultaneous queues already in progress (%s queues). No additional queues will begin processing until the current queues are complete.',\n\t\t\t\t\t\t$claim_count,\n\t\t\t\t\t\t'action-scheduler'\n\t\t\t\t\t),\n\t\t\t\t\t$claim_count\n\t\t\t\t),\n\t\t\t);\n\t\t} elseif ( $this->store->has_pending_actions_due() ) {\n\n\t\t\t$async_request_lock_expiration = ActionScheduler::lock()->get_expiration( 'async-request-runner' );\n\n\t\t\t// No lock set or lock expired\n\t\t\tif ( false === $async_request_lock_expiration || $async_request_lock_expiration < time() ) {\n\t\t\t\t$in_progress_url       = add_query_arg( 'status', 'in-progress', remove_query_arg( 'status' ) );\n\t\t\t\t/* translators: %s: process URL */\n\t\t\t\t$async_request_message = sprintf( __( 'A new queue has begun processing. <a href=\"%s\">View actions in-progress &raquo;</a>', 'action-scheduler' ), esc_url( $in_progress_url ) );\n\t\t\t} else {\n\t\t\t\t/* translators: %d: seconds */\n\t\t\t\t$async_request_message = sprintf( __( 'The next queue will begin processing in approximately %d seconds.', 'action-scheduler' ), $async_request_lock_expiration - time() );\n\t\t\t}\n\n\t\t\t$this->admin_notices[] = array(\n\t\t\t\t'class'   => 'notice notice-info',\n\t\t\t\t'message' => $async_request_message,\n\t\t\t);\n\t\t}\n\n\t\t$notification = get_transient( 'action_scheduler_admin_notice' );\n\n\t\tif ( is_array( $notification ) ) {\n\t\t\tdelete_transient( 'action_scheduler_admin_notice' );\n\n\t\t\t$action = $this->store->fetch_action( $notification['action_id'] );\n\t\t\t$action_hook_html = '<strong><code>' . $action->get_hook() . '</code></strong>';\n\t\t\tif ( 1 == $notification['success'] ) {\n\t\t\t\t$class = 'updated';\n\t\t\t\tswitch ( $notification['row_action_type'] ) {\n\t\t\t\t\tcase 'run' :\n\t\t\t\t\t\t/* translators: %s: action HTML */\n\t\t\t\t\t\t$action_message_html = sprintf( __( 'Successfully executed action: %s', 'action-scheduler' ), $action_hook_html );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'cancel' :\n\t\t\t\t\t\t/* translators: %s: action HTML */\n\t\t\t\t\t\t$action_message_html = sprintf( __( 'Successfully canceled action: %s', 'action-scheduler' ), $action_hook_html );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :\n\t\t\t\t\t\t/* translators: %s: action HTML */\n\t\t\t\t\t\t$action_message_html = sprintf( __( 'Successfully processed change for action: %s', 'action-scheduler' ), $action_hook_html );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$class = 'error';\n\t\t\t\t/* translators: 1: action HTML 2: action ID 3: error message */\n\t\t\t\t$action_message_html = sprintf( __( 'Could not process change for action: \"%1$s\" (ID: %2$d). Error: %3$s', 'action-scheduler' ), $action_hook_html, esc_html( $notification['action_id'] ), esc_html( $notification['error_message'] ) );\n\t\t\t}\n\n\t\t\t$action_message_html = apply_filters( 'action_scheduler_admin_notice_html', $action_message_html, $action, $notification );\n\n\t\t\t$this->admin_notices[] = array(\n\t\t\t\t'class'   => $class,\n\t\t\t\t'message' => $action_message_html,\n\t\t\t);\n\t\t}\n\n\t\tparent::display_admin_notices();\n\t}\n\n\t/**\n\t * Prints the scheduled date in a human friendly format.\n\t *\n\t * @param array $row The array representation of the current row of the table\n\t *\n\t * @return string\n\t */\n\tpublic function column_schedule( $row ) {\n\t\treturn $this->get_schedule_display_string( $row['schedule'] );\n\t}\n\n\t/**\n\t * Get the scheduled date in a human friendly format.\n\t *\n\t * @param ActionScheduler_Schedule $schedule\n\t * @return string\n\t */\n\tprotected function get_schedule_display_string( ActionScheduler_Schedule $schedule ) {\n\n\t\t$schedule_display_string = '';\n\n\t\tif ( is_a( $schedule, 'ActionScheduler_NullSchedule' ) ) {\n\t\t\treturn __( 'async', 'action-scheduler' );\n\t\t}\n\n\t\tif ( ! $schedule->get_date() ) {\n\t\t\treturn '0000-00-00 00:00:00';\n\t\t}\n\n\t\t$next_timestamp = $schedule->get_date()->getTimestamp();\n\n\t\t$schedule_display_string .= $schedule->get_date()->format( 'Y-m-d H:i:s O' );\n\t\t$schedule_display_string .= '<br/>';\n\n\t\tif ( gmdate( 'U' ) > $next_timestamp ) {\n\t\t\t/* translators: %s: date interval */\n\t\t\t$schedule_display_string .= sprintf( __( ' (%s ago)', 'action-scheduler' ), self::human_interval( gmdate( 'U' ) - $next_timestamp ) );\n\t\t} else {\n\t\t\t/* translators: %s: date interval */\n\t\t\t$schedule_display_string .= sprintf( __( ' (%s)', 'action-scheduler' ), self::human_interval( $next_timestamp - gmdate( 'U' ) ) );\n\t\t}\n\n\t\treturn $schedule_display_string;\n\t}\n\n\t/**\n\t * Bulk delete\n\t *\n\t * Deletes actions based on their ID. This is the handler for the bulk delete. It assumes the data\n\t * properly validated by the callee and it will delete the actions without any extra validation.\n\t *\n\t * @param array $ids\n\t * @param string $ids_sql Inherited and unused\n\t */\n\tprotected function bulk_delete( array $ids, $ids_sql ) {\n\t\tforeach ( $ids as $id ) {\n\t\t\t$this->store->delete_action( $id );\n\t\t}\n\t}\n\n\t/**\n\t * Implements the logic behind running an action. ActionScheduler_Abstract_ListTable validates the request and their\n\t * parameters are valid.\n\t *\n\t * @param int $action_id\n\t */\n\tprotected function row_action_cancel( $action_id ) {\n\t\t$this->process_row_action( $action_id, 'cancel' );\n\t}\n\n\t/**\n\t * Implements the logic behind running an action. ActionScheduler_Abstract_ListTable validates the request and their\n\t * parameters are valid.\n\t *\n\t * @param int $action_id\n\t */\n\tprotected function row_action_run( $action_id ) {\n\t\t$this->process_row_action( $action_id, 'run' );\n\t}\n\n\t/**\n\t * Force the data store schema updates.\n\t */\n\tprotected function recreate_tables() {\n\t\tif ( is_a( $this->store, 'ActionScheduler_HybridStore' ) ) {\n\t\t\t$store = $this->store;\n\t\t} else {\n\t\t\t$store = new ActionScheduler_HybridStore();\n\t\t}\n\t\tadd_action( 'action_scheduler/created_table', array( $store, 'set_autoincrement' ), 10, 2 );\n\n\t\t$store_schema  = new ActionScheduler_StoreSchema();\n\t\t$logger_schema = new ActionScheduler_LoggerSchema();\n\t\t$store_schema->register_tables( true );\n\t\t$logger_schema->register_tables( true );\n\n\t\tremove_action( 'action_scheduler/created_table', array( $store, 'set_autoincrement' ), 10 );\n\t}\n\t/**\n\t * Implements the logic behind processing an action once an action link is clicked on the list table.\n\t *\n\t * @param int $action_id\n\t * @param string $row_action_type The type of action to perform on the action.\n\t */\n\tprotected function process_row_action( $action_id, $row_action_type ) {\n\t\ttry {\n\t\t\tswitch ( $row_action_type ) {\n\t\t\t\tcase 'run' :\n\t\t\t\t\t$this->runner->process_action( $action_id, 'Admin List Table' );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cancel' :\n\t\t\t\t\t$this->store->cancel_action( $action_id );\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$success = 1;\n\t\t\t$error_message = '';\n\t\t} catch ( Exception $e ) {\n\t\t\t$success = 0;\n\t\t\t$error_message = $e->getMessage();\n\t\t}\n\n\t\tset_transient( 'action_scheduler_admin_notice', compact( 'action_id', 'success', 'error_message', 'row_action_type' ), 30 );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic function prepare_items() {\n\t\t$this->prepare_column_headers();\n\n\t\t$per_page = $this->get_items_per_page( $this->get_per_page_option_name(), $this->items_per_page );\n\n\t\t$query = array(\n\t\t\t'per_page' => $per_page,\n\t\t\t'offset'   => $this->get_items_offset(),\n\t\t\t'status'   => $this->get_request_status(),\n\t\t\t'orderby'  => $this->get_request_orderby(),\n\t\t\t'order'    => $this->get_request_order(),\n\t\t\t'search'   => $this->get_request_search_query(),\n\t\t);\n\n\t\t/**\n\t\t * Change query arguments to query for past-due actions.\n\t\t * Past-due actions have the 'pending' status and are in the past.\n\t\t * This is needed because registering 'past-due' as a status is overkill.\n\t\t */\n\t\tif ( 'past-due' === $this->get_request_status() ) {\n\t\t\t$query['status'] = ActionScheduler_Store::STATUS_PENDING;\n\t\t\t$query['date']   = as_get_datetime_object();\n\t\t}\n\n\t\t$this->items = array();\n\n\t\t$total_items = $this->store->query_actions( $query, 'count' );\n\n\t\t$status_labels = $this->store->get_status_labels();\n\n\t\tforeach ( $this->store->query_actions( $query ) as $action_id ) {\n\t\t\ttry {\n\t\t\t\t$action = $this->store->fetch_action( $action_id );\n\t\t\t} catch ( Exception $e ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( is_a( $action, 'ActionScheduler_NullAction' ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$this->items[ $action_id ] = array(\n\t\t\t\t'ID'          => $action_id,\n\t\t\t\t'hook'        => $action->get_hook(),\n\t\t\t\t'status_name' => $this->store->get_status( $action_id ),\n\t\t\t\t'status'      => $status_labels[ $this->store->get_status( $action_id ) ],\n\t\t\t\t'args'        => $action->get_args(),\n\t\t\t\t'group'       => $action->get_group(),\n\t\t\t\t'log_entries' => $this->logger->get_logs( $action_id ),\n\t\t\t\t'claim_id'    => $this->store->get_claim_id( $action_id ),\n\t\t\t\t'recurrence'  => $this->get_recurrence( $action ),\n\t\t\t\t'schedule'    => $action->get_schedule(),\n\t\t\t);\n\t\t}\n\n\t\t$this->set_pagination_args( array(\n\t\t\t'total_items' => $total_items,\n\t\t\t'per_page'    => $per_page,\n\t\t\t'total_pages' => ceil( $total_items / $per_page ),\n\t\t) );\n\t}\n\n\t/**\n\t * Prints the available statuses so the user can click to filter.\n\t */\n\tprotected function display_filter_by_status() {\n\t\t$this->status_counts = $this->store->action_counts() + $this->store->extra_action_counts();\n\t\tparent::display_filter_by_status();\n\t}\n\n\t/**\n\t * Get the text to display in the search box on the list table.\n\t */\n\tprotected function get_search_box_button_text() {\n\t\treturn __( 'Search hook, args and claim ID', 'action-scheduler' );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tprotected function get_per_page_option_name() {\n\t\treturn str_replace( '-', '_', $this->screen->id ) . '_per_page';\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ListTable.php b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ListTable.php
--- a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ListTable.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ListTable.php	(date 1675081217869)
@@ -467,10 +467,6 @@
 
 		$schedule_display_string = '';
 
-		if ( is_a( $schedule, 'ActionScheduler_NullSchedule' ) ) {
-			return __( 'async', 'action-scheduler' );
-		}
-
 		if ( ! $schedule->get_date() ) {
 			return '0000-00-00 00:00:00';
 		}
@@ -587,16 +583,6 @@
 			'search'   => $this->get_request_search_query(),
 		);
 
-		/**
-		 * Change query arguments to query for past-due actions.
-		 * Past-due actions have the 'pending' status and are in the past.
-		 * This is needed because registering 'past-due' as a status is overkill.
-		 */
-		if ( 'past-due' === $this->get_request_status() ) {
-			$query['status'] = ActionScheduler_Store::STATUS_PENDING;
-			$query['date']   = as_get_datetime_object();
-		}
-
 		$this->items = array();
 
 		$total_items = $this->store->query_actions( $query, 'count' );
@@ -637,7 +623,7 @@
 	 * Prints the available statuses so the user can click to filter.
 	 */
 	protected function display_filter_by_status() {
-		$this->status_counts = $this->store->action_counts() + $this->store->extra_action_counts();
+		$this->status_counts = $this->store->action_counts();
 		parent::display_filter_by_status();
 	}
 
Index: inc/Dependencies/ActionScheduler/action-scheduler.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n/**\n * Plugin Name: Action Scheduler\n * Plugin URI: https://actionscheduler.org\n * Description: A robust scheduling library for use in WordPress plugins.\n * Author: Automattic\n * Author URI: https://automattic.com/\n * Version: 3.5.2\n * License: GPLv3\n *\n * Copyright 2019 Automattic, Inc.  (https://automattic.com/contact/)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * @package ActionScheduler\n */\n\nif ( ! function_exists( 'action_scheduler_register_3_dot_5_dot_2' ) && function_exists( 'add_action' ) ) {\n\n\tif ( ! class_exists( 'ActionScheduler_Versions', false ) ) {\n\t\trequire_once __DIR__ . '/classes/ActionScheduler_Versions.php';\n\t\tadd_action( 'plugins_loaded', array( 'ActionScheduler_Versions', 'initialize_latest_version' ), 1, 0 );\n\t}\n\n\tadd_action( 'plugins_loaded', 'action_scheduler_register_3_dot_5_dot_2', 0, 0 );\n\n\t/**\n\t * Registers this version of Action Scheduler.\n\t */\n\tfunction action_scheduler_register_3_dot_5_dot_2() {\n\t\t$versions = ActionScheduler_Versions::instance();\n\t\t$versions->register( '3.5.2', 'action_scheduler_initialize_3_dot_5_dot_2' );\n\t}\n\n\t/**\n\t * Initializes this version of Action Scheduler.\n\t */\n\tfunction action_scheduler_initialize_3_dot_5_dot_2() {\n\t\t// A final safety check is required even here, because historic versions of Action Scheduler\n\t\t// followed a different pattern (in some unusual cases, we could reach this point and the\n\t\t// ActionScheduler class is already defined—so we need to guard against that).\n\t\tif ( ! class_exists( 'ActionScheduler', false ) ) {\n\t\t\trequire_once __DIR__ . '/classes/abstracts/ActionScheduler.php';\n\t\t\tActionScheduler::init( __FILE__ );\n\t\t}\n\t}\n\n\t// Support usage in themes - load this version if no plugin has loaded a version yet.\n\tif ( did_action( 'plugins_loaded' ) && ! doing_action( 'plugins_loaded' ) && ! class_exists( 'ActionScheduler', false ) ) {\n\t\taction_scheduler_initialize_3_dot_5_dot_2();\n\t\tdo_action( 'action_scheduler_pre_theme_init' );\n\t\tActionScheduler_Versions::initialize_latest_version();\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/action-scheduler.php b/inc/Dependencies/ActionScheduler/action-scheduler.php
--- a/inc/Dependencies/ActionScheduler/action-scheduler.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/action-scheduler.php	(date 1675081217873)
@@ -5,7 +5,7 @@
  * Description: A robust scheduling library for use in WordPress plugins.
  * Author: Automattic
  * Author URI: https://automattic.com/
- * Version: 3.5.2
+ * Version: 3.4.2
  * License: GPLv3
  *
  * Copyright 2019 Automattic, Inc.  (https://automattic.com/contact/)
@@ -26,27 +26,27 @@
  * @package ActionScheduler
  */
 
-if ( ! function_exists( 'action_scheduler_register_3_dot_5_dot_2' ) && function_exists( 'add_action' ) ) {
+if ( ! function_exists( 'action_scheduler_register_3_dot_4_dot_0' ) && function_exists( 'add_action' ) ) {
 
 	if ( ! class_exists( 'ActionScheduler_Versions', false ) ) {
 		require_once __DIR__ . '/classes/ActionScheduler_Versions.php';
 		add_action( 'plugins_loaded', array( 'ActionScheduler_Versions', 'initialize_latest_version' ), 1, 0 );
 	}
 
-	add_action( 'plugins_loaded', 'action_scheduler_register_3_dot_5_dot_2', 0, 0 );
+	add_action( 'plugins_loaded', 'action_scheduler_register_3_dot_4_dot_0', 0, 0 );
 
 	/**
 	 * Registers this version of Action Scheduler.
 	 */
-	function action_scheduler_register_3_dot_5_dot_2() {
+	function action_scheduler_register_3_dot_4_dot_0() {
 		$versions = ActionScheduler_Versions::instance();
-		$versions->register( '3.5.2', 'action_scheduler_initialize_3_dot_5_dot_2' );
+		$versions->register( '3.4.0', 'action_scheduler_initialize_3_dot_4_dot_0' );
 	}
 
 	/**
 	 * Initializes this version of Action Scheduler.
 	 */
-	function action_scheduler_initialize_3_dot_5_dot_2() {
+	function action_scheduler_initialize_3_dot_4_dot_0() {
 		// A final safety check is required even here, because historic versions of Action Scheduler
 		// followed a different pattern (in some unusual cases, we could reach this point and the
 		// ActionScheduler class is already defined—so we need to guard against that).
@@ -58,7 +58,7 @@
 
 	// Support usage in themes - load this version if no plugin has loaded a version yet.
 	if ( did_action( 'plugins_loaded' ) && ! doing_action( 'plugins_loaded' ) && ! class_exists( 'ActionScheduler', false ) ) {
-		action_scheduler_initialize_3_dot_5_dot_2();
+		action_scheduler_initialize_3_dot_4_dot_0();
 		do_action( 'action_scheduler_pre_theme_init' );
 		ActionScheduler_Versions::initialize_latest_version();
 	}
Index: inc/Dependencies/ActionScheduler/classes/ActionScheduler_ActionFactory.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_ActionFactory\n */\nclass ActionScheduler_ActionFactory {\n\n\t/**\n\t * Return stored actions for given params.\n\t *\n\t * @param string                   $status The action's status in the data store.\n\t * @param string                   $hook The hook to trigger when this action runs.\n\t * @param array                    $args Args to pass to callbacks when the hook is triggered.\n\t * @param ActionScheduler_Schedule $schedule The action's schedule.\n\t * @param string                   $group A group to put the action in.\n\t *\n\t * @return ActionScheduler_Action An instance of the stored action.\n\t */\n\tpublic function get_stored_action( $status, $hook, array $args = array(), ActionScheduler_Schedule $schedule = null, $group = '' ) {\n\n\t\tswitch ( $status ) {\n\t\t\tcase ActionScheduler_Store::STATUS_PENDING:\n\t\t\t\t$action_class = 'ActionScheduler_Action';\n\t\t\t\tbreak;\n\t\t\tcase ActionScheduler_Store::STATUS_CANCELED:\n\t\t\t\t$action_class = 'ActionScheduler_CanceledAction';\n\t\t\t\tif ( ! is_null( $schedule ) && ! is_a( $schedule, 'ActionScheduler_CanceledSchedule' ) && ! is_a( $schedule, 'ActionScheduler_NullSchedule' ) ) {\n\t\t\t\t\t$schedule = new ActionScheduler_CanceledSchedule( $schedule->get_date() );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$action_class = 'ActionScheduler_FinishedAction';\n\t\t\t\tbreak;\n\t\t}\n\n\t\t$action_class = apply_filters( 'action_scheduler_stored_action_class', $action_class, $status, $hook, $args, $schedule, $group );\n\n\t\t$action = new $action_class( $hook, $args, $schedule, $group );\n\n\t\t/**\n\t\t * Allow 3rd party code to change the instantiated action for a given hook, args, schedule and group.\n\t\t *\n\t\t * @param ActionScheduler_Action $action The instantiated action.\n\t\t * @param string $hook The instantiated action's hook.\n\t\t * @param array $args The instantiated action's args.\n\t\t * @param ActionScheduler_Schedule $schedule The instantiated action's schedule.\n\t\t * @param string $group The instantiated action's group.\n\t\t */\n\t\treturn apply_filters( 'action_scheduler_stored_action_instance', $action, $hook, $args, $schedule, $group );\n\t}\n\n\t/**\n\t * Enqueue an action to run one time, as soon as possible (rather a specific scheduled time).\n\t *\n\t * This method creates a new action with the NULLSchedule. This schedule maps to a MySQL datetime string of\n\t * 0000-00-00 00:00:00. This is done to create a psuedo \"async action\" type that is fully backward compatible.\n\t * Existing queries to claim actions claim by date, meaning actions scheduled for 0000-00-00 00:00:00 will\n\t * always be claimed prior to actions scheduled for a specific date. This makes sure that any async action is\n\t * given priority in queue processing. This has the added advantage of making sure async actions can be\n\t * claimed by both the existing WP Cron and WP CLI runners, as well as a new async request runner.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param string $group A group to put the action in.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function async( $hook, $args = array(), $group = '' ) {\n\t\treturn $this->async_unique( $hook, $args, $group, false );\n\t}\n\n\t/**\n\t * Same as async, but also supports $unique param.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param string $group A group to put the action in.\n\t * @param bool   $unique Whether to ensure the action is unique.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function async_unique( $hook, $args = array(), $group = '', $unique = true ) {\n\t\t$schedule = new ActionScheduler_NullSchedule();\n\t\t$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );\n\t\treturn $unique ? $this->store_unique_action( $action, $unique ) : $this->store( $action );\n\t}\n\n\t/**\n\t * Create single action.\n\t *\n\t * @param string $hook  The hook to trigger when this action runs.\n\t * @param array  $args  Args to pass when the hook is triggered.\n\t * @param int    $when  Unix timestamp when the action will run.\n\t * @param string $group A group to put the action in.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function single( $hook, $args = array(), $when = null, $group = '' ) {\n\t\treturn $this->single_unique( $hook, $args, $when, $group, false );\n\t}\n\n\t/**\n\t * Create single action only if there is no pending or running action with same name and params.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param int    $when Unix timestamp when the action will run.\n\t * @param string $group A group to put the action in.\n\t * @param bool   $unique Whether action scheduled should be unique.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function single_unique( $hook, $args = array(), $when = null, $group = '', $unique = true ) {\n\t\t$date     = as_get_datetime_object( $when );\n\t\t$schedule = new ActionScheduler_SimpleSchedule( $date );\n\t\t$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );\n\t\treturn $unique ? $this->store_unique_action( $action ) : $this->store( $action );\n\t}\n\n\t/**\n\t * Create the first instance of an action recurring on a given interval.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param int    $first Unix timestamp for the first run.\n\t * @param int    $interval Seconds between runs.\n\t * @param string $group A group to put the action in.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function recurring( $hook, $args = array(), $first = null, $interval = null, $group = '' ) {\n\t\treturn $this->recurring_unique( $hook, $args, $first, $interval, $group, false );\n\t}\n\n\t/**\n\t * Create the first instance of an action recurring on a given interval only if there is no pending or running action with same name and params.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param int    $first Unix timestamp for the first run.\n\t * @param int    $interval Seconds between runs.\n\t * @param string $group A group to put the action in.\n\t * @param bool   $unique Whether action scheduled should be unique.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function recurring_unique( $hook, $args = array(), $first = null, $interval = null, $group = '', $unique = true ) {\n\t\tif ( empty( $interval ) ) {\n\t\t\treturn $this->single_unique( $hook, $unique, $args, $first, $group );\n\t\t}\n\t\t$date     = as_get_datetime_object( $first );\n\t\t$schedule = new ActionScheduler_IntervalSchedule( $date, $interval );\n\t\t$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );\n\t\treturn $unique ? $this->store_unique_action( $action ) : $this->store( $action );\n\t}\n\n\t/**\n\t * Create the first instance of an action recurring on a Cron schedule.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param int    $base_timestamp The first instance of the action will be scheduled\n\t *        to run at a time calculated after this timestamp matching the cron\n\t *        expression. This can be used to delay the first instance of the action.\n\t * @param int    $schedule A cron definition string.\n\t * @param string $group A group to put the action in.\n\t *\n\t * @return int The ID of the stored action.\n\t */\n\tpublic function cron( $hook, $args = array(), $base_timestamp = null, $schedule = null, $group = '' ) {\n\t\treturn $this->cron_unique( $hook, $args, $base_timestamp, $schedule, $group, false );\n\t}\n\n\n\t/**\n\t * Create the first instance of an action recurring on a Cron schedule only if there is no pending or running action with same name and params.\n\t *\n\t * @param string $hook The hook to trigger when this action runs.\n\t * @param array  $args Args to pass when the hook is triggered.\n\t * @param int    $base_timestamp The first instance of the action will be scheduled\n\t *        to run at a time calculated after this timestamp matching the cron\n\t *        expression. This can be used to delay the first instance of the action.\n\t * @param int    $schedule A cron definition string.\n\t * @param string $group A group to put the action in.\n\t * @param bool   $unique Whether action scheduled should be unique.\n\t *\n\t * @return int The ID of the stored action.\n\t **/\n\tpublic function cron_unique( $hook, $args = array(), $base_timestamp = null, $schedule = null, $group = '', $unique = true ) {\n\t\tif ( empty( $schedule ) ) {\n\t\t\treturn $this->single_unique( $hook, $unique, $args, $base_timestamp, $group );\n\t\t}\n\t\t$date     = as_get_datetime_object( $base_timestamp );\n\t\t$cron     = CronExpression::factory( $schedule );\n\t\t$schedule = new ActionScheduler_CronSchedule( $date, $cron );\n\t\t$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );\n\t\treturn $unique ? $this->store_unique_action( $action ) : $this->store( $action );\n\t}\n\n\t/**\n\t * Create a successive instance of a recurring or cron action.\n\t *\n\t * Importantly, the action will be rescheduled to run based on the current date/time.\n\t * That means when the action is scheduled to run in the past, the next scheduled date\n\t * will be pushed forward. For example, if a recurring action set to run every hour\n\t * was scheduled to run 5 seconds ago, it will be next scheduled for 1 hour in the\n\t * future, which is 1 hour and 5 seconds from when it was last scheduled to run.\n\t *\n\t * Alternatively, if the action is scheduled to run in the future, and is run early,\n\t * likely via manual intervention, then its schedule will change based on the time now.\n\t * For example, if a recurring action set to run every day, and is run 12 hours early,\n\t * it will run again in 24 hours, not 36 hours.\n\t *\n\t * This slippage is less of an issue with Cron actions, as the specific run time can\n\t * be set for them to run, e.g. 1am each day. In those cases, and entire period would\n\t * need to be missed before there was any change is scheduled, e.g. in the case of an\n\t * action scheduled for 1am each day, the action would need to run an entire day late.\n\t *\n\t * @param ActionScheduler_Action $action The existing action.\n\t *\n\t * @return string The ID of the stored action\n\t * @throws InvalidArgumentException If $action is not a recurring action.\n\t */\n\tpublic function repeat( $action ) {\n\t\t$schedule = $action->get_schedule();\n\t\t$next     = $schedule->get_next( as_get_datetime_object() );\n\n\t\tif ( is_null( $next ) || ! $schedule->is_recurring() ) {\n\t\t\tthrow new InvalidArgumentException( __( 'Invalid action - must be a recurring action.', 'action-scheduler' ) );\n\t\t}\n\n\t\t$schedule_class = get_class( $schedule );\n\t\t$new_schedule   = new $schedule( $next, $schedule->get_recurrence(), $schedule->get_first_date() );\n\t\t$new_action     = new ActionScheduler_Action( $action->get_hook(), $action->get_args(), $new_schedule, $action->get_group() );\n\t\treturn $this->store( $new_action );\n\t}\n\n\t/**\n\t * Save action to database.\n\t *\n\t * @param ActionScheduler_Action $action Action object to save.\n\t *\n\t * @return int The ID of the stored action\n\t */\n\tprotected function store( ActionScheduler_Action $action ) {\n\t\t$store = ActionScheduler_Store::instance();\n\t\treturn $store->save_action( $action );\n\t}\n\n\t/**\n\t * Store action if it's unique.\n\t *\n\t * @param ActionScheduler_Action $action Action object to store.\n\t *\n\t * @return int ID of the created action. Will be 0 if action was not created.\n\t */\n\tprotected function store_unique_action( ActionScheduler_Action $action ) {\n\t\t$store = ActionScheduler_Store::instance();\n\t\treturn method_exists( $store, 'save_unique_action' ) ?\n\t\t\t$store->save_unique_action( $action ) : $store->save_action( $action );\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ActionFactory.php b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ActionFactory.php
--- a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ActionFactory.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_ActionFactory.php	(date 1675081217877)
@@ -6,29 +6,27 @@
 class ActionScheduler_ActionFactory {
 
 	/**
-	 * Return stored actions for given params.
+	 * @param string $status The action's status in the data store
+	 * @param string $hook The hook to trigger when this action runs
+	 * @param array $args Args to pass to callbacks when the hook is triggered
+	 * @param ActionScheduler_Schedule $schedule The action's schedule
+	 * @param string $group A group to put the action in
 	 *
-	 * @param string                   $status The action's status in the data store.
-	 * @param string                   $hook The hook to trigger when this action runs.
-	 * @param array                    $args Args to pass to callbacks when the hook is triggered.
-	 * @param ActionScheduler_Schedule $schedule The action's schedule.
-	 * @param string                   $group A group to put the action in.
-	 *
-	 * @return ActionScheduler_Action An instance of the stored action.
+	 * @return ActionScheduler_Action An instance of the stored action
 	 */
 	public function get_stored_action( $status, $hook, array $args = array(), ActionScheduler_Schedule $schedule = null, $group = '' ) {
 
 		switch ( $status ) {
-			case ActionScheduler_Store::STATUS_PENDING:
+			case ActionScheduler_Store::STATUS_PENDING :
 				$action_class = 'ActionScheduler_Action';
 				break;
-			case ActionScheduler_Store::STATUS_CANCELED:
+			case ActionScheduler_Store::STATUS_CANCELED :
 				$action_class = 'ActionScheduler_CanceledAction';
 				if ( ! is_null( $schedule ) && ! is_a( $schedule, 'ActionScheduler_CanceledSchedule' ) && ! is_a( $schedule, 'ActionScheduler_NullSchedule' ) ) {
 					$schedule = new ActionScheduler_CanceledSchedule( $schedule->get_date() );
 				}
 				break;
-			default:
+			default :
 				$action_class = 'ActionScheduler_FinishedAction';
 				break;
 		}
@@ -59,142 +57,76 @@
 	 * given priority in queue processing. This has the added advantage of making sure async actions can be
 	 * claimed by both the existing WP Cron and WP CLI runners, as well as a new async request runner.
 	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param string $group A group to put the action in.
+	 * @param string $hook The hook to trigger when this action runs
+	 * @param array $args Args to pass when the hook is triggered
+	 * @param string $group A group to put the action in
 	 *
-	 * @return int The ID of the stored action.
+	 * @return int The ID of the stored action
 	 */
 	public function async( $hook, $args = array(), $group = '' ) {
-		return $this->async_unique( $hook, $args, $group, false );
-	}
-
-	/**
-	 * Same as async, but also supports $unique param.
-	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param string $group A group to put the action in.
-	 * @param bool   $unique Whether to ensure the action is unique.
-	 *
-	 * @return int The ID of the stored action.
-	 */
-	public function async_unique( $hook, $args = array(), $group = '', $unique = true ) {
 		$schedule = new ActionScheduler_NullSchedule();
-		$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );
-		return $unique ? $this->store_unique_action( $action, $unique ) : $this->store( $action );
+		$action = new ActionScheduler_Action( $hook, $args, $schedule, $group );
+		return $this->store( $action );
 	}
 
 	/**
-	 * Create single action.
+	 * @param string $hook The hook to trigger when this action runs
+	 * @param array $args Args to pass when the hook is triggered
+	 * @param int $when Unix timestamp when the action will run
+	 * @param string $group A group to put the action in
 	 *
-	 * @param string $hook  The hook to trigger when this action runs.
-	 * @param array  $args  Args to pass when the hook is triggered.
-	 * @param int    $when  Unix timestamp when the action will run.
-	 * @param string $group A group to put the action in.
-	 *
-	 * @return int The ID of the stored action.
+	 * @return int The ID of the stored action
 	 */
 	public function single( $hook, $args = array(), $when = null, $group = '' ) {
-		return $this->single_unique( $hook, $args, $when, $group, false );
-	}
-
-	/**
-	 * Create single action only if there is no pending or running action with same name and params.
-	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param int    $when Unix timestamp when the action will run.
-	 * @param string $group A group to put the action in.
-	 * @param bool   $unique Whether action scheduled should be unique.
-	 *
-	 * @return int The ID of the stored action.
-	 */
-	public function single_unique( $hook, $args = array(), $when = null, $group = '', $unique = true ) {
-		$date     = as_get_datetime_object( $when );
+		$date = as_get_datetime_object( $when );
 		$schedule = new ActionScheduler_SimpleSchedule( $date );
-		$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );
-		return $unique ? $this->store_unique_action( $action ) : $this->store( $action );
+		$action = new ActionScheduler_Action( $hook, $args, $schedule, $group );
+		return $this->store( $action );
 	}
 
 	/**
 	 * Create the first instance of an action recurring on a given interval.
 	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param int    $first Unix timestamp for the first run.
-	 * @param int    $interval Seconds between runs.
-	 * @param string $group A group to put the action in.
+	 * @param string $hook The hook to trigger when this action runs
+	 * @param array $args Args to pass when the hook is triggered
+	 * @param int $first Unix timestamp for the first run
+	 * @param int $interval Seconds between runs
+	 * @param string $group A group to put the action in
 	 *
-	 * @return int The ID of the stored action.
+	 * @return int The ID of the stored action
 	 */
 	public function recurring( $hook, $args = array(), $first = null, $interval = null, $group = '' ) {
-		return $this->recurring_unique( $hook, $args, $first, $interval, $group, false );
-	}
-
-	/**
-	 * Create the first instance of an action recurring on a given interval only if there is no pending or running action with same name and params.
-	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param int    $first Unix timestamp for the first run.
-	 * @param int    $interval Seconds between runs.
-	 * @param string $group A group to put the action in.
-	 * @param bool   $unique Whether action scheduled should be unique.
-	 *
-	 * @return int The ID of the stored action.
-	 */
-	public function recurring_unique( $hook, $args = array(), $first = null, $interval = null, $group = '', $unique = true ) {
-		if ( empty( $interval ) ) {
-			return $this->single_unique( $hook, $unique, $args, $first, $group );
+		if ( empty($interval) ) {
+			return $this->single( $hook, $args, $first, $group );
 		}
-		$date     = as_get_datetime_object( $first );
+		$date = as_get_datetime_object( $first );
 		$schedule = new ActionScheduler_IntervalSchedule( $date, $interval );
-		$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );
-		return $unique ? $this->store_unique_action( $action ) : $this->store( $action );
+		$action = new ActionScheduler_Action( $hook, $args, $schedule, $group );
+		return $this->store( $action );
 	}
 
 	/**
 	 * Create the first instance of an action recurring on a Cron schedule.
 	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param int    $base_timestamp The first instance of the action will be scheduled
+	 * @param string $hook The hook to trigger when this action runs
+	 * @param array $args Args to pass when the hook is triggered
+	 * @param int $base_timestamp The first instance of the action will be scheduled
 	 *        to run at a time calculated after this timestamp matching the cron
 	 *        expression. This can be used to delay the first instance of the action.
-	 * @param int    $schedule A cron definition string.
-	 * @param string $group A group to put the action in.
+	 * @param int $schedule A cron definition string
+	 * @param string $group A group to put the action in
 	 *
-	 * @return int The ID of the stored action.
+	 * @return int The ID of the stored action
 	 */
 	public function cron( $hook, $args = array(), $base_timestamp = null, $schedule = null, $group = '' ) {
-		return $this->cron_unique( $hook, $args, $base_timestamp, $schedule, $group, false );
-	}
-
-
-	/**
-	 * Create the first instance of an action recurring on a Cron schedule only if there is no pending or running action with same name and params.
-	 *
-	 * @param string $hook The hook to trigger when this action runs.
-	 * @param array  $args Args to pass when the hook is triggered.
-	 * @param int    $base_timestamp The first instance of the action will be scheduled
-	 *        to run at a time calculated after this timestamp matching the cron
-	 *        expression. This can be used to delay the first instance of the action.
-	 * @param int    $schedule A cron definition string.
-	 * @param string $group A group to put the action in.
-	 * @param bool   $unique Whether action scheduled should be unique.
-	 *
-	 * @return int The ID of the stored action.
-	 **/
-	public function cron_unique( $hook, $args = array(), $base_timestamp = null, $schedule = null, $group = '', $unique = true ) {
-		if ( empty( $schedule ) ) {
-			return $this->single_unique( $hook, $unique, $args, $base_timestamp, $group );
+		if ( empty($schedule) ) {
+			return $this->single( $hook, $args, $base_timestamp, $group );
 		}
-		$date     = as_get_datetime_object( $base_timestamp );
-		$cron     = CronExpression::factory( $schedule );
+		$date = as_get_datetime_object( $base_timestamp );
+		$cron = CronExpression::factory( $schedule );
 		$schedule = new ActionScheduler_CronSchedule( $date, $cron );
-		$action   = new ActionScheduler_Action( $hook, $args, $schedule, $group );
-		return $unique ? $this->store_unique_action( $action ) : $this->store( $action );
+		$action = new ActionScheduler_Action( $hook, $args, $schedule, $group );
+		return $this->store( $action );
 	}
 
 	/**
@@ -230,15 +162,13 @@
 		}
 
 		$schedule_class = get_class( $schedule );
-		$new_schedule   = new $schedule( $next, $schedule->get_recurrence(), $schedule->get_first_date() );
-		$new_action     = new ActionScheduler_Action( $action->get_hook(), $action->get_args(), $new_schedule, $action->get_group() );
+		$new_schedule = new $schedule( $next, $schedule->get_recurrence(), $schedule->get_first_date() );
+		$new_action = new ActionScheduler_Action( $action->get_hook(), $action->get_args(), $new_schedule, $action->get_group() );
 		return $this->store( $new_action );
 	}
 
 	/**
-	 * Save action to database.
-	 *
-	 * @param ActionScheduler_Action $action Action object to save.
+	 * @param ActionScheduler_Action $action
 	 *
 	 * @return int The ID of the stored action
 	 */
@@ -246,17 +176,4 @@
 		$store = ActionScheduler_Store::instance();
 		return $store->save_action( $action );
 	}
-
-	/**
-	 * Store action if it's unique.
-	 *
-	 * @param ActionScheduler_Action $action Action object to store.
-	 *
-	 * @return int ID of the created action. Will be 0 if action was not created.
-	 */
-	protected function store_unique_action( ActionScheduler_Action $action ) {
-		$store = ActionScheduler_Store::instance();
-		return method_exists( $store, 'save_unique_action' ) ?
-			$store->save_unique_action( $action ) : $store->save_action( $action );
-	}
 }
Index: inc/Dependencies/ActionScheduler/classes/ActionScheduler_QueueRunner.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_QueueRunner\n */\nclass ActionScheduler_QueueRunner extends ActionScheduler_Abstract_QueueRunner {\n\tconst WP_CRON_HOOK = 'action_scheduler_run_queue';\n\n\tconst WP_CRON_SCHEDULE = 'every_minute';\n\n\t/** @var ActionScheduler_AsyncRequest_QueueRunner */\n\tprotected $async_request;\n\n\t/** @var ActionScheduler_QueueRunner  */\n\tprivate static $runner = null;\n\n\t/**\n\t * @return ActionScheduler_QueueRunner\n\t * @codeCoverageIgnore\n\t */\n\tpublic static function instance() {\n\t\tif ( empty(self::$runner) ) {\n\t\t\t$class = apply_filters('action_scheduler_queue_runner_class', 'ActionScheduler_QueueRunner');\n\t\t\tself::$runner = new $class();\n\t\t}\n\t\treturn self::$runner;\n\t}\n\n\t/**\n\t * ActionScheduler_QueueRunner constructor.\n\t *\n\t * @param ActionScheduler_Store             $store\n\t * @param ActionScheduler_FatalErrorMonitor $monitor\n\t * @param ActionScheduler_QueueCleaner      $cleaner\n\t */\n\tpublic function __construct( ActionScheduler_Store $store = null, ActionScheduler_FatalErrorMonitor $monitor = null, ActionScheduler_QueueCleaner $cleaner = null, ActionScheduler_AsyncRequest_QueueRunner $async_request = null ) {\n\t\tparent::__construct( $store, $monitor, $cleaner );\n\n\t\tif ( is_null( $async_request ) ) {\n\t\t\t$async_request = new ActionScheduler_AsyncRequest_QueueRunner( $this->store );\n\t\t}\n\n\t\t$this->async_request = $async_request;\n\t}\n\n\t/**\n\t * @codeCoverageIgnore\n\t */\n\tpublic function init() {\n\n\t\tadd_filter( 'cron_schedules', array( self::instance(), 'add_wp_cron_schedule' ) );\n\n\t\t// Check for and remove any WP Cron hook scheduled by Action Scheduler < 3.0.0, which didn't include the $context param\n\t\t$next_timestamp = wp_next_scheduled( self::WP_CRON_HOOK );\n\t\tif ( $next_timestamp ) {\n\t\t\twp_unschedule_event( $next_timestamp, self::WP_CRON_HOOK );\n\t\t}\n\n\t\t$cron_context = array( 'WP Cron' );\n\n\t\tif ( ! wp_next_scheduled( self::WP_CRON_HOOK, $cron_context ) ) {\n\t\t\t$schedule = apply_filters( 'action_scheduler_run_schedule', self::WP_CRON_SCHEDULE );\n\t\t\twp_schedule_event( time(), $schedule, self::WP_CRON_HOOK, $cron_context );\n\t\t}\n\n\t\tadd_action( self::WP_CRON_HOOK, array( self::instance(), 'run' ) );\n\t\t$this->hook_dispatch_async_request();\n\t}\n\n\t/**\n\t * Hook check for dispatching an async request.\n\t */\n\tpublic function hook_dispatch_async_request() {\n\t\tadd_action( 'shutdown', array( $this, 'maybe_dispatch_async_request' ) );\n\t}\n\n\t/**\n\t * Unhook check for dispatching an async request.\n\t */\n\tpublic function unhook_dispatch_async_request() {\n\t\tremove_action( 'shutdown', array( $this, 'maybe_dispatch_async_request' ) );\n\t}\n\n\t/**\n\t * Check if we should dispatch an async request to process actions.\n\t *\n\t * This method is attached to 'shutdown', so is called frequently. To avoid slowing down\n\t * the site, it mitigates the work performed in each request by:\n\t * 1. checking if it's in the admin context and then\n\t * 2. haven't run on the 'shutdown' hook within the lock time (60 seconds by default)\n\t * 3. haven't exceeded the number of allowed batches.\n\t *\n\t * The order of these checks is important, because they run from a check on a value:\n\t * 1. in memory - is_admin() maps to $GLOBALS or the WP_ADMIN constant\n\t * 2. in memory - transients use autoloaded options by default\n\t * 3. from a database query - has_maximum_concurrent_batches() run the query\n\t *    $this->store->get_claim_count() to find the current number of claims in the DB.\n\t *\n\t * If all of these conditions are met, then we request an async runner check whether it\n\t * should dispatch a request to process pending actions.\n\t */\n\tpublic function maybe_dispatch_async_request() {\n\t\tif ( is_admin() && ! ActionScheduler::lock()->is_locked( 'async-request-runner' ) ) {\n\t\t\t// Only start an async queue at most once every 60 seconds\n\t\t\tActionScheduler::lock()->set( 'async-request-runner' );\n\t\t\t$this->async_request->maybe_dispatch();\n\t\t}\n\t}\n\n\t/**\n\t * Process actions in the queue. Attached to self::WP_CRON_HOOK i.e. 'action_scheduler_run_queue'\n\t *\n\t * The $context param of this method defaults to 'WP Cron', because prior to Action Scheduler 3.0.0\n\t * that was the only context in which this method was run, and the self::WP_CRON_HOOK hook had no context\n\t * passed along with it. New code calling this method directly, or by triggering the self::WP_CRON_HOOK,\n\t * should set a context as the first parameter. For an example of this, refer to the code seen in\n\t * @see ActionScheduler_AsyncRequest_QueueRunner::handle()\n\t *\n\t * @param string $context Optional identifer for the context in which this action is being processed, e.g. 'WP CLI' or 'WP Cron'\n\t *        Generally, this should be capitalised and not localised as it's a proper noun.\n\t * @return int The number of actions processed.\n\t */\n\tpublic function run( $context = 'WP Cron' ) {\n\t\tActionScheduler_Compatibility::raise_memory_limit();\n\t\tActionScheduler_Compatibility::raise_time_limit( $this->get_time_limit() );\n\t\tdo_action( 'action_scheduler_before_process_queue' );\n\t\t$this->run_cleanup();\n\t\t$processed_actions = 0;\n\t\tif ( false === $this->has_maximum_concurrent_batches() ) {\n\t\t\t$batch_size = apply_filters( 'action_scheduler_queue_runner_batch_size', 25 );\n\t\t\tdo {\n\t\t\t\t$processed_actions_in_batch = $this->do_batch( $batch_size, $context );\n\t\t\t\t$processed_actions         += $processed_actions_in_batch;\n\t\t\t} while ( $processed_actions_in_batch > 0 && ! $this->batch_limits_exceeded( $processed_actions ) ); // keep going until we run out of actions, time, or memory\n\t\t}\n\n\t\tdo_action( 'action_scheduler_after_process_queue' );\n\t\treturn $processed_actions;\n\t}\n\n\t/**\n\t * Process a batch of actions pending in the queue.\n\t *\n\t * Actions are processed by claiming a set of pending actions then processing each one until either the batch\n\t * size is completed, or memory or time limits are reached, defined by @see $this->batch_limits_exceeded().\n\t *\n\t * @param int $size The maximum number of actions to process in the batch.\n\t * @param string $context Optional identifer for the context in which this action is being processed, e.g. 'WP CLI' or 'WP Cron'\n\t *        Generally, this should be capitalised and not localised as it's a proper noun.\n\t * @return int The number of actions processed.\n\t */\n\tprotected function do_batch( $size = 100, $context = '' ) {\n\t\t$claim = $this->store->stake_claim($size);\n\t\t$this->monitor->attach($claim);\n\t\t$processed_actions = 0;\n\n\t\tforeach ( $claim->get_actions() as $action_id ) {\n\t\t\t// bail if we lost the claim\n\t\t\tif ( ! in_array( $action_id, $this->store->find_actions_by_claim_id( $claim->get_id() ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$this->process_action( $action_id, $context );\n\t\t\t$processed_actions++;\n\n\t\t\tif ( $this->batch_limits_exceeded( $processed_actions ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->store->release_claim($claim);\n\t\t$this->monitor->detach();\n\t\t$this->clear_caches();\n\t\treturn $processed_actions;\n\t}\n\n\t/**\n\t * Flush the cache if possible (intended for use after a batch of actions has been processed).\n\t *\n\t * This is useful because running large batches can eat up memory and because invalid data can accrue in the\n\t * runtime cache, which may lead to unexpected results.\n\t */\n\tprotected function clear_caches() {\n\t\t/*\n\t\t * Calling wp_cache_flush_runtime() lets us clear the runtime cache without invalidating the external object\n\t\t * cache, so we will always prefer this when it is available (but it was only introduced in WordPress 6.0).\n\t\t */\n\t\tif ( function_exists( 'wp_cache_flush_runtime' ) ) {\n\t\t\twp_cache_flush_runtime();\n\t\t} elseif (\n\t\t\t! wp_using_ext_object_cache()\n\t\t\t/**\n\t\t\t * When an external object cache is in use, and when wp_cache_flush_runtime() is not available, then\n\t\t\t * normally the cache will not be flushed after processing a batch of actions (to avoid a performance\n\t\t\t * penalty for other processes).\n\t\t\t *\n\t\t\t * This filter makes it possible to override this behavior and always flush the cache, even if an external\n\t\t\t * object cache is in use.\n\t\t\t *\n\t\t\t * @since 1.0\n\t\t\t *\n\t\t\t * @param bool $flush_cache If the cache should be flushed.\n\t\t\t */\n\t\t\t|| apply_filters( 'action_scheduler_queue_runner_flush_cache', false )\n\t\t) {\n\t\t\twp_cache_flush();\n\t\t}\n\t}\n\n\tpublic function add_wp_cron_schedule( $schedules ) {\n\t\t$schedules['every_minute'] = array(\n\t\t\t'interval' => 60, // in seconds\n\t\t\t'display'  => __( 'Every minute', 'action-scheduler' ),\n\t\t);\n\n\t\treturn $schedules;\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_QueueRunner.php b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_QueueRunner.php
--- a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_QueueRunner.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_QueueRunner.php	(date 1675081217885)
@@ -173,34 +173,15 @@
 	}
 
 	/**
-	 * Flush the cache if possible (intended for use after a batch of actions has been processed).
+	 * Running large batches can eat up memory, as WP adds data to its object cache.
 	 *
-	 * This is useful because running large batches can eat up memory and because invalid data can accrue in the
-	 * runtime cache, which may lead to unexpected results.
+	 * If using a persistent object store, this has the side effect of flushing that
+	 * as well, so this is disabled by default. To enable:
+	 *
+	 * add_filter( 'action_scheduler_queue_runner_flush_cache', '__return_true' );
 	 */
 	protected function clear_caches() {
-		/*
-		 * Calling wp_cache_flush_runtime() lets us clear the runtime cache without invalidating the external object
-		 * cache, so we will always prefer this when it is available (but it was only introduced in WordPress 6.0).
-		 */
-		if ( function_exists( 'wp_cache_flush_runtime' ) ) {
-			wp_cache_flush_runtime();
-		} elseif (
-			! wp_using_ext_object_cache()
-			/**
-			 * When an external object cache is in use, and when wp_cache_flush_runtime() is not available, then
-			 * normally the cache will not be flushed after processing a batch of actions (to avoid a performance
-			 * penalty for other processes).
-			 *
-			 * This filter makes it possible to override this behavior and always flush the cache, even if an external
-			 * object cache is in use.
-			 *
-			 * @since 1.0
-			 *
-			 * @param bool $flush_cache If the cache should be flushed.
-			 */
-			|| apply_filters( 'action_scheduler_queue_runner_flush_cache', false )
-		) {
+		if ( ! wp_using_ext_object_cache() || apply_filters( 'action_scheduler_queue_runner_flush_cache', false ) ) {
 			wp_cache_flush();
 		}
 	}
Index: inc/Dependencies/ActionScheduler/classes/ActionScheduler_AdminView.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_AdminView\n * @codeCoverageIgnore\n */\nclass ActionScheduler_AdminView extends ActionScheduler_AdminView_Deprecated {\n\n\tprivate static $admin_view = NULL;\n\n\tprivate static $screen_id = 'tools_page_action-scheduler';\n\n\t/** @var ActionScheduler_ListTable */\n\tprotected $list_table;\n\n\t/**\n\t * @return ActionScheduler_AdminView\n\t * @codeCoverageIgnore\n\t */\n\tpublic static function instance() {\n\n\t\tif ( empty( self::$admin_view ) ) {\n\t\t\t$class = apply_filters('action_scheduler_admin_view_class', 'ActionScheduler_AdminView');\n\t\t\tself::$admin_view = new $class();\n\t\t}\n\n\t\treturn self::$admin_view;\n\t}\n\n\t/**\n\t * @codeCoverageIgnore\n\t */\n\tpublic function init() {\n\t\tif ( is_admin() && ( ! defined( 'DOING_AJAX' ) || false == DOING_AJAX ) ) {\n\n\t\t\tif ( class_exists( 'WooCommerce' ) ) {\n\t\t\t\tadd_action( 'woocommerce_admin_status_content_action-scheduler', array( $this, 'render_admin_ui' ) );\n\t\t\t\tadd_action( 'woocommerce_system_status_report', array( $this, 'system_status_report' ) );\n\t\t\t\tadd_filter( 'woocommerce_admin_status_tabs', array( $this, 'register_system_status_tab' ) );\n\t\t\t}\n\n\t\t\tadd_action( 'admin_menu', array( $this, 'register_menu' ) );\n\t\t\tadd_action( 'admin_notices', array( $this, 'maybe_check_pastdue_actions' ) );\n\t\t\tadd_action( 'current_screen', array( $this, 'add_help_tabs' ) );\n\t\t}\n\t}\n\n\tpublic function system_status_report() {\n\t\t$table = new ActionScheduler_wcSystemStatus( ActionScheduler::store() );\n\t\t$table->render();\n\t}\n\n\t/**\n\t * Registers action-scheduler into WooCommerce > System status.\n\t *\n\t * @param array $tabs An associative array of tab key => label.\n\t * @return array $tabs An associative array of tab key => label, including Action Scheduler's tabs\n\t */\n\tpublic function register_system_status_tab( array $tabs ) {\n\t\t$tabs['action-scheduler'] = __( 'Scheduled Actions', 'action-scheduler' );\n\n\t\treturn $tabs;\n\t}\n\n\t/**\n\t * Include Action Scheduler's administration under the Tools menu.\n\t *\n\t * A menu under the Tools menu is important for backward compatibility (as that's\n\t * where it started), and also provides more convenient access than the WooCommerce\n\t * System Status page, and for sites where WooCommerce isn't active.\n\t */\n\tpublic function register_menu() {\n\t\t$hook_suffix = add_submenu_page(\n\t\t\t'tools.php',\n\t\t\t__( 'Scheduled Actions', 'action-scheduler' ),\n\t\t\t__( 'Scheduled Actions', 'action-scheduler' ),\n\t\t\t'manage_options',\n\t\t\t'action-scheduler',\n\t\t\tarray( $this, 'render_admin_ui' )\n\t\t);\n\t\tadd_action( 'load-' . $hook_suffix , array( $this, 'process_admin_ui' ) );\n\t}\n\n\t/**\n\t * Triggers processing of any pending actions.\n\t */\n\tpublic function process_admin_ui() {\n\t\t$this->get_list_table();\n\t}\n\n\t/**\n\t * Renders the Admin UI\n\t */\n\tpublic function render_admin_ui() {\n\t\t$table = $this->get_list_table();\n\t\t$table->display_page();\n\t}\n\n\t/**\n\t * Get the admin UI object and process any requested actions.\n\t *\n\t * @return ActionScheduler_ListTable\n\t */\n\tprotected function get_list_table() {\n\t\tif ( null === $this->list_table ) {\n\t\t\t$this->list_table = new ActionScheduler_ListTable( ActionScheduler::store(), ActionScheduler::logger(), ActionScheduler::runner() );\n\t\t\t$this->list_table->process_actions();\n\t\t}\n\n\t\treturn $this->list_table;\n\t}\n\n\t/**\n\t * Action: admin_notices\n\t *\n\t * Maybe check past-due actions, and print notice.\n\t *\n\t * @uses $this->check_pastdue_actions()\n\t */\n\tpublic function maybe_check_pastdue_actions() {\n\n\t\t# Filter to prevent checking actions (ex: inappropriate user).\n\t\tif ( ! apply_filters( 'action_scheduler_check_pastdue_actions', current_user_can( 'manage_options' ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t# Get last check transient.\n\t\t$last_check = get_transient( 'action_scheduler_last_pastdue_actions_check' );\n\n\t\t# If transient exists, we're within interval, so bail.\n\t\tif ( ! empty( $last_check ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t# Perform the check.\n\t\t$this->check_pastdue_actions();\n\t}\n\n\t/**\n\t * Check past-due actions, and print notice.\n\t *\n\t * @todo update $link_url to \"Past-due\" filter when released (see issue #510, PR #511)\n\t */\n\tprotected function check_pastdue_actions() {\n\n\t\t# Set thresholds.\n\t\t$threshold_seconds = ( int ) apply_filters( 'action_scheduler_pastdue_actions_seconds', DAY_IN_SECONDS );\n\t\t$threshhold_min    = ( int ) apply_filters( 'action_scheduler_pastdue_actions_min', 1 );\n\n\t\t# Allow third-parties to preempt the default check logic.\n\t\t$check = apply_filters( 'action_scheduler_pastdue_actions_check_pre', null );\n\n\t\t# Scheduled actions query arguments.\n\t\t$query_args = array(\n\t\t\t'date'     => as_get_datetime_object( time() - $threshold_seconds ),\n\t\t\t'status'   => ActionScheduler_Store::STATUS_PENDING,\n\t\t\t'per_page' => $threshhold_min,\n\t\t);\n\n\t\t# If no third-party preempted, run default check.\n\t\tif ( is_null( $check ) ) {\n\t\t\t$store = ActionScheduler_Store::instance();\n\t\t\t$num_pastdue_actions = ( int ) $store->query_actions( $query_args, 'count' );\n\n\t\t\t# Check if past-due actions count is greater than or equal to threshold.\n\t\t\t$check = ( $num_pastdue_actions >= $threshhold_min );\n\t\t\t$check = ( bool ) apply_filters( 'action_scheduler_pastdue_actions_check', $check, $num_pastdue_actions, $threshold_seconds, $threshhold_min );\n\t\t}\n\n\t\t# If check failed, set transient and abort.\n\t\tif ( ! boolval( $check ) ) {\n\t\t\t$interval = apply_filters( 'action_scheduler_pastdue_actions_check_interval', round( $threshold_seconds / 4 ), $threshold_seconds );\n\t\t\tset_transient( 'action_scheduler_last_pastdue_actions_check', time(), $interval );\n\n\t\t\treturn;\n\t\t}\n\n\t\t$actions_url = add_query_arg( array(\n\t\t\t'page'   => 'action-scheduler',\n\t\t\t'status' => 'past-due',\n\t\t\t'order'  => 'asc',\n\t\t), admin_url( 'tools.php' ) );\n\n\t\t# Print notice.\n\t\techo '<div class=\"notice notice-warning\"><p>';\n\t\tprintf(\n\t\t\t_n(\n\t\t\t\t// translators: 1) is the number of affected actions, 2) is a link to an admin screen.\n\t\t\t\t'<strong>Action Scheduler:</strong> %1$d <a href=\"%2$s\">past-due action</a> found; something may be wrong. <a href=\"https://actionscheduler.org/faq/#my-site-has-past-due-actions-what-can-i-do\" target=\"_blank\">Read documentation &raquo;</a>',\n\t\t\t\t'<strong>Action Scheduler:</strong> %1$d <a href=\"%2$s\">past-due actions</a> found; something may be wrong. <a href=\"https://actionscheduler.org/faq/#my-site-has-past-due-actions-what-can-i-do\" target=\"_blank\">Read documentation &raquo;</a>',\n\t\t\t\t$num_pastdue_actions,\n\t\t\t\t'action-scheduler'\n\t\t\t),\n\t\t\t$num_pastdue_actions,\n\t\t\tesc_attr( esc_url( $actions_url ) )\n\t\t);\n\t\techo '</p></div>';\n\n\t\t# Facilitate third-parties to evaluate and print notices.\n\t\tdo_action( 'action_scheduler_pastdue_actions_extra_notices', $query_args );\n\t}\n\n\t/**\n\t * Provide more information about the screen and its data in the help tab.\n\t */\n\tpublic function add_help_tabs() {\n\t\t$screen = get_current_screen();\n\n\t\tif ( ! $screen || self::$screen_id != $screen->id ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$as_version = ActionScheduler_Versions::instance()->latest_version();\n\t\t$screen->add_help_tab(\n\t\t\tarray(\n\t\t\t\t'id'      => 'action_scheduler_about',\n\t\t\t\t'title'   => __( 'About', 'action-scheduler' ),\n\t\t\t\t'content' =>\n\t\t\t\t\t'<h2>' . sprintf( __( 'About Action Scheduler %s', 'action-scheduler' ), $as_version ) . '</h2>' .\n\t\t\t\t\t'<p>' .\n\t\t\t\t\t\t__( 'Action Scheduler is a scalable, traceable job queue for background processing large sets of actions. Action Scheduler works by triggering an action hook to run at some time in the future. Scheduled actions can also be scheduled to run on a recurring schedule.', 'action-scheduler' ) .\n\t\t\t\t\t'</p>',\n\t\t\t)\n\t\t);\n\n\t\t$screen->add_help_tab(\n\t\t\tarray(\n\t\t\t\t'id'      => 'action_scheduler_columns',\n\t\t\t\t'title'   => __( 'Columns', 'action-scheduler' ),\n\t\t\t\t'content' =>\n\t\t\t\t\t'<h2>' . __( 'Scheduled Action Columns', 'action-scheduler' ) . '</h2>' .\n\t\t\t\t\t'<ul>' .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Hook', 'action-scheduler' ), __( 'Name of the action hook that will be triggered.', 'action-scheduler' ) ) .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Status', 'action-scheduler' ), __( 'Action statuses are Pending, Complete, Canceled, Failed', 'action-scheduler' ) ) .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Arguments', 'action-scheduler' ), __( 'Optional data array passed to the action hook.', 'action-scheduler' ) ) .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Group', 'action-scheduler' ), __( 'Optional action group.', 'action-scheduler' ) ) .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Recurrence', 'action-scheduler' ), __( 'The action\\'s schedule frequency.', 'action-scheduler' ) ) .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Scheduled', 'action-scheduler' ), __( 'The date/time the action is/was scheduled to run.', 'action-scheduler' ) ) .\n\t\t\t\t\tsprintf( '<li><strong>%1$s</strong>: %2$s</li>', __( 'Log', 'action-scheduler' ), __( 'Activity log for the action.', 'action-scheduler' ) ) .\n\t\t\t\t\t'</ul>',\n\t\t\t)\n\t\t);\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_AdminView.php b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_AdminView.php
--- a/inc/Dependencies/ActionScheduler/classes/ActionScheduler_AdminView.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/ActionScheduler_AdminView.php	(date 1675081217889)
@@ -40,7 +40,7 @@
 			}
 
 			add_action( 'admin_menu', array( $this, 'register_menu' ) );
-			add_action( 'admin_notices', array( $this, 'maybe_check_pastdue_actions' ) );
+
 			add_action( 'current_screen', array( $this, 'add_help_tabs' ) );
 		}
 	}
@@ -110,96 +110,6 @@
 		return $this->list_table;
 	}
 
-	/**
-	 * Action: admin_notices
-	 *
-	 * Maybe check past-due actions, and print notice.
-	 *
-	 * @uses $this->check_pastdue_actions()
-	 */
-	public function maybe_check_pastdue_actions() {
-
-		# Filter to prevent checking actions (ex: inappropriate user).
-		if ( ! apply_filters( 'action_scheduler_check_pastdue_actions', current_user_can( 'manage_options' ) ) ) {
-			return;
-		}
-
-		# Get last check transient.
-		$last_check = get_transient( 'action_scheduler_last_pastdue_actions_check' );
-
-		# If transient exists, we're within interval, so bail.
-		if ( ! empty( $last_check ) ) {
-			return;
-		}
-
-		# Perform the check.
-		$this->check_pastdue_actions();
-	}
-
-	/**
-	 * Check past-due actions, and print notice.
-	 *
-	 * @todo update $link_url to "Past-due" filter when released (see issue #510, PR #511)
-	 */
-	protected function check_pastdue_actions() {
-
-		# Set thresholds.
-		$threshold_seconds = ( int ) apply_filters( 'action_scheduler_pastdue_actions_seconds', DAY_IN_SECONDS );
-		$threshhold_min    = ( int ) apply_filters( 'action_scheduler_pastdue_actions_min', 1 );
-
-		# Allow third-parties to preempt the default check logic.
-		$check = apply_filters( 'action_scheduler_pastdue_actions_check_pre', null );
-
-		# Scheduled actions query arguments.
-		$query_args = array(
-			'date'     => as_get_datetime_object( time() - $threshold_seconds ),
-			'status'   => ActionScheduler_Store::STATUS_PENDING,
-			'per_page' => $threshhold_min,
-		);
-
-		# If no third-party preempted, run default check.
-		if ( is_null( $check ) ) {
-			$store = ActionScheduler_Store::instance();
-			$num_pastdue_actions = ( int ) $store->query_actions( $query_args, 'count' );
-
-			# Check if past-due actions count is greater than or equal to threshold.
-			$check = ( $num_pastdue_actions >= $threshhold_min );
-			$check = ( bool ) apply_filters( 'action_scheduler_pastdue_actions_check', $check, $num_pastdue_actions, $threshold_seconds, $threshhold_min );
-		}
-
-		# If check failed, set transient and abort.
-		if ( ! boolval( $check ) ) {
-			$interval = apply_filters( 'action_scheduler_pastdue_actions_check_interval', round( $threshold_seconds / 4 ), $threshold_seconds );
-			set_transient( 'action_scheduler_last_pastdue_actions_check', time(), $interval );
-
-			return;
-		}
-
-		$actions_url = add_query_arg( array(
-			'page'   => 'action-scheduler',
-			'status' => 'past-due',
-			'order'  => 'asc',
-		), admin_url( 'tools.php' ) );
-
-		# Print notice.
-		echo '<div class="notice notice-warning"><p>';
-		printf(
-			_n(
-				// translators: 1) is the number of affected actions, 2) is a link to an admin screen.
-				'<strong>Action Scheduler:</strong> %1$d <a href="%2$s">past-due action</a> found; something may be wrong. <a href="https://actionscheduler.org/faq/#my-site-has-past-due-actions-what-can-i-do" target="_blank">Read documentation &raquo;</a>',
-				'<strong>Action Scheduler:</strong> %1$d <a href="%2$s">past-due actions</a> found; something may be wrong. <a href="https://actionscheduler.org/faq/#my-site-has-past-due-actions-what-can-i-do" target="_blank">Read documentation &raquo;</a>',
-				$num_pastdue_actions,
-				'action-scheduler'
-			),
-			$num_pastdue_actions,
-			esc_attr( esc_url( $actions_url ) )
-		);
-		echo '</p></div>';
-
-		# Facilitate third-parties to evaluate and print notices.
-		do_action( 'action_scheduler_pastdue_actions_extra_notices', $query_args );
-	}
-
 	/**
 	 * Provide more information about the screen and its data in the help tab.
 	 */
Index: inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Store.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_Store\n * @codeCoverageIgnore\n */\nabstract class ActionScheduler_Store extends ActionScheduler_Store_Deprecated {\n\tconst STATUS_COMPLETE = 'complete';\n\tconst STATUS_PENDING  = 'pending';\n\tconst STATUS_RUNNING  = 'in-progress';\n\tconst STATUS_FAILED   = 'failed';\n\tconst STATUS_CANCELED = 'canceled';\n\tconst DEFAULT_CLASS   = 'ActionScheduler_wpPostStore';\n\n\t/** @var ActionScheduler_Store */\n\tprivate static $store = NULL;\n\n\t/** @var int */\n\tprotected static $max_args_length = 191;\n\n\t/**\n\t * @param ActionScheduler_Action $action\n\t * @param DateTime $scheduled_date Optional Date of the first instance\n\t *        to store. Otherwise uses the first date of the action's\n\t *        schedule.\n\t *\n\t * @return int The action ID\n\t */\n\tabstract public function save_action( ActionScheduler_Action $action, DateTime $scheduled_date = NULL );\n\n\t/**\n\t * @param string $action_id\n\t *\n\t * @return ActionScheduler_Action\n\t */\n\tabstract public function fetch_action( $action_id );\n\n\t/**\n\t * Find an action.\n\t *\n\t * Note: the query ordering changes based on the passed 'status' value.\n\t *\n\t * @param string $hook Action hook.\n\t * @param array  $params Parameters of the action to find.\n\t *\n\t * @return string|null ID of the next action matching the criteria or NULL if not found.\n\t */\n\tpublic function find_action( $hook, $params = array() ) {\n\t\t$params = wp_parse_args(\n\t\t\t$params,\n\t\t\tarray(\n\t\t\t\t'args'   => null,\n\t\t\t\t'status' => self::STATUS_PENDING,\n\t\t\t\t'group'  => '',\n\t\t\t)\n\t\t);\n\n\t\t// These params are fixed for this method.\n\t\t$params['hook']     = $hook;\n\t\t$params['orderby']  = 'date';\n\t\t$params['per_page'] = 1;\n\n\t\tif ( ! empty( $params['status'] ) ) {\n\t\t\tif ( self::STATUS_PENDING === $params['status'] ) {\n\t\t\t\t$params['order'] = 'ASC'; // Find the next action that matches.\n\t\t\t} else {\n\t\t\t\t$params['order'] = 'DESC'; // Find the most recent action that matches.\n\t\t\t}\n\t\t}\n\n\t\t$results = $this->query_actions( $params );\n\n\t\treturn empty( $results ) ? null : $results[0];\n\t}\n\n\t/**\n\t * Query for action count or list of action IDs.\n\t *\n\t * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.\n\t *\n\t * @param array  $query {\n\t *      Query filtering options.\n\t *\n\t *      @type string       $hook             The name of the actions. Optional.\n\t *      @type string|array $status           The status or statuses of the actions. Optional.\n\t *      @type array        $args             The args array of the actions. Optional.\n\t *      @type DateTime     $date             The scheduled date of the action. Used in UTC timezone. Optional.\n\t *      @type string       $date_compare     Operator for selecting by $date param. Accepted values are '!=', '>', '>=', '<', '<=', '='. Defaults to '<='.\n\t *      @type DateTime     $modified         The last modified date of the action. Used in UTC timezone. Optional.\n\t *      @type string       $modified_compare Operator for comparing $modified param. Accepted values are '!=', '>', '>=', '<', '<=', '='. Defaults to '<='.\n\t *      @type string       $group            The group the action belongs to. Optional.\n\t *      @type bool|int     $claimed          TRUE to find claimed actions, FALSE to find unclaimed actions, an int to find a specific claim ID. Optional.\n\t *      @type int          $per_page         Number of results to return. Defaults to 5.\n\t *      @type int          $offset           The query pagination offset. Defaults to 0.\n\t *      @type int          $orderby          Accepted values are 'hook', 'group', 'modified', 'date' or 'none'. Defaults to 'date'.\n\t *      @type string       $order            Accepted values are 'ASC' or 'DESC'. Defaults to 'ASC'.\n\t * }\n\t * @param string $query_type Whether to select or count the results. Default, select.\n\t *\n\t * @return string|array|null The IDs of actions matching the query. Null on failure.\n\t */\n\tabstract public function query_actions( $query = array(), $query_type = 'select' );\n\n\t/**\n\t * Run query to get a single action ID.\n\t *\n\t * @since 3.3.0\n\t *\n\t * @see ActionScheduler_Store::query_actions for $query arg usage but 'per_page' and 'offset' can't be used.\n\t *\n\t * @param array $query Query parameters.\n\t *\n\t * @return int|null\n\t */\n\tpublic function query_action( $query ) {\n\t\t$query['per_page'] = 1;\n\t\t$query['offset']   = 0;\n\t\t$results           = $this->query_actions( $query );\n\n\t\tif ( empty( $results ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn (int) $results[0];\n\t\t}\n\t}\n\n\t/**\n\t * Get a count of all actions in the store, grouped by status\n\t *\n\t * @return array\n\t */\n\tabstract public function action_counts();\n\n\t/**\n\t * Get additional action counts.\n\t *\n\t * - add past-due actions\n\t *\n\t * @return array\n\t */\n\tpublic function extra_action_counts() {\n\t\t$extra_actions = array();\n\n\t\t$pastdue_action_counts = ( int ) $this->query_actions( array(\n\t\t\t'status' => self::STATUS_PENDING,\n\t\t\t'date'   => as_get_datetime_object(),\n\t\t), 'count' );\n\n\t\tif ( $pastdue_action_counts ) {\n\t\t\t$extra_actions['past-due'] = $pastdue_action_counts;\n\t\t}\n\n\t\t/**\n\t\t * Allows 3rd party code to add extra action counts (used in filters in the list table).\n\t\t *\n\t\t * @since 3.5.0\n\t\t * @param $extra_actions array Array with format action_count_identifier => action count.\n\t\t */\n\t\treturn apply_filters( 'action_scheduler_extra_action_counts', $extra_actions );\n\t}\n\n\t/**\n\t * @param string $action_id\n\t */\n\tabstract public function cancel_action( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t */\n\tabstract public function delete_action( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t *\n\t * @return DateTime The date the action is schedule to run, or the date that it ran.\n\t */\n\tabstract public function get_date( $action_id );\n\n\n\t/**\n\t * @param int      $max_actions\n\t * @param DateTime $before_date Claim only actions schedule before the given date. Defaults to now.\n\t * @param array    $hooks       Claim only actions with a hook or hooks.\n\t * @param string   $group       Claim only actions in the given group.\n\t *\n\t * @return ActionScheduler_ActionClaim\n\t */\n\tabstract public function stake_claim( $max_actions = 10, DateTime $before_date = null, $hooks = array(), $group = '' );\n\n\t/**\n\t * @return int\n\t */\n\tabstract public function get_claim_count();\n\n\t/**\n\t * @param ActionScheduler_ActionClaim $claim\n\t */\n\tabstract public function release_claim( ActionScheduler_ActionClaim $claim );\n\n\t/**\n\t * @param string $action_id\n\t */\n\tabstract public function unclaim_action( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t */\n\tabstract public function mark_failure( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t */\n\tabstract public function log_execution( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t */\n\tabstract public function mark_complete( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t *\n\t * @return string\n\t */\n\tabstract public function get_status( $action_id );\n\n\t/**\n\t * @param string $action_id\n\t * @return mixed\n\t */\n\tabstract public function get_claim_id( $action_id );\n\n\t/**\n\t * @param string $claim_id\n\t * @return array\n\t */\n\tabstract public function find_actions_by_claim_id( $claim_id );\n\n\t/**\n\t * @param string $comparison_operator\n\t * @return string\n\t */\n\tprotected function validate_sql_comparator( $comparison_operator ) {\n\t\tif ( in_array( $comparison_operator, array('!=', '>', '>=', '<', '<=', '=') ) ) {\n\t\t\treturn $comparison_operator;\n\t\t}\n\t\treturn '=';\n\t}\n\n\t/**\n\t * Get the time MySQL formated date/time string for an action's (next) scheduled date.\n\t *\n\t * @param ActionScheduler_Action $action\n\t * @param DateTime $scheduled_date (optional)\n\t * @return string\n\t */\n\tprotected function get_scheduled_date_string( ActionScheduler_Action $action, DateTime $scheduled_date = NULL ) {\n\t\t$next = null === $scheduled_date ? $action->get_schedule()->get_date() : $scheduled_date;\n\t\tif ( ! $next ) {\n\t\t\treturn '0000-00-00 00:00:00';\n\t\t}\n\t\t$next->setTimezone( new DateTimeZone( 'UTC' ) );\n\n\t\treturn $next->format( 'Y-m-d H:i:s' );\n\t}\n\n\t/**\n\t * Get the time MySQL formated date/time string for an action's (next) scheduled date.\n\t *\n\t * @param ActionScheduler_Action $action\n\t * @param DateTime $scheduled_date (optional)\n\t * @return string\n\t */\n\tprotected function get_scheduled_date_string_local( ActionScheduler_Action $action, DateTime $scheduled_date = NULL ) {\n\t\t$next = null === $scheduled_date ? $action->get_schedule()->get_date() : $scheduled_date;\n\t\tif ( ! $next ) {\n\t\t\treturn '0000-00-00 00:00:00';\n\t\t}\n\n\t\tActionScheduler_TimezoneHelper::set_local_timezone( $next );\n\t\treturn $next->format( 'Y-m-d H:i:s' );\n\t}\n\n\t/**\n\t * Validate that we could decode action arguments.\n\t *\n\t * @param mixed $args      The decoded arguments.\n\t * @param int   $action_id The action ID.\n\t *\n\t * @throws ActionScheduler_InvalidActionException When the decoded arguments are invalid.\n\t */\n\tprotected function validate_args( $args, $action_id ) {\n\t\t// Ensure we have an array of args.\n\t\tif ( ! is_array( $args ) ) {\n\t\t\tthrow ActionScheduler_InvalidActionException::from_decoding_args( $action_id );\n\t\t}\n\n\t\t// Validate JSON decoding if possible.\n\t\tif ( function_exists( 'json_last_error' ) && JSON_ERROR_NONE !== json_last_error() ) {\n\t\t\tthrow ActionScheduler_InvalidActionException::from_decoding_args( $action_id, $args );\n\t\t}\n\t}\n\n\t/**\n\t * Validate a ActionScheduler_Schedule object.\n\t *\n\t * @param mixed $schedule  The unserialized ActionScheduler_Schedule object.\n\t * @param int   $action_id The action ID.\n\t *\n\t * @throws ActionScheduler_InvalidActionException When the schedule is invalid.\n\t */\n\tprotected function validate_schedule( $schedule, $action_id ) {\n\t\tif ( empty( $schedule ) || ! is_a( $schedule, 'ActionScheduler_Schedule' ) ) {\n\t\t\tthrow ActionScheduler_InvalidActionException::from_schedule( $action_id, $schedule );\n\t\t}\n\t}\n\n\t/**\n\t * InnoDB indexes have a maximum size of 767 bytes by default, which is only 191 characters with utf8mb4.\n\t *\n\t * Previously, AS wasn't concerned about args length, as we used the (unindex) post_content column. However,\n\t * with custom tables, we use an indexed VARCHAR column instead.\n\t *\n\t * @param  ActionScheduler_Action $action Action to be validated.\n\t * @throws InvalidArgumentException When json encoded args is too long.\n\t */\n\tprotected function validate_action( ActionScheduler_Action $action ) {\n\t\tif ( strlen( json_encode( $action->get_args() ) ) > static::$max_args_length ) {\n\t\t\tthrow new InvalidArgumentException( sprintf( __( 'ActionScheduler_Action::$args too long. To ensure the args column can be indexed, action args should not be more than %d characters when encoded as JSON.', 'action-scheduler' ), static::$max_args_length ) );\n\t\t}\n\t}\n\n\t/**\n\t * Cancel pending actions by hook.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param string $hook Hook name.\n\t *\n\t * @return void\n\t */\n\tpublic function cancel_actions_by_hook( $hook ) {\n\t\t$action_ids = true;\n\t\twhile ( ! empty( $action_ids ) ) {\n\t\t\t$action_ids = $this->query_actions(\n\t\t\t\tarray(\n\t\t\t\t\t'hook'     => $hook,\n\t\t\t\t\t'status'   => self::STATUS_PENDING,\n\t\t\t\t\t'per_page' => 1000,\n\t\t\t\t\t'orderby'  => 'action_id',\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t$this->bulk_cancel_actions( $action_ids );\n\t\t}\n\t}\n\n\t/**\n\t * Cancel pending actions by group.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param string $group Group slug.\n\t *\n\t * @return void\n\t */\n\tpublic function cancel_actions_by_group( $group ) {\n\t\t$action_ids = true;\n\t\twhile ( ! empty( $action_ids ) ) {\n\t\t\t$action_ids = $this->query_actions(\n\t\t\t\tarray(\n\t\t\t\t\t'group'    => $group,\n\t\t\t\t\t'status'   => self::STATUS_PENDING,\n\t\t\t\t\t'per_page' => 1000,\n\t\t\t\t\t'orderby'  => 'action_id',\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t$this->bulk_cancel_actions( $action_ids );\n\t\t}\n\t}\n\n\t/**\n\t * Cancel a set of action IDs.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param array $action_ids List of action IDs.\n\t *\n\t * @return void\n\t */\n\tprivate function bulk_cancel_actions( $action_ids ) {\n\t\tforeach ( $action_ids as $action_id ) {\n\t\t\t$this->cancel_action( $action_id );\n\t\t}\n\n\t\tdo_action( 'action_scheduler_bulk_cancel_actions', $action_ids );\n\t}\n\n\t/**\n\t * @return array\n\t */\n\tpublic function get_status_labels() {\n\t\treturn array(\n\t\t\tself::STATUS_COMPLETE => __( 'Complete', 'action-scheduler' ),\n\t\t\tself::STATUS_PENDING  => __( 'Pending', 'action-scheduler' ),\n\t\t\tself::STATUS_RUNNING  => __( 'In-progress', 'action-scheduler' ),\n\t\t\tself::STATUS_FAILED   => __( 'Failed', 'action-scheduler' ),\n\t\t\tself::STATUS_CANCELED => __( 'Canceled', 'action-scheduler' ),\n\t\t);\n\t}\n\n\t/**\n\t * Check if there are any pending scheduled actions due to run.\n\t *\n\t * @param ActionScheduler_Action $action\n\t * @param DateTime $scheduled_date (optional)\n\t * @return string\n\t */\n\tpublic function has_pending_actions_due() {\n\t\t$pending_actions = $this->query_actions( array(\n\t\t\t'date'    => as_get_datetime_object(),\n\t\t\t'status'  => ActionScheduler_Store::STATUS_PENDING,\n\t\t\t'orderby' => 'none',\n\t\t) );\n\n\t\treturn ! empty( $pending_actions );\n\t}\n\n\t/**\n\t * Callable initialization function optionally overridden in derived classes.\n\t */\n\tpublic function init() {}\n\n\t/**\n\t * Callable function to mark an action as migrated optionally overridden in derived classes.\n\t */\n\tpublic function mark_migrated( $action_id ) {}\n\n\t/**\n\t * @return ActionScheduler_Store\n\t */\n\tpublic static function instance() {\n\t\tif ( empty( self::$store ) ) {\n\t\t\t$class = apply_filters( 'action_scheduler_store_class', self::DEFAULT_CLASS );\n\t\t\tself::$store = new $class();\n\t\t}\n\t\treturn self::$store;\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Store.php b/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Store.php
--- a/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Store.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Store.php	(date 1675081217897)
@@ -76,7 +76,7 @@
 	/**
 	 * Query for action count or list of action IDs.
 	 *
-	 * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.
+	 * @since x.x.x $query['status'] accepts array of statuses instead of a single status.
 	 *
 	 * @param array  $query {
 	 *      Query filtering options.
@@ -104,7 +104,7 @@
 	/**
 	 * Run query to get a single action ID.
 	 *
-	 * @since 3.3.0
+	 * @since x.x.x
 	 *
 	 * @see ActionScheduler_Store::query_actions for $query arg usage but 'per_page' and 'offset' can't be used.
 	 *
@@ -131,34 +131,6 @@
 	 */
 	abstract public function action_counts();
 
-	/**
-	 * Get additional action counts.
-	 *
-	 * - add past-due actions
-	 *
-	 * @return array
-	 */
-	public function extra_action_counts() {
-		$extra_actions = array();
-
-		$pastdue_action_counts = ( int ) $this->query_actions( array(
-			'status' => self::STATUS_PENDING,
-			'date'   => as_get_datetime_object(),
-		), 'count' );
-
-		if ( $pastdue_action_counts ) {
-			$extra_actions['past-due'] = $pastdue_action_counts;
-		}
-
-		/**
-		 * Allows 3rd party code to add extra action counts (used in filters in the list table).
-		 *
-		 * @since 3.5.0
-		 * @param $extra_actions array Array with format action_count_identifier => action count.
-		 */
-		return apply_filters( 'action_scheduler_extra_action_counts', $extra_actions );
-	}
-
 	/**
 	 * @param string $action_id
 	 */
Index: inc/Dependencies/ActionScheduler/classes/actions/ActionScheduler_Action.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_Action\n */\nclass ActionScheduler_Action {\n\tprotected $hook = '';\n\tprotected $args = array();\n\t/** @var ActionScheduler_Schedule */\n\tprotected $schedule = NULL;\n\tprotected $group = '';\n\n\tpublic function __construct( $hook, array $args = array(), ActionScheduler_Schedule $schedule = NULL, $group = '' ) {\n\t\t$schedule = empty( $schedule ) ? new ActionScheduler_NullSchedule() : $schedule;\n\t\t$this->set_hook($hook);\n\t\t$this->set_schedule($schedule);\n\t\t$this->set_args($args);\n\t\t$this->set_group($group);\n\t}\n\n\t/**\n\t * Executes the action.\n\t *\n\t * If no callbacks are registered, an exception will be thrown and the action will not be\n\t * fired. This is useful to help detect cases where the code responsible for setting up\n\t * a scheduled action no longer exists.\n\t *\n\t * @throws Exception If no callbacks are registered for this action.\n\t */\n\tpublic function execute() {\n\t\t$hook = $this->get_hook();\n\n\t\tif ( ! has_action( $hook ) ) {\n\t\t\tthrow new Exception(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: action hook. */\n\t\t\t\t\t__( 'Scheduled action for %1$s will not be executed as no callbacks are registered.', 'action-scheduler' ),\n\t\t\t\t\t$hook\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tdo_action_ref_array( $hook, array_values( $this->get_args() ) );\n\t}\n\n\t/**\n\t * @param string $hook\n\t */\n\tprotected function set_hook( $hook ) {\n\t\t$this->hook = $hook;\n\t}\n\n\tpublic function get_hook() {\n\t\treturn $this->hook;\n\t}\n\n\tprotected function set_schedule( ActionScheduler_Schedule $schedule ) {\n\t\t$this->schedule = $schedule;\n\t}\n\n\t/**\n\t * @return ActionScheduler_Schedule\n\t */\n\tpublic function get_schedule() {\n\t\treturn $this->schedule;\n\t}\n\n\tprotected function set_args( array $args ) {\n\t\t$this->args = $args;\n\t}\n\n\tpublic function get_args() {\n\t\treturn $this->args;\n\t}\n\n\t/**\n\t * @param string $group\n\t */\n\tprotected function set_group( $group ) {\n\t\t$this->group = $group;\n\t}\n\n\t/**\n\t * @return string\n\t */\n\tpublic function get_group() {\n\t\treturn $this->group;\n\t}\n\n\t/**\n\t * @return bool If the action has been finished\n\t */\n\tpublic function is_finished() {\n\t\treturn FALSE;\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/actions/ActionScheduler_Action.php b/inc/Dependencies/ActionScheduler/classes/actions/ActionScheduler_Action.php
--- a/inc/Dependencies/ActionScheduler/classes/actions/ActionScheduler_Action.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/actions/ActionScheduler_Action.php	(date 1675081217901)
@@ -18,29 +18,8 @@
 		$this->set_group($group);
 	}
 
-	/**
-	 * Executes the action.
-	 *
-	 * If no callbacks are registered, an exception will be thrown and the action will not be
-	 * fired. This is useful to help detect cases where the code responsible for setting up
-	 * a scheduled action no longer exists.
-	 *
-	 * @throws Exception If no callbacks are registered for this action.
-	 */
 	public function execute() {
-		$hook = $this->get_hook();
-
-		if ( ! has_action( $hook ) ) {
-			throw new Exception(
-				sprintf(
-					/* translators: 1: action hook. */
-					__( 'Scheduled action for %1$s will not be executed as no callbacks are registered.', 'action-scheduler' ),
-					$hook
-				)
-			);
-		}
-
-		do_action_ref_array( $hook, array_values( $this->get_args() ) );
+		return do_action_ref_array( $this->get_hook(), array_values( $this->get_args() ) );
 	}
 
 	/**
Index: inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_DBStore.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_DBStore\n *\n * Action data table data store.\n *\n * @since 3.0.0\n */\nclass ActionScheduler_DBStore extends ActionScheduler_Store {\n\n\t/**\n\t * Used to share information about the before_date property of claims internally.\n\t *\n\t * This is used in preference to passing the same information as a method param\n\t * for backwards-compatibility reasons.\n\t *\n\t * @var DateTime|null\n\t */\n\tprivate $claim_before_date = null;\n\n\t/** @var int */\n\tprotected static $max_args_length = 8000;\n\n\t/** @var int */\n\tprotected static $max_index_length = 191;\n\n\t/**\n\t * Initialize the data store\n\t *\n\t * @codeCoverageIgnore\n\t */\n\tpublic function init() {\n\t\t$table_maker = new ActionScheduler_StoreSchema();\n\t\t$table_maker->init();\n\t\t$table_maker->register_tables();\n\t}\n\n\t/**\n\t * Save an action, checks if this is a unique action before actually saving.\n\t *\n\t * @param ActionScheduler_Action $action         Action object.\n\t * @param \\DateTime              $scheduled_date Optional schedule date. Default null.\n\t *\n\t * @return int                  Action ID.\n\t * @throws RuntimeException     Throws exception when saving the action fails.\n\t */\n\tpublic function save_unique_action( ActionScheduler_Action $action, \\DateTime $scheduled_date = null ) {\n\t\treturn $this->save_action_to_db( $action, $scheduled_date, true );\n\t}\n\n\t/**\n\t * Save an action. Can save duplicate action as well, prefer using `save_unique_action` instead.\n\t *\n\t * @param ActionScheduler_Action $action Action object.\n\t * @param \\DateTime              $scheduled_date Optional schedule date. Default null.\n\t *\n\t * @return int Action ID.\n\t * @throws RuntimeException     Throws exception when saving the action fails.\n\t */\n\tpublic function save_action( ActionScheduler_Action $action, \\DateTime $scheduled_date = null ) {\n\t\treturn $this->save_action_to_db( $action, $scheduled_date, false );\n\t}\n\n\t/**\n\t * Save an action.\n\t *\n\t * @param ActionScheduler_Action $action Action object.\n\t * @param ?DateTime              $date Optional schedule date. Default null.\n\t * @param bool                   $unique Whether the action should be unique.\n\t *\n\t * @return int Action ID.\n\t * @throws RuntimeException     Throws exception when saving the action fails.\n\t */\n\tprivate function save_action_to_db( ActionScheduler_Action $action, DateTime $date = null, $unique = false ) {\n\t\tglobal $wpdb;\n\n\t\ttry {\n\t\t\t$this->validate_action( $action );\n\n\t\t\t$data = array(\n\t\t\t\t'hook'                 => $action->get_hook(),\n\t\t\t\t'status'               => ( $action->is_finished() ? self::STATUS_COMPLETE : self::STATUS_PENDING ),\n\t\t\t\t'scheduled_date_gmt'   => $this->get_scheduled_date_string( $action, $date ),\n\t\t\t\t'scheduled_date_local' => $this->get_scheduled_date_string_local( $action, $date ),\n\t\t\t\t'schedule'             => serialize( $action->get_schedule() ), // phpcs:ignore WordPress.PHP.DiscouragedPHPFunctions.serialize_serialize\n\t\t\t\t'group_id'             => $this->get_group_id( $action->get_group() ),\n\t\t\t);\n\n\t\t\t$args = wp_json_encode( $action->get_args() );\n\t\t\tif ( strlen( $args ) <= static::$max_index_length ) {\n\t\t\t\t$data['args'] = $args;\n\t\t\t} else {\n\t\t\t\t$data['args']          = $this->hash_args( $args );\n\t\t\t\t$data['extended_args'] = $args;\n\t\t\t}\n\n\t\t\t$insert_sql = $this->build_insert_sql( $data, $unique );\n\n\t\t\t// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- $insert_sql should be already prepared.\n\t\t\t$wpdb->query( $insert_sql );\n\t\t\t$action_id = $wpdb->insert_id;\n\n\t\t\tif ( is_wp_error( $action_id ) ) {\n\t\t\t\tthrow new \\RuntimeException( $action_id->get_error_message() );\n\t\t\t} elseif ( empty( $action_id ) ) {\n\t\t\t\tif ( $unique ) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tthrow new \\RuntimeException( $wpdb->last_error ? $wpdb->last_error : __( 'Database error.', 'action-scheduler' ) );\n\t\t\t}\n\n\t\t\tdo_action( 'action_scheduler_stored_action', $action_id );\n\n\t\t\treturn $action_id;\n\t\t} catch ( \\Exception $e ) {\n\t\t\t/* translators: %s: error message */\n\t\t\tthrow new \\RuntimeException( sprintf( __( 'Error saving action: %s', 'action-scheduler' ), $e->getMessage() ), 0 );\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to build insert query.\n\t *\n\t * @param array $data Row data for action.\n\t * @param bool  $unique Whether the action should be unique.\n\t *\n\t * @return string Insert query.\n\t */\n\tprivate function build_insert_sql( array $data, $unique ) {\n\t\tglobal $wpdb;\n\t\t$columns      = array_keys( $data );\n\t\t$values       = array_values( $data );\n\t\t$placeholders = array_map( array( $this, 'get_placeholder_for_column' ), $columns );\n\n\t\t$table_name = ! empty( $wpdb->actionscheduler_actions ) ? $wpdb->actionscheduler_actions : $wpdb->prefix . 'actionscheduler_actions';\n\n\t\t$column_sql      = '`' . implode( '`, `', $columns ) . '`';\n\t\t$placeholder_sql = implode( ', ', $placeholders );\n\t\t$where_clause    = $this->build_where_clause_for_insert( $data, $table_name, $unique );\n\t\t// phpcs:disable WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- $column_sql and $where_clause are already prepared. $placeholder_sql is hardcoded.\n\t\t$insert_query    = $wpdb->prepare(\n\t\t\t\"\nINSERT INTO $table_name ( $column_sql )\nSELECT $placeholder_sql FROM DUAL\nWHERE ( $where_clause ) IS NULL\",\n\t\t\t$values\n\t\t);\n\t\t// phpcs:enable\n\n\t\treturn $insert_query;\n\t}\n\n\t/**\n\t * Helper method to build where clause for action insert statement.\n\t *\n\t * @param array  $data Row data for action.\n\t * @param string $table_name Action table name.\n\t * @param bool   $unique Where action should be unique.\n\t *\n\t * @return string Where clause to be used with insert.\n\t */\n\tprivate function build_where_clause_for_insert( $data, $table_name, $unique ) {\n\t\tglobal $wpdb;\n\n\t\tif ( ! $unique ) {\n\t\t\treturn 'SELECT NULL FROM DUAL';\n\t\t}\n\n\t\t$pending_statuses            = array(\n\t\t\tActionScheduler_Store::STATUS_PENDING,\n\t\t\tActionScheduler_Store::STATUS_RUNNING,\n\t\t);\n\t\t$pending_status_placeholders = implode( ', ', array_fill( 0, count( $pending_statuses ), '%s' ) );\n\t\t// phpcs:disable WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- $pending_status_placeholders is hardcoded.\n\t\t$where_clause = $wpdb->prepare(\n\t\t\t\"\nSELECT action_id FROM $table_name\nWHERE status IN ( $pending_status_placeholders )\nAND hook = %s\nAND `group_id` = %d\n\",\n\t\t\tarray_merge(\n\t\t\t\t$pending_statuses,\n\t\t\t\tarray(\n\t\t\t\t\t$data['hook'],\n\t\t\t\t\t$data['group_id'],\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\t// phpcs:enable\n\n\t\treturn \"$where_clause\" . ' LIMIT 1';\n\t}\n\n\t/**\n\t * Helper method to get $wpdb->prepare placeholder for a given column name.\n\t *\n\t * @param string $column_name Name of column in actions table.\n\t *\n\t * @return string Placeholder to use for given column.\n\t */\n\tprivate function get_placeholder_for_column( $column_name ) {\n\t\t$string_columns = array(\n\t\t\t'hook',\n\t\t\t'status',\n\t\t\t'scheduled_date_gmt',\n\t\t\t'scheduled_date_local',\n\t\t\t'args',\n\t\t\t'schedule',\n\t\t\t'last_attempt_gmt',\n\t\t\t'last_attempt_local',\n\t\t\t'extended_args',\n\t\t);\n\n\t\treturn in_array( $column_name, $string_columns ) ? '%s' : '%d';\n\t}\n\n\t/**\n\t * Generate a hash from json_encoded $args using MD5 as this isn't for security.\n\t *\n\t * @param string $args JSON encoded action args.\n\t * @return string\n\t */\n\tprotected function hash_args( $args ) {\n\t\treturn md5( $args );\n\t}\n\n\t/**\n\t * Get action args query param value from action args.\n\t *\n\t * @param array $args Action args.\n\t * @return string\n\t */\n\tprotected function get_args_for_query( $args ) {\n\t\t$encoded = wp_json_encode( $args );\n\t\tif ( strlen( $encoded ) <= static::$max_index_length ) {\n\t\t\treturn $encoded;\n\t\t}\n\t\treturn $this->hash_args( $encoded );\n\t}\n\t/**\n\t * Get a group's ID based on its name/slug.\n\t *\n\t * @param string $slug The string name of a group.\n\t * @param bool   $create_if_not_exists Whether to create the group if it does not already exist. Default, true - create the group.\n\t *\n\t * @return int The group's ID, if it exists or is created, or 0 if it does not exist and is not created.\n\t */\n\tprotected function get_group_id( $slug, $create_if_not_exists = true ) {\n\t\tif ( empty( $slug ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$group_id = (int) $wpdb->get_var( $wpdb->prepare( \"SELECT group_id FROM {$wpdb->actionscheduler_groups} WHERE slug=%s\", $slug ) );\n\t\tif ( empty( $group_id ) && $create_if_not_exists ) {\n\t\t\t$group_id = $this->create_group( $slug );\n\t\t}\n\n\t\treturn $group_id;\n\t}\n\n\t/**\n\t * Create an action group.\n\t *\n\t * @param string $slug Group slug.\n\t *\n\t * @return int Group ID.\n\t */\n\tprotected function create_group( $slug ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$wpdb->insert( $wpdb->actionscheduler_groups, array( 'slug' => $slug ) );\n\n\t\treturn (int) $wpdb->insert_id;\n\t}\n\n\t/**\n\t * Retrieve an action.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return ActionScheduler_Action\n\t */\n\tpublic function fetch_action( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$data = $wpdb->get_row(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"SELECT a.*, g.slug AS `group` FROM {$wpdb->actionscheduler_actions} a LEFT JOIN {$wpdb->actionscheduler_groups} g ON a.group_id=g.group_id WHERE a.action_id=%d\",\n\t\t\t\t$action_id\n\t\t\t)\n\t\t);\n\n\t\tif ( empty( $data ) ) {\n\t\t\treturn $this->get_null_action();\n\t\t}\n\n\t\tif ( ! empty( $data->extended_args ) ) {\n\t\t\t$data->args = $data->extended_args;\n\t\t\tunset( $data->extended_args );\n\t\t}\n\n\t\t// Convert NULL dates to zero dates.\n\t\t$date_fields = array(\n\t\t\t'scheduled_date_gmt',\n\t\t\t'scheduled_date_local',\n\t\t\t'last_attempt_gmt',\n\t\t\t'last_attempt_gmt',\n\t\t);\n\t\tforeach ( $date_fields as $date_field ) {\n\t\t\tif ( is_null( $data->$date_field ) ) {\n\t\t\t\t$data->$date_field = ActionScheduler_StoreSchema::DEFAULT_DATE;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t$action = $this->make_action_from_db_record( $data );\n\t\t} catch ( ActionScheduler_InvalidActionException $exception ) {\n\t\t\tdo_action( 'action_scheduler_failed_fetch_action', $action_id, $exception );\n\t\t\treturn $this->get_null_action();\n\t\t}\n\n\t\treturn $action;\n\t}\n\n\t/**\n\t * Create a null action.\n\t *\n\t * @return ActionScheduler_NullAction\n\t */\n\tprotected function get_null_action() {\n\t\treturn new ActionScheduler_NullAction();\n\t}\n\n\t/**\n\t * Create an action from a database record.\n\t *\n\t * @param object $data Action database record.\n\t *\n\t * @return ActionScheduler_Action|ActionScheduler_CanceledAction|ActionScheduler_FinishedAction\n\t */\n\tprotected function make_action_from_db_record( $data ) {\n\n\t\t$hook     = $data->hook;\n\t\t$args     = json_decode( $data->args, true );\n\t\t$schedule = unserialize( $data->schedule ); // phpcs:ignore WordPress.PHP.DiscouragedPHPFunctions.serialize_unserialize\n\n\t\t$this->validate_args( $args, $data->action_id );\n\t\t$this->validate_schedule( $schedule, $data->action_id );\n\n\t\tif ( empty( $schedule ) ) {\n\t\t\t$schedule = new ActionScheduler_NullSchedule();\n\t\t}\n\t\t$group = $data->group ? $data->group : '';\n\n\t\treturn ActionScheduler::factory()->get_stored_action( $data->status, $data->hook, $args, $schedule, $group );\n\t}\n\n\t/**\n\t * Returns the SQL statement to query (or count) actions.\n\t *\n\t * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.\n\t *\n\t * @param array  $query Filtering options.\n\t * @param string $select_or_count  Whether the SQL should select and return the IDs or just the row count.\n\t *\n\t * @return string SQL statement already properly escaped.\n\t * @throws InvalidArgumentException If the query is invalid.\n\t */\n\tprotected function get_query_actions_sql( array $query, $select_or_count = 'select' ) {\n\n\t\tif ( ! in_array( $select_or_count, array( 'select', 'count' ), true ) ) {\n\t\t\tthrow new InvalidArgumentException( __( 'Invalid value for select or count parameter. Cannot query actions.', 'action-scheduler' ) );\n\t\t}\n\n\t\t$query = wp_parse_args(\n\t\t\t$query,\n\t\t\tarray(\n\t\t\t\t'hook'             => '',\n\t\t\t\t'args'             => null,\n\t\t\t\t'date'             => null,\n\t\t\t\t'date_compare'     => '<=',\n\t\t\t\t'modified'         => null,\n\t\t\t\t'modified_compare' => '<=',\n\t\t\t\t'group'            => '',\n\t\t\t\t'status'           => '',\n\t\t\t\t'claimed'          => null,\n\t\t\t\t'per_page'         => 5,\n\t\t\t\t'offset'           => 0,\n\t\t\t\t'orderby'          => 'date',\n\t\t\t\t'order'            => 'ASC',\n\t\t\t)\n\t\t);\n\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$sql        = ( 'count' === $select_or_count ) ? 'SELECT count(a.action_id)' : 'SELECT a.action_id';\n\t\t$sql       .= \" FROM {$wpdb->actionscheduler_actions} a\";\n\t\t$sql_params = array();\n\n\t\tif ( ! empty( $query['group'] ) || 'group' === $query['orderby'] ) {\n\t\t\t$sql .= \" LEFT JOIN {$wpdb->actionscheduler_groups} g ON g.group_id=a.group_id\";\n\t\t}\n\n\t\t$sql .= ' WHERE 1=1';\n\n\t\tif ( ! empty( $query['group'] ) ) {\n\t\t\t$sql         .= ' AND g.slug=%s';\n\t\t\t$sql_params[] = $query['group'];\n\t\t}\n\n\t\tif ( $query['hook'] ) {\n\t\t\t$sql         .= ' AND a.hook=%s';\n\t\t\t$sql_params[] = $query['hook'];\n\t\t}\n\t\tif ( ! is_null( $query['args'] ) ) {\n\t\t\t$sql         .= ' AND a.args=%s';\n\t\t\t$sql_params[] = $this->get_args_for_query( $query['args'] );\n\t\t}\n\n\t\tif ( $query['status'] ) {\n\t\t\t$statuses     = (array) $query['status'];\n\t\t\t$placeholders = array_fill( 0, count( $statuses ), '%s' );\n\t\t\t$sql         .= ' AND a.status IN (' . join( ', ', $placeholders ) . ')';\n\t\t\t$sql_params   = array_merge( $sql_params, array_values( $statuses ) );\n\t\t}\n\n\t\tif ( $query['date'] instanceof \\DateTime ) {\n\t\t\t$date = clone $query['date'];\n\t\t\t$date->setTimezone( new \\DateTimeZone( 'UTC' ) );\n\t\t\t$date_string  = $date->format( 'Y-m-d H:i:s' );\n\t\t\t$comparator   = $this->validate_sql_comparator( $query['date_compare'] );\n\t\t\t$sql         .= \" AND a.scheduled_date_gmt $comparator %s\";\n\t\t\t$sql_params[] = $date_string;\n\t\t}\n\n\t\tif ( $query['modified'] instanceof \\DateTime ) {\n\t\t\t$modified = clone $query['modified'];\n\t\t\t$modified->setTimezone( new \\DateTimeZone( 'UTC' ) );\n\t\t\t$date_string  = $modified->format( 'Y-m-d H:i:s' );\n\t\t\t$comparator   = $this->validate_sql_comparator( $query['modified_compare'] );\n\t\t\t$sql         .= \" AND a.last_attempt_gmt $comparator %s\";\n\t\t\t$sql_params[] = $date_string;\n\t\t}\n\n\t\tif ( true === $query['claimed'] ) {\n\t\t\t$sql .= ' AND a.claim_id != 0';\n\t\t} elseif ( false === $query['claimed'] ) {\n\t\t\t$sql .= ' AND a.claim_id = 0';\n\t\t} elseif ( ! is_null( $query['claimed'] ) ) {\n\t\t\t$sql         .= ' AND a.claim_id = %d';\n\t\t\t$sql_params[] = $query['claimed'];\n\t\t}\n\n\t\tif ( ! empty( $query['search'] ) ) {\n\t\t\t$sql .= ' AND (a.hook LIKE %s OR (a.extended_args IS NULL AND a.args LIKE %s) OR a.extended_args LIKE %s';\n\t\t\tfor ( $i = 0; $i < 3; $i++ ) {\n\t\t\t\t$sql_params[] = sprintf( '%%%s%%', $query['search'] );\n\t\t\t}\n\n\t\t\t$search_claim_id = (int) $query['search'];\n\t\t\tif ( $search_claim_id ) {\n\t\t\t\t$sql         .= ' OR a.claim_id = %d';\n\t\t\t\t$sql_params[] = $search_claim_id;\n\t\t\t}\n\n\t\t\t$sql .= ')';\n\t\t}\n\n\t\tif ( 'select' === $select_or_count ) {\n\t\t\tif ( 'ASC' === strtoupper( $query['order'] ) ) {\n\t\t\t\t$order = 'ASC';\n\t\t\t} else {\n\t\t\t\t$order = 'DESC';\n\t\t\t}\n\t\t\tswitch ( $query['orderby'] ) {\n\t\t\t\tcase 'hook':\n\t\t\t\t\t$sql .= \" ORDER BY a.hook $order\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'group':\n\t\t\t\t\t$sql .= \" ORDER BY g.slug $order\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'modified':\n\t\t\t\t\t$sql .= \" ORDER BY a.last_attempt_gmt $order\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'none':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'action_id':\n\t\t\t\t\t$sql .= \" ORDER BY a.action_id $order\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'date':\n\t\t\t\tdefault:\n\t\t\t\t\t$sql .= \" ORDER BY a.scheduled_date_gmt $order\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( $query['per_page'] > 0 ) {\n\t\t\t\t$sql         .= ' LIMIT %d, %d';\n\t\t\t\t$sql_params[] = $query['offset'];\n\t\t\t\t$sql_params[] = $query['per_page'];\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $sql_params ) ) {\n\t\t\t$sql = $wpdb->prepare( $sql, $sql_params ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t}\n\n\t\treturn $sql;\n\t}\n\n\t/**\n\t * Query for action count or list of action IDs.\n\t *\n\t * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.\n\t *\n\t * @see ActionScheduler_Store::query_actions for $query arg usage.\n\t *\n\t * @param array  $query      Query filtering options.\n\t * @param string $query_type Whether to select or count the results. Defaults to select.\n\t *\n\t * @return string|array|null The IDs of actions matching the query. Null on failure.\n\t */\n\tpublic function query_actions( $query = array(), $query_type = 'select' ) {\n\t\t/** @var wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\t$sql = $this->get_query_actions_sql( $query, $query_type );\n\n\t\treturn ( 'count' === $query_type ) ? $wpdb->get_var( $sql ) : $wpdb->get_col( $sql ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.DirectDatabaseQuery.NoSql, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t}\n\n\t/**\n\t * Get a count of all actions in the store, grouped by status.\n\t *\n\t * @return array Set of 'status' => int $count pairs for statuses with 1 or more actions of that status.\n\t */\n\tpublic function action_counts() {\n\t\tglobal $wpdb;\n\n\t\t$sql  = \"SELECT a.status, count(a.status) as 'count'\";\n\t\t$sql .= \" FROM {$wpdb->actionscheduler_actions} a\";\n\t\t$sql .= ' GROUP BY a.status';\n\n\t\t$actions_count_by_status = array();\n\t\t$action_stati_and_labels = $this->get_status_labels();\n\n\t\tforeach ( $wpdb->get_results( $sql ) as $action_data ) { // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t\t// Ignore any actions with invalid status.\n\t\t\tif ( array_key_exists( $action_data->status, $action_stati_and_labels ) ) {\n\t\t\t\t$actions_count_by_status[ $action_data->status ] = $action_data->count;\n\t\t\t}\n\t\t}\n\n\t\treturn $actions_count_by_status;\n\t}\n\n\t/**\n\t * Cancel an action.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return void\n\t * @throws \\InvalidArgumentException If the action update failed.\n\t */\n\tpublic function cancel_action( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\t$updated = $wpdb->update(\n\t\t\t$wpdb->actionscheduler_actions,\n\t\t\tarray( 'status' => self::STATUS_CANCELED ),\n\t\t\tarray( 'action_id' => $action_id ),\n\t\t\tarray( '%s' ),\n\t\t\tarray( '%d' )\n\t\t);\n\t\tif ( false === $updated ) {\n\t\t\t/* translators: %s: action ID */\n\t\t\tthrow new \\InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t\tdo_action( 'action_scheduler_canceled_action', $action_id );\n\t}\n\n\t/**\n\t * Cancel pending actions by hook.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param string $hook Hook name.\n\t *\n\t * @return void\n\t */\n\tpublic function cancel_actions_by_hook( $hook ) {\n\t\t$this->bulk_cancel_actions( array( 'hook' => $hook ) );\n\t}\n\n\t/**\n\t * Cancel pending actions by group.\n\t *\n\t * @param string $group Group slug.\n\t *\n\t * @return void\n\t */\n\tpublic function cancel_actions_by_group( $group ) {\n\t\t$this->bulk_cancel_actions( array( 'group' => $group ) );\n\t}\n\n\t/**\n\t * Bulk cancel actions.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param array $query_args Query parameters.\n\t */\n\tprotected function bulk_cancel_actions( $query_args ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\tif ( ! is_array( $query_args ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't cancel actions that are already canceled.\n\t\tif ( isset( $query_args['status'] ) && self::STATUS_CANCELED === $query_args['status'] ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$action_ids = true;\n\t\t$query_args = wp_parse_args(\n\t\t\t$query_args,\n\t\t\tarray(\n\t\t\t\t'per_page' => 1000,\n\t\t\t\t'status'   => self::STATUS_PENDING,\n\t\t\t\t'orderby'  => 'action_id',\n\t\t\t)\n\t\t);\n\n\t\twhile ( $action_ids ) {\n\t\t\t$action_ids = $this->query_actions( $query_args );\n\t\t\tif ( empty( $action_ids ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$format     = array_fill( 0, count( $action_ids ), '%d' );\n\t\t\t$query_in   = '(' . implode( ',', $format ) . ')';\n\t\t\t$parameters = $action_ids;\n\t\t\tarray_unshift( $parameters, self::STATUS_CANCELED );\n\n\t\t\t$wpdb->query(\n\t\t\t\t$wpdb->prepare(\n\t\t\t\t\t\"UPDATE {$wpdb->actionscheduler_actions} SET status = %s WHERE action_id IN {$query_in}\", // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared\n\t\t\t\t\t$parameters\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tdo_action( 'action_scheduler_bulk_cancel_actions', $action_ids );\n\t\t}\n\t}\n\n\t/**\n\t * Delete an action.\n\t *\n\t * @param int $action_id Action ID.\n\t * @throws \\InvalidArgumentException If the action deletion failed.\n\t */\n\tpublic function delete_action( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$deleted = $wpdb->delete( $wpdb->actionscheduler_actions, array( 'action_id' => $action_id ), array( '%d' ) );\n\t\tif ( empty( $deleted ) ) {\n\t\t\tthrow new \\InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) ); //phpcs:ignore WordPress.WP.I18n.MissingTranslatorsComment\n\t\t}\n\t\tdo_action( 'action_scheduler_deleted_action', $action_id );\n\t}\n\n\t/**\n\t * Get the schedule date for an action.\n\t *\n\t * @param string $action_id Action ID.\n\t *\n\t * @return \\DateTime The local date the action is scheduled to run, or the date that it ran.\n\t */\n\tpublic function get_date( $action_id ) {\n\t\t$date = $this->get_date_gmt( $action_id );\n\t\tActionScheduler_TimezoneHelper::set_local_timezone( $date );\n\t\treturn $date;\n\t}\n\n\t/**\n\t * Get the GMT schedule date for an action.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @throws \\InvalidArgumentException If action cannot be identified.\n\t * @return \\DateTime The GMT date the action is scheduled to run, or the date that it ran.\n\t */\n\tprotected function get_date_gmt( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$record = $wpdb->get_row( $wpdb->prepare( \"SELECT * FROM {$wpdb->actionscheduler_actions} WHERE action_id=%d\", $action_id ) );\n\t\tif ( empty( $record ) ) {\n\t\t\tthrow new \\InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) ); //phpcs:ignore WordPress.WP.I18n.MissingTranslatorsComment\n\t\t}\n\t\tif ( self::STATUS_PENDING === $record->status ) {\n\t\t\treturn as_get_datetime_object( $record->scheduled_date_gmt );\n\t\t} else {\n\t\t\treturn as_get_datetime_object( $record->last_attempt_gmt );\n\t\t}\n\t}\n\n\t/**\n\t * Stake a claim on actions.\n\t *\n\t * @param int       $max_actions Maximum number of action to include in claim.\n\t * @param \\DateTime $before_date Jobs must be schedule before this date. Defaults to now.\n\t * @param array     $hooks Hooks to filter for.\n\t * @param string    $group Group to filter for.\n\t *\n\t * @return ActionScheduler_ActionClaim\n\t */\n\tpublic function stake_claim( $max_actions = 10, \\DateTime $before_date = null, $hooks = array(), $group = '' ) {\n\t\t$claim_id = $this->generate_claim_id();\n\n\t\t$this->claim_before_date = $before_date;\n\t\t$this->claim_actions( $claim_id, $max_actions, $before_date, $hooks, $group );\n\t\t$action_ids              = $this->find_actions_by_claim_id( $claim_id );\n\t\t$this->claim_before_date = null;\n\n\t\treturn new ActionScheduler_ActionClaim( $claim_id, $action_ids );\n\t}\n\n\t/**\n\t * Generate a new action claim.\n\t *\n\t * @return int Claim ID.\n\t */\n\tprotected function generate_claim_id() {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$now = as_get_datetime_object();\n\t\t$wpdb->insert( $wpdb->actionscheduler_claims, array( 'date_created_gmt' => $now->format( 'Y-m-d H:i:s' ) ) );\n\n\t\treturn $wpdb->insert_id;\n\t}\n\n\t/**\n\t * Mark actions claimed.\n\t *\n\t * @param string    $claim_id Claim Id.\n\t * @param int       $limit Number of action to include in claim.\n\t * @param \\DateTime $before_date Should use UTC timezone.\n\t * @param array     $hooks Hooks to filter for.\n\t * @param string    $group Group to filter for.\n\t *\n\t * @return int The number of actions that were claimed.\n\t * @throws \\InvalidArgumentException Throws InvalidArgumentException if group doesn't exist.\n\t * @throws \\RuntimeException Throws RuntimeException if unable to claim action.\n\t */\n\tprotected function claim_actions( $claim_id, $limit, \\DateTime $before_date = null, $hooks = array(), $group = '' ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\t$now  = as_get_datetime_object();\n\t\t$date = is_null( $before_date ) ? $now : clone $before_date;\n\n\t\t// can't use $wpdb->update() because of the <= condition.\n\t\t$update = \"UPDATE {$wpdb->actionscheduler_actions} SET claim_id=%d, last_attempt_gmt=%s, last_attempt_local=%s\";\n\t\t$params = array(\n\t\t\t$claim_id,\n\t\t\t$now->format( 'Y-m-d H:i:s' ),\n\t\t\tcurrent_time( 'mysql' ),\n\t\t);\n\n\t\t$where    = 'WHERE claim_id = 0 AND scheduled_date_gmt <= %s AND status=%s';\n\t\t$params[] = $date->format( 'Y-m-d H:i:s' );\n\t\t$params[] = self::STATUS_PENDING;\n\n\t\tif ( ! empty( $hooks ) ) {\n\t\t\t$placeholders = array_fill( 0, count( $hooks ), '%s' );\n\t\t\t$where       .= ' AND hook IN (' . join( ', ', $placeholders ) . ')';\n\t\t\t$params       = array_merge( $params, array_values( $hooks ) );\n\t\t}\n\n\t\tif ( ! empty( $group ) ) {\n\n\t\t\t$group_id = $this->get_group_id( $group, false );\n\n\t\t\t// throw exception if no matching group found, this matches ActionScheduler_wpPostStore's behaviour.\n\t\t\tif ( empty( $group_id ) ) {\n\t\t\t\t/* translators: %s: group name */\n\t\t\t\tthrow new InvalidArgumentException( sprintf( __( 'The group \"%s\" does not exist.', 'action-scheduler' ), $group ) );\n\t\t\t}\n\n\t\t\t$where   .= ' AND group_id = %d';\n\t\t\t$params[] = $group_id;\n\t\t}\n\n\t\t/**\n\t\t * Sets the order-by clause used in the action claim query.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param string $order_by_sql\n\t\t */\n\t\t$order    = apply_filters( 'action_scheduler_claim_actions_order_by', 'ORDER BY attempts ASC, scheduled_date_gmt ASC, action_id ASC' );\n\t\t$params[] = $limit;\n\n\t\t$sql           = $wpdb->prepare( \"{$update} {$where} {$order} LIMIT %d\", $params ); // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders\n\t\t$rows_affected = $wpdb->query( $sql ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\tif ( false === $rows_affected ) {\n\t\t\tthrow new \\RuntimeException( __( 'Unable to claim actions. Database error.', 'action-scheduler' ) );\n\t\t}\n\n\t\treturn (int) $rows_affected;\n\t}\n\n\t/**\n\t * Get the number of active claims.\n\t *\n\t * @return int\n\t */\n\tpublic function get_claim_count() {\n\t\tglobal $wpdb;\n\n\t\t$sql = \"SELECT COUNT(DISTINCT claim_id) FROM {$wpdb->actionscheduler_actions} WHERE claim_id != 0 AND status IN ( %s, %s)\";\n\t\t$sql = $wpdb->prepare( $sql, array( self::STATUS_PENDING, self::STATUS_RUNNING ) ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\n\t\treturn (int) $wpdb->get_var( $sql ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t}\n\n\t/**\n\t * Return an action's claim ID, as stored in the claim_id column.\n\t *\n\t * @param string $action_id Action ID.\n\t * @return mixed\n\t */\n\tpublic function get_claim_id( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\t$sql = \"SELECT claim_id FROM {$wpdb->actionscheduler_actions} WHERE action_id=%d\";\n\t\t$sql = $wpdb->prepare( $sql, $action_id ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\n\t\treturn (int) $wpdb->get_var( $sql ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t}\n\n\t/**\n\t * Retrieve the action IDs of action in a claim.\n\t *\n\t * @param  int $claim_id Claim ID.\n\t * @return int[]\n\t */\n\tpublic function find_actions_by_claim_id( $claim_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\t$action_ids  = array();\n\t\t$before_date = isset( $this->claim_before_date ) ? $this->claim_before_date : as_get_datetime_object();\n\t\t$cut_off     = $before_date->format( 'Y-m-d H:i:s' );\n\n\t\t$sql = $wpdb->prepare(\n\t\t\t\"SELECT action_id, scheduled_date_gmt FROM {$wpdb->actionscheduler_actions} WHERE claim_id = %d\",\n\t\t\t$claim_id\n\t\t);\n\n\t\t// Verify that the scheduled date for each action is within the expected bounds (in some unusual\n\t\t// cases, we cannot depend on MySQL to honor all of the WHERE conditions we specify).\n\t\tforeach ( $wpdb->get_results( $sql ) as $claimed_action ) { // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t\tif ( $claimed_action->scheduled_date_gmt <= $cut_off ) {\n\t\t\t\t$action_ids[] = absint( $claimed_action->action_id );\n\t\t\t}\n\t\t}\n\n\t\treturn $action_ids;\n\t}\n\n\t/**\n\t * Release actions from a claim and delete the claim.\n\t *\n\t * @param ActionScheduler_ActionClaim $claim Claim object.\n\t */\n\tpublic function release_claim( ActionScheduler_ActionClaim $claim ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$wpdb->update( $wpdb->actionscheduler_actions, array( 'claim_id' => 0 ), array( 'claim_id' => $claim->get_id() ), array( '%d' ), array( '%d' ) );\n\t\t$wpdb->delete( $wpdb->actionscheduler_claims, array( 'claim_id' => $claim->get_id() ), array( '%d' ) );\n\t}\n\n\t/**\n\t * Remove the claim from an action.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return void\n\t */\n\tpublic function unclaim_action( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$wpdb->update(\n\t\t\t$wpdb->actionscheduler_actions,\n\t\t\tarray( 'claim_id' => 0 ),\n\t\t\tarray( 'action_id' => $action_id ),\n\t\t\tarray( '%s' ),\n\t\t\tarray( '%d' )\n\t\t);\n\t}\n\n\t/**\n\t * Mark an action as failed.\n\t *\n\t * @param int $action_id Action ID.\n\t * @throws \\InvalidArgumentException Throw an exception if action was not updated.\n\t */\n\tpublic function mark_failure( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$updated = $wpdb->update(\n\t\t\t$wpdb->actionscheduler_actions,\n\t\t\tarray( 'status' => self::STATUS_FAILED ),\n\t\t\tarray( 'action_id' => $action_id ),\n\t\t\tarray( '%s' ),\n\t\t\tarray( '%d' )\n\t\t);\n\t\tif ( empty( $updated ) ) {\n\t\t\tthrow new \\InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) ); //phpcs:ignore WordPress.WP.I18n.MissingTranslatorsComment\n\t\t}\n\t}\n\n\t/**\n\t * Add execution message to action log.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return void\n\t */\n\tpublic function log_execution( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\n\t\t$sql = \"UPDATE {$wpdb->actionscheduler_actions} SET attempts = attempts+1, status=%s, last_attempt_gmt = %s, last_attempt_local = %s WHERE action_id = %d\";\n\t\t$sql = $wpdb->prepare( $sql, self::STATUS_RUNNING, current_time( 'mysql', true ), current_time( 'mysql' ), $action_id ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t$wpdb->query( $sql ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t}\n\n\t/**\n\t * Mark an action as complete.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return void\n\t * @throws \\InvalidArgumentException Throw an exception if action was not updated.\n\t */\n\tpublic function mark_complete( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$updated = $wpdb->update(\n\t\t\t$wpdb->actionscheduler_actions,\n\t\t\tarray(\n\t\t\t\t'status'             => self::STATUS_COMPLETE,\n\t\t\t\t'last_attempt_gmt'   => current_time( 'mysql', true ),\n\t\t\t\t'last_attempt_local' => current_time( 'mysql' ),\n\t\t\t),\n\t\t\tarray( 'action_id' => $action_id ),\n\t\t\tarray( '%s' ),\n\t\t\tarray( '%d' )\n\t\t);\n\t\tif ( empty( $updated ) ) {\n\t\t\tthrow new \\InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) ); //phpcs:ignore WordPress.WP.I18n.MissingTranslatorsComment\n\t\t}\n\n\t\t/**\n\t\t * Fires after a scheduled action has been completed.\n\t\t *\n\t\t * @since 3.4.2\n\t\t *\n\t\t * @param int $action_id Action ID.\n\t\t */\n\t\tdo_action( 'action_scheduler_completed_action', $action_id );\n\t}\n\n\t/**\n\t * Get an action's status.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return string\n\t * @throws \\InvalidArgumentException Throw an exception if not status was found for action_id.\n\t * @throws \\RuntimeException Throw an exception if action status could not be retrieved.\n\t */\n\tpublic function get_status( $action_id ) {\n\t\t/** @var \\wpdb $wpdb */\n\t\tglobal $wpdb;\n\t\t$sql    = \"SELECT status FROM {$wpdb->actionscheduler_actions} WHERE action_id=%d\";\n\t\t$sql    = $wpdb->prepare( $sql, $action_id ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t$status = $wpdb->get_var( $sql ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\n\t\tif ( null === $status ) {\n\t\t\tthrow new \\InvalidArgumentException( __( 'Invalid action ID. No status found.', 'action-scheduler' ) );\n\t\t} elseif ( empty( $status ) ) {\n\t\t\tthrow new \\RuntimeException( __( 'Unknown status found for action.', 'action-scheduler' ) );\n\t\t} else {\n\t\t\treturn $status;\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_DBStore.php b/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_DBStore.php
--- a/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_DBStore.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_DBStore.php	(date 1675081217909)
@@ -36,48 +36,22 @@
 		$table_maker->register_tables();
 	}
 
-	/**
-	 * Save an action, checks if this is a unique action before actually saving.
-	 *
-	 * @param ActionScheduler_Action $action         Action object.
-	 * @param \DateTime              $scheduled_date Optional schedule date. Default null.
-	 *
-	 * @return int                  Action ID.
-	 * @throws RuntimeException     Throws exception when saving the action fails.
-	 */
-	public function save_unique_action( ActionScheduler_Action $action, \DateTime $scheduled_date = null ) {
-		return $this->save_action_to_db( $action, $scheduled_date, true );
-	}
-
-	/**
-	 * Save an action. Can save duplicate action as well, prefer using `save_unique_action` instead.
-	 *
-	 * @param ActionScheduler_Action $action Action object.
-	 * @param \DateTime              $scheduled_date Optional schedule date. Default null.
-	 *
-	 * @return int Action ID.
-	 * @throws RuntimeException     Throws exception when saving the action fails.
-	 */
-	public function save_action( ActionScheduler_Action $action, \DateTime $scheduled_date = null ) {
-		return $this->save_action_to_db( $action, $scheduled_date, false );
-	}
-
 	/**
 	 * Save an action.
 	 *
 	 * @param ActionScheduler_Action $action Action object.
-	 * @param ?DateTime              $date Optional schedule date. Default null.
-	 * @param bool                   $unique Whether the action should be unique.
+	 * @param DateTime              $date Optional schedule date. Default null.
 	 *
 	 * @return int Action ID.
 	 * @throws RuntimeException     Throws exception when saving the action fails.
 	 */
-	private function save_action_to_db( ActionScheduler_Action $action, DateTime $date = null, $unique = false ) {
-		global $wpdb;
-
+	public function save_action( ActionScheduler_Action $action, \DateTime $date = null ) {
 		try {
+
 			$this->validate_action( $action );
 
+			/** @var \wpdb $wpdb */
+			global $wpdb;
 			$data = array(
 				'hook'                 => $action->get_hook(),
 				'status'               => ( $action->is_finished() ? self::STATUS_COMPLETE : self::STATUS_PENDING ),
@@ -86,7 +60,6 @@
 				'schedule'             => serialize( $action->get_schedule() ), // phpcs:ignore WordPress.PHP.DiscouragedPHPFunctions.serialize_serialize
 				'group_id'             => $this->get_group_id( $action->get_group() ),
 			);
-
 			$args = wp_json_encode( $action->get_args() );
 			if ( strlen( $args ) <= static::$max_index_length ) {
 				$data['args'] = $args;
@@ -95,18 +68,13 @@
 				$data['extended_args'] = $args;
 			}
 
-			$insert_sql = $this->build_insert_sql( $data, $unique );
-
-			// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- $insert_sql should be already prepared.
-			$wpdb->query( $insert_sql );
+			$table_name = ! empty( $wpdb->actionscheduler_actions ) ? $wpdb->actionscheduler_actions : $wpdb->prefix . 'actionscheduler_actions';
+			$wpdb->insert( $table_name, $data );
 			$action_id = $wpdb->insert_id;
 
 			if ( is_wp_error( $action_id ) ) {
 				throw new \RuntimeException( $action_id->get_error_message() );
 			} elseif ( empty( $action_id ) ) {
-				if ( $unique ) {
-					return 0;
-				}
 				throw new \RuntimeException( $wpdb->last_error ? $wpdb->last_error : __( 'Database error.', 'action-scheduler' ) );
 			}
 
@@ -119,103 +87,6 @@
 		}
 	}
 
-	/**
-	 * Helper function to build insert query.
-	 *
-	 * @param array $data Row data for action.
-	 * @param bool  $unique Whether the action should be unique.
-	 *
-	 * @return string Insert query.
-	 */
-	private function build_insert_sql( array $data, $unique ) {
-		global $wpdb;
-		$columns      = array_keys( $data );
-		$values       = array_values( $data );
-		$placeholders = array_map( array( $this, 'get_placeholder_for_column' ), $columns );
-
-		$table_name = ! empty( $wpdb->actionscheduler_actions ) ? $wpdb->actionscheduler_actions : $wpdb->prefix . 'actionscheduler_actions';
-
-		$column_sql      = '`' . implode( '`, `', $columns ) . '`';
-		$placeholder_sql = implode( ', ', $placeholders );
-		$where_clause    = $this->build_where_clause_for_insert( $data, $table_name, $unique );
-		// phpcs:disable WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- $column_sql and $where_clause are already prepared. $placeholder_sql is hardcoded.
-		$insert_query    = $wpdb->prepare(
-			"
-INSERT INTO $table_name ( $column_sql )
-SELECT $placeholder_sql FROM DUAL
-WHERE ( $where_clause ) IS NULL",
-			$values
-		);
-		// phpcs:enable
-
-		return $insert_query;
-	}
-
-	/**
-	 * Helper method to build where clause for action insert statement.
-	 *
-	 * @param array  $data Row data for action.
-	 * @param string $table_name Action table name.
-	 * @param bool   $unique Where action should be unique.
-	 *
-	 * @return string Where clause to be used with insert.
-	 */
-	private function build_where_clause_for_insert( $data, $table_name, $unique ) {
-		global $wpdb;
-
-		if ( ! $unique ) {
-			return 'SELECT NULL FROM DUAL';
-		}
-
-		$pending_statuses            = array(
-			ActionScheduler_Store::STATUS_PENDING,
-			ActionScheduler_Store::STATUS_RUNNING,
-		);
-		$pending_status_placeholders = implode( ', ', array_fill( 0, count( $pending_statuses ), '%s' ) );
-		// phpcs:disable WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.PreparedSQL.InterpolatedNotPrepared -- $pending_status_placeholders is hardcoded.
-		$where_clause = $wpdb->prepare(
-			"
-SELECT action_id FROM $table_name
-WHERE status IN ( $pending_status_placeholders )
-AND hook = %s
-AND `group_id` = %d
-",
-			array_merge(
-				$pending_statuses,
-				array(
-					$data['hook'],
-					$data['group_id'],
-				)
-			)
-		);
-		// phpcs:enable
-
-		return "$where_clause" . ' LIMIT 1';
-	}
-
-	/**
-	 * Helper method to get $wpdb->prepare placeholder for a given column name.
-	 *
-	 * @param string $column_name Name of column in actions table.
-	 *
-	 * @return string Placeholder to use for given column.
-	 */
-	private function get_placeholder_for_column( $column_name ) {
-		$string_columns = array(
-			'hook',
-			'status',
-			'scheduled_date_gmt',
-			'scheduled_date_local',
-			'args',
-			'schedule',
-			'last_attempt_gmt',
-			'last_attempt_local',
-			'extended_args',
-		);
-
-		return in_array( $column_name, $string_columns ) ? '%s' : '%d';
-	}
-
 	/**
 	 * Generate a hash from json_encoded $args using MD5 as this isn't for security.
 	 *
@@ -361,7 +232,7 @@
 	/**
 	 * Returns the SQL statement to query (or count) actions.
 	 *
-	 * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.
+	 * @since x.x.x $query['status'] accepts array of statuses instead of a single status.
 	 *
 	 * @param array  $query Filtering options.
 	 * @param string $select_or_count  Whether the SQL should select and return the IDs or just the row count.
@@ -513,7 +384,7 @@
 	/**
 	 * Query for action count or list of action IDs.
 	 *
-	 * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.
+	 * @since x.x.x $query['status'] accepts array of statuses instead of a single status.
 	 *
 	 * @see ActionScheduler_Store::query_actions for $query arg usage.
 	 *
@@ -799,7 +670,7 @@
 		/**
 		 * Sets the order-by clause used in the action claim query.
 		 *
-		 * @since 3.4.0
+		 * @since x.x.x
 		 *
 		 * @param string $order_by_sql
 		 */
Index: inc/Dependencies/ActionScheduler/classes/schema/ActionScheduler_LoggerSchema.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_LoggerSchema\n *\n * @codeCoverageIgnore\n *\n * Creates a custom table for storing action logs\n */\nclass ActionScheduler_LoggerSchema extends ActionScheduler_Abstract_Schema {\n\tconst LOG_TABLE = 'actionscheduler_logs';\n\n\t/**\n\t * @var int Increment this value to trigger a schema update.\n\t */\n\tprotected $schema_version = 3;\n\n\tpublic function __construct() {\n\t\t$this->tables = [\n\t\t\tself::LOG_TABLE,\n\t\t];\n\t}\n\n\t/**\n\t * Performs additional setup work required to support this schema.\n\t */\n\tpublic function init() {\n\t\tadd_action( 'action_scheduler_before_schema_update', array( $this, 'update_schema_3_0' ), 10, 2 );\n\t}\n\n\tprotected function get_table_definition( $table ) {\n\t\tglobal $wpdb;\n\t\t$table_name       = $wpdb->$table;\n\t\t$charset_collate  = $wpdb->get_charset_collate();\n\t\tswitch ( $table ) {\n\n\t\t\tcase self::LOG_TABLE:\n\n\t\t\t\t$default_date = ActionScheduler_StoreSchema::DEFAULT_DATE;\n\t\t\t\treturn \"CREATE TABLE $table_name (\n\t\t\t\t        log_id bigint(20) unsigned NOT NULL auto_increment,\n\t\t\t\t        action_id bigint(20) unsigned NOT NULL,\n\t\t\t\t        message text NOT NULL,\n\t\t\t\t        log_date_gmt datetime NULL default '{$default_date}',\n\t\t\t\t        log_date_local datetime NULL default '{$default_date}',\n\t\t\t\t        PRIMARY KEY  (log_id),\n\t\t\t\t        KEY action_id (action_id),\n\t\t\t\t        KEY log_date_gmt (log_date_gmt)\n\t\t\t\t        ) $charset_collate\";\n\n\t\t\tdefault:\n\t\t\t\treturn '';\n\t\t}\n\t}\n\n\t/**\n\t * Update the logs table schema, allowing datetime fields to be NULL.\n\t *\n\t * This is needed because the NOT NULL constraint causes a conflict with some versions of MySQL\n\t * configured with sql_mode=NO_ZERO_DATE, which can for instance lead to tables not being created.\n\t *\n\t * Most other schema updates happen via ActionScheduler_Abstract_Schema::update_table(), however\n\t * that method relies on dbDelta() and this change is not possible when using that function.\n\t *\n\t * @param string $table Name of table being updated.\n\t * @param string $db_version The existing schema version of the table.\n\t */\n\tpublic function update_schema_3_0( $table, $db_version ) {\n\t\tglobal $wpdb;\n\n\t\tif ( 'actionscheduler_logs' !== $table || version_compare( $db_version, '3', '>=' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// phpcs:disable WordPress.DB.PreparedSQL.InterpolatedNotPrepared\n\t\t$table_name   = $wpdb->prefix . 'actionscheduler_logs';\n\t\t$table_list   = $wpdb->get_col( \"SHOW TABLES LIKE '{$table_name}'\" );\n\t\t$default_date = ActionScheduler_StoreSchema::DEFAULT_DATE;\n\n\t\tif ( ! empty( $table_list ) ) {\n\t\t\t$query = \"\n\t\t\t\tALTER TABLE {$table_name}\n\t\t\t\tMODIFY COLUMN log_date_gmt datetime NULL default '{$default_date}',\n\t\t\t\tMODIFY COLUMN log_date_local datetime NULL default '{$default_date}'\n\t\t\t\";\n\t\t\t$wpdb->query( $query ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t}\n\t\t// phpcs:enable WordPress.DB.PreparedSQL.InterpolatedNotPrepared\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/schema/ActionScheduler_LoggerSchema.php b/inc/Dependencies/ActionScheduler/classes/schema/ActionScheduler_LoggerSchema.php
--- a/inc/Dependencies/ActionScheduler/classes/schema/ActionScheduler_LoggerSchema.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/schema/ActionScheduler_LoggerSchema.php	(date 1675081217913)
@@ -37,12 +37,12 @@
 			case self::LOG_TABLE:
 
 				$default_date = ActionScheduler_StoreSchema::DEFAULT_DATE;
-				return "CREATE TABLE $table_name (
+				return "CREATE TABLE {$table_name} (
 				        log_id bigint(20) unsigned NOT NULL auto_increment,
 				        action_id bigint(20) unsigned NOT NULL,
 				        message text NOT NULL,
-				        log_date_gmt datetime NULL default '{$default_date}',
-				        log_date_local datetime NULL default '{$default_date}',
+				        log_date_gmt datetime NULL default '${default_date}',
+				        log_date_local datetime NULL default '${default_date}',
 				        PRIMARY KEY  (log_id),
 				        KEY action_id (action_id),
 				        KEY log_date_gmt (log_date_gmt)
@@ -74,14 +74,14 @@
 
 		// phpcs:disable WordPress.DB.PreparedSQL.InterpolatedNotPrepared
 		$table_name   = $wpdb->prefix . 'actionscheduler_logs';
-		$table_list   = $wpdb->get_col( "SHOW TABLES LIKE '{$table_name}'" );
+		$table_list   = $wpdb->get_col( "SHOW TABLES LIKE '${table_name}'" );
 		$default_date = ActionScheduler_StoreSchema::DEFAULT_DATE;
 
 		if ( ! empty( $table_list ) ) {
 			$query = "
-				ALTER TABLE {$table_name}
-				MODIFY COLUMN log_date_gmt datetime NULL default '{$default_date}',
-				MODIFY COLUMN log_date_local datetime NULL default '{$default_date}'
+				ALTER TABLE ${table_name}
+				MODIFY COLUMN log_date_gmt datetime NULL default '${default_date}',
+				MODIFY COLUMN log_date_local datetime NULL default '${default_date}'
 			";
 			$wpdb->query( $query ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
 		}
Index: inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_ListTable.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\nif ( ! class_exists( 'WP_List_Table' ) ) {\n\trequire_once ABSPATH . 'wp-admin/includes/class-wp-list-table.php';\n}\n\n/**\n * Action Scheduler Abstract List Table class\n *\n * This abstract class enhances WP_List_Table making it ready to use.\n *\n * By extending this class we can focus on describing how our table looks like,\n * which columns needs to be shown, filter, ordered by and more and forget about the details.\n *\n * This class supports:\n *  - Bulk actions\n *  - Search\n *  - Sortable columns\n *  - Automatic translations of the columns\n *\n * @codeCoverageIgnore\n * @since  2.0.0\n */\nabstract class ActionScheduler_Abstract_ListTable extends WP_List_Table {\n\n\t/**\n\t * The table name\n\t *\n\t * @var string\n\t */\n\tprotected $table_name;\n\n\t/**\n\t * Package name, used to get options from WP_List_Table::get_items_per_page.\n\t *\n\t * @var string\n\t */\n\tprotected $package;\n\n\t/**\n\t * How many items do we render per page?\n\t *\n\t * @var int\n\t */\n\tprotected $items_per_page = 10;\n\n\t/**\n\t * Enables search in this table listing. If this array\n\t * is empty it means the listing is not searchable.\n\t *\n\t * @var array\n\t */\n\tprotected $search_by = array();\n\n\t/**\n\t * Columns to show in the table listing. It is a key => value pair. The\n\t * key must much the table column name and the value is the label, which is\n\t * automatically translated.\n\t *\n\t * @var array\n\t */\n\tprotected $columns = array();\n\n\t/**\n\t * Defines the row-actions. It expects an array where the key\n\t * is the column name and the value is an array of actions.\n\t *\n\t * The array of actions are key => value, where key is the method name\n\t * (with the prefix row_action_<key>) and the value is the label\n\t * and title.\n\t *\n\t * @var array\n\t */\n\tprotected $row_actions = array();\n\n\t/**\n\t * The Primary key of our table\n\t *\n\t * @var string\n\t */\n\tprotected $ID = 'ID';\n\n\t/**\n\t * Enables sorting, it expects an array\n\t * of columns (the column names are the values)\n\t *\n\t * @var array\n\t */\n\tprotected $sort_by = array();\n\n\t/**\n\t * The default sort order\n\t *\n\t * @var string\n\t */\n\tprotected $filter_by = array();\n\n\t/**\n\t * The status name => count combinations for this table's items. Used to display status filters.\n\t *\n\t * @var array\n\t */\n\tprotected $status_counts = array();\n\n\t/**\n\t * Notices to display when loading the table. Array of arrays of form array( 'class' => {updated|error}, 'message' => 'This is the notice text display.' ).\n\t *\n\t * @var array\n\t */\n\tprotected $admin_notices = array();\n\n\t/**\n\t * Localised string displayed in the <h1> element above the able.\n\t *\n\t * @var string\n\t */\n\tprotected $table_header;\n\n\t/**\n\t * Enables bulk actions. It must be an array where the key is the action name\n\t * and the value is the label (which is translated automatically). It is important\n\t * to notice that it will check that the method exists (`bulk_$name`) and will throw\n\t * an exception if it does not exists.\n\t *\n\t * This class will automatically check if the current request has a bulk action, will do the\n\t * validations and afterwards will execute the bulk method, with two arguments. The first argument\n\t * is the array with primary keys, the second argument is a string with a list of the primary keys,\n\t * escaped and ready to use (with `IN`).\n\t *\n\t * @var array\n\t */\n\tprotected $bulk_actions = array();\n\n\t/**\n\t * Makes translation easier, it basically just wraps\n\t * `_x` with some default (the package name).\n\t *\n\t * @param string $text The new text to translate.\n\t * @param string $context The context of the text.\n\t * @return string|void The translated text.\n\t *\n\t * @deprecated 3.0.0 Use `_x()` instead.\n\t */\n\tprotected function translate( $text, $context = '' ) {\n\t\treturn $text;\n\t}\n\n\t/**\n\t * Reads `$this->bulk_actions` and returns an array that WP_List_Table understands. It\n\t * also validates that the bulk method handler exists. It throws an exception because\n\t * this is a library meant for developers and missing a bulk method is a development-time error.\n\t *\n\t * @return array\n\t *\n\t * @throws RuntimeException Throws RuntimeException when the bulk action does not have a callback method.\n\t */\n\tprotected function get_bulk_actions() {\n\t\t$actions = array();\n\n\t\tforeach ( $this->bulk_actions as $action => $label ) {\n\t\t\tif ( ! is_callable( array( $this, 'bulk_' . $action ) ) ) {\n\t\t\t\tthrow new RuntimeException( \"The bulk action $action does not have a callback method\" );\n\t\t\t}\n\n\t\t\t$actions[ $action ] = $label;\n\t\t}\n\n\t\treturn $actions;\n\t}\n\n\t/**\n\t * Checks if the current request has a bulk action. If that is the case it will validate and will\n\t * execute the bulk method handler. Regardless if the action is valid or not it will redirect to\n\t * the previous page removing the current arguments that makes this request a bulk action.\n\t */\n\tprotected function process_bulk_action() {\n\t\tglobal $wpdb;\n\t\t// Detect when a bulk action is being triggered.\n\t\t$action = $this->current_action();\n\t\tif ( ! $action ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcheck_admin_referer( 'bulk-' . $this->_args['plural'] );\n\n\t\t$method = 'bulk_' . $action;\n\t\tif ( array_key_exists( $action, $this->bulk_actions ) && is_callable( array( $this, $method ) ) && ! empty( $_GET['ID'] ) && is_array( $_GET['ID'] ) ) {\n\t\t\t$ids_sql = '(' . implode( ',', array_fill( 0, count( $_GET['ID'] ), '%s' ) ) . ')';\n\t\t\t$id      = array_map( 'absint', $_GET['ID'] );\n\t\t\t$this->$method( $id, $wpdb->prepare( $ids_sql, $id ) ); //phpcs:ignore WordPress.DB.PreparedSQL\n\t\t}\n\n\t\tif ( isset( $_SERVER['REQUEST_URI'] ) ) {\n\t\t\twp_safe_redirect(\n\t\t\t\tremove_query_arg(\n\t\t\t\t\tarray( '_wp_http_referer', '_wpnonce', 'ID', 'action', 'action2' ),\n\t\t\t\t\tesc_url_raw( wp_unslash( $_SERVER['REQUEST_URI'] ) )\n\t\t\t\t)\n\t\t\t);\n\t\t\texit;\n\t\t}\n\t}\n\n\t/**\n\t * Default code for deleting entries.\n\t * validated already by process_bulk_action()\n\t *\n\t * @param array  $ids ids of the items to delete.\n\t * @param string $ids_sql the sql for the ids.\n\t * @return void\n\t */\n\tprotected function bulk_delete( array $ids, $ids_sql ) {\n\t\t$store = ActionScheduler::store();\n\t\tforeach ( $ids as $action_id ) {\n\t\t\t$store->delete( $action_id );\n\t\t}\n\t}\n\n\t/**\n\t * Prepares the _column_headers property which is used by WP_Table_List at rendering.\n\t * It merges the columns and the sortable columns.\n\t */\n\tprotected function prepare_column_headers() {\n\t\t$this->_column_headers = array(\n\t\t\t$this->get_columns(),\n\t\t\tget_hidden_columns( $this->screen ),\n\t\t\t$this->get_sortable_columns(),\n\t\t);\n\t}\n\n\t/**\n\t * Reads $this->sort_by and returns the columns name in a format that WP_Table_List\n\t * expects\n\t */\n\tpublic function get_sortable_columns() {\n\t\t$sort_by = array();\n\t\tforeach ( $this->sort_by as $column ) {\n\t\t\t$sort_by[ $column ] = array( $column, true );\n\t\t}\n\t\treturn $sort_by;\n\t}\n\n\t/**\n\t * Returns the columns names for rendering. It adds a checkbox for selecting everything\n\t * as the first column\n\t */\n\tpublic function get_columns() {\n\t\t$columns = array_merge(\n\t\t\tarray( 'cb' => '<input type=\"checkbox\" />' ),\n\t\t\t$this->columns\n\t\t);\n\n\t\treturn $columns;\n\t}\n\n\t/**\n\t * Get prepared LIMIT clause for items query\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @return string Prepared LIMIT clause for items query.\n\t */\n\tprotected function get_items_query_limit() {\n\t\tglobal $wpdb;\n\n\t\t$per_page = $this->get_items_per_page( $this->get_per_page_option_name(), $this->items_per_page );\n\t\treturn $wpdb->prepare( 'LIMIT %d', $per_page );\n\t}\n\n\t/**\n\t * Returns the number of items to offset/skip for this current view.\n\t *\n\t * @return int\n\t */\n\tprotected function get_items_offset() {\n\t\t$per_page     = $this->get_items_per_page( $this->get_per_page_option_name(), $this->items_per_page );\n\t\t$current_page = $this->get_pagenum();\n\t\tif ( 1 < $current_page ) {\n\t\t\t$offset = $per_page * ( $current_page - 1 );\n\t\t} else {\n\t\t\t$offset = 0;\n\t\t}\n\n\t\treturn $offset;\n\t}\n\n\t/**\n\t * Get prepared OFFSET clause for items query\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @return string Prepared OFFSET clause for items query.\n\t */\n\tprotected function get_items_query_offset() {\n\t\tglobal $wpdb;\n\n\t\treturn $wpdb->prepare( 'OFFSET %d', $this->get_items_offset() );\n\t}\n\n\t/**\n\t * Prepares the ORDER BY sql statement. It uses `$this->sort_by` to know which\n\t * columns are sortable. This requests validates the orderby $_GET parameter is a valid\n\t * column and sortable. It will also use order (ASC|DESC) using DESC by default.\n\t */\n\tprotected function get_items_query_order() {\n\t\tif ( empty( $this->sort_by ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$orderby = esc_sql( $this->get_request_orderby() );\n\t\t$order   = esc_sql( $this->get_request_order() );\n\n\t\treturn \"ORDER BY {$orderby} {$order}\";\n\t}\n\n\t/**\n\t * Return the sortable column specified for this request to order the results by, if any.\n\t *\n\t * @return string\n\t */\n\tprotected function get_request_orderby() {\n\n\t\t$valid_sortable_columns = array_values( $this->sort_by );\n\n\t\tif ( ! empty( $_GET['orderby'] ) && in_array( $_GET['orderby'], $valid_sortable_columns, true ) ) { //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\t$orderby = sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t} else {\n\t\t\t$orderby = $valid_sortable_columns[0];\n\t\t}\n\n\t\treturn $orderby;\n\t}\n\n\t/**\n\t * Return the sortable column order specified for this request.\n\t *\n\t * @return string\n\t */\n\tprotected function get_request_order() {\n\n\t\tif ( ! empty( $_GET['order'] ) && 'desc' === strtolower( sanitize_text_field( wp_unslash( $_GET['order'] ) ) ) ) { //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\t$order = 'DESC';\n\t\t} else {\n\t\t\t$order = 'ASC';\n\t\t}\n\n\t\treturn $order;\n\t}\n\n\t/**\n\t * Return the status filter for this request, if any.\n\t *\n\t * @return string\n\t */\n\tprotected function get_request_status() {\n\t\t$status = ( ! empty( $_GET['status'] ) ) ? sanitize_text_field( wp_unslash( $_GET['status'] ) ) : ''; //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Return the search filter for this request, if any.\n\t *\n\t * @return string\n\t */\n\tprotected function get_request_search_query() {\n\t\t$search_query = ( ! empty( $_GET['s'] ) ) ? sanitize_text_field( wp_unslash( $_GET['s'] ) ) : ''; //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\treturn $search_query;\n\t}\n\n\t/**\n\t * Process and return the columns name. This is meant for using with SQL, this means it\n\t * always includes the primary key.\n\t *\n\t * @return array\n\t */\n\tprotected function get_table_columns() {\n\t\t$columns = array_keys( $this->columns );\n\t\tif ( ! in_array( $this->ID, $columns, true ) ) {\n\t\t\t$columns[] = $this->ID;\n\t\t}\n\n\t\treturn $columns;\n\t}\n\n\t/**\n\t * Check if the current request is doing a \"full text\" search. If that is the case\n\t * prepares the SQL to search texts using LIKE.\n\t *\n\t * If the current request does not have any search or if this list table does not support\n\t * that feature it will return an empty string.\n\t *\n\t * @return string\n\t */\n\tprotected function get_items_query_search() {\n\t\tglobal $wpdb;\n\n\t\tif ( empty( $_GET['s'] ) || empty( $this->search_by ) ) { //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\treturn '';\n\t\t}\n\n\t\t$search_string = sanitize_text_field( wp_unslash( $_GET['s'] ) ); //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\n\t\t$filter = array();\n\t\tforeach ( $this->search_by as $column ) {\n\t\t\t$wild     = '%';\n\t\t\t$sql_like = $wild . $wpdb->esc_like( $search_string ) . $wild;\n\t\t\t$filter[] = $wpdb->prepare( '`' . $column . '` LIKE %s', $sql_like ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended, WordPress.DB.PreparedSQL.NotPrepared\n\t\t}\n\t\treturn implode( ' OR ', $filter );\n\t}\n\n\t/**\n\t * Prepares the SQL to filter rows by the options defined at `$this->filter_by`. Before trusting\n\t * any data sent by the user it validates that it is a valid option.\n\t */\n\tprotected function get_items_query_filters() {\n\t\tglobal $wpdb;\n\n\t\tif ( ! $this->filter_by || empty( $_GET['filter_by'] ) || ! is_array( $_GET['filter_by'] ) ) { //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\treturn '';\n\t\t}\n\n\t\t$filter = array();\n\n\t\tforeach ( $this->filter_by as $column => $options ) {\n\t\t\tif ( empty( $_GET['filter_by'][ $column ] ) || empty( $options[ $_GET['filter_by'][ $column ] ] ) ) { //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$filter[] = $wpdb->prepare( \"`$column` = %s\", sanitize_text_field( wp_unslash( $_GET['filter_by'][ $column ] ) ) ); //phpcs:ignore WordPress.Security.NonceVerification.Recommended, WordPress.DB.PreparedSQL.InterpolatedNotPrepared\n\t\t}\n\n\t\treturn implode( ' AND ', $filter );\n\n\t}\n\n\t/**\n\t * Prepares the data to feed WP_Table_List.\n\t *\n\t * This has the core for selecting, sorting and filting data. To keep the code simple\n\t * its logic is split among many methods (get_items_query_*).\n\t *\n\t * Beside populating the items this function will also count all the records that matches\n\t * the filtering criteria and will do fill the pagination variables.\n\t */\n\tpublic function prepare_items() {\n\t\tglobal $wpdb;\n\n\t\t$this->process_bulk_action();\n\n\t\t$this->process_row_actions();\n\n\t\tif ( ! empty( $_REQUEST['_wp_http_referer'] && ! empty( $_SERVER['REQUEST_URI'] ) ) ) { //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\t// _wp_http_referer is used only on bulk actions, we remove it to keep the $_GET shorter\n\t\t\twp_safe_redirect( remove_query_arg( array( '_wp_http_referer', '_wpnonce' ), esc_url_raw( wp_unslash( $_SERVER['REQUEST_URI'] ) ) ) );\n\t\t\texit;\n\t\t}\n\n\t\t$this->prepare_column_headers();\n\n\t\t$limit   = $this->get_items_query_limit();\n\t\t$offset  = $this->get_items_query_offset();\n\t\t$order   = $this->get_items_query_order();\n\t\t$where   = array_filter(\n\t\t\tarray(\n\t\t\t\t$this->get_items_query_search(),\n\t\t\t\t$this->get_items_query_filters(),\n\t\t\t)\n\t\t);\n\t\t$columns = '`' . implode( '`, `', $this->get_table_columns() ) . '`';\n\n\t\tif ( ! empty( $where ) ) {\n\t\t\t$where = 'WHERE (' . implode( ') AND (', $where ) . ')';\n\t\t} else {\n\t\t\t$where = '';\n\t\t}\n\n\t\t$sql = \"SELECT $columns FROM {$this->table_name} {$where} {$order} {$limit} {$offset}\";\n\n\t\t$this->set_items( $wpdb->get_results( $sql, ARRAY_A ) ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\n\t\t$query_count = \"SELECT COUNT({$this->ID}) FROM {$this->table_name} {$where}\";\n\t\t$total_items = $wpdb->get_var( $query_count ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t\t$per_page    = $this->get_items_per_page( $this->get_per_page_option_name(), $this->items_per_page );\n\t\t$this->set_pagination_args(\n\t\t\tarray(\n\t\t\t\t'total_items' => $total_items,\n\t\t\t\t'per_page'    => $per_page,\n\t\t\t\t'total_pages' => ceil( $total_items / $per_page ),\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Display the table.\n\t *\n\t * @param string $which The name of the table.\n\t */\n\tpublic function extra_tablenav( $which ) {\n\t\tif ( ! $this->filter_by || 'top' !== $which ) {\n\t\t\treturn;\n\t\t}\n\n\t\techo '<div class=\"alignleft actions\">';\n\n\t\tforeach ( $this->filter_by as $id => $options ) {\n\t\t\t$default = ! empty( $_GET['filter_by'][ $id ] ) ? sanitize_text_field( wp_unslash( $_GET['filter_by'][ $id ] ) ) : ''; //phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\tif ( empty( $options[ $default ] ) ) {\n\t\t\t\t$default = '';\n\t\t\t}\n\n\t\t\techo '<select name=\"filter_by[' . esc_attr( $id ) . ']\" class=\"first\" id=\"filter-by-' . esc_attr( $id ) . '\">';\n\n\t\t\tforeach ( $options as $value => $label ) {\n\t\t\t\techo '<option value=\"' . esc_attr( $value ) . '\" ' . esc_html( $value === $default ? 'selected' : '' ) . '>'\n\t\t\t\t\t. esc_html( $label )\n\t\t\t\t. '</option>';\n\t\t\t}\n\n\t\t\techo '</select>';\n\t\t}\n\n\t\tsubmit_button( esc_html__( 'Filter', 'action-scheduler' ), '', 'filter_action', false, array( 'id' => 'post-query-submit' ) );\n\t\techo '</div>';\n\t}\n\n\t/**\n\t * Set the data for displaying. It will attempt to unserialize (There is a chance that some columns\n\t * are serialized). This can be override in child classes for futher data transformation.\n\t *\n\t * @param array $items Items array.\n\t */\n\tprotected function set_items( array $items ) {\n\t\t$this->items = array();\n\t\tforeach ( $items as $item ) {\n\t\t\t$this->items[ $item[ $this->ID ] ] = array_map( 'maybe_unserialize', $item );\n\t\t}\n\t}\n\n\t/**\n\t * Renders the checkbox for each row, this is the first column and it is named ID regardless\n\t * of how the primary key is named (to keep the code simpler). The bulk actions will do the proper\n\t * name transformation though using `$this->ID`.\n\t *\n\t * @param array $row The row to render.\n\t */\n\tpublic function column_cb( $row ) {\n\t\treturn '<input name=\"ID[]\" type=\"checkbox\" value=\"' . esc_attr( $row[ $this->ID ] ) . '\" />';\n\t}\n\n\t/**\n\t * Renders the row-actions.\n\t *\n\t * This method renders the action menu, it reads the definition from the $row_actions property,\n\t * and it checks that the row action method exists before rendering it.\n\t *\n\t * @param array  $row Row to be rendered.\n\t * @param string $column_name Column name.\n\t * @return string\n\t */\n\tprotected function maybe_render_actions( $row, $column_name ) {\n\t\tif ( empty( $this->row_actions[ $column_name ] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$row_id = $row[ $this->ID ];\n\n\t\t$actions      = '<div class=\"row-actions\">';\n\t\t$action_count = 0;\n\t\tforeach ( $this->row_actions[ $column_name ] as $action_key => $action ) {\n\n\t\t\t$action_count++;\n\n\t\t\tif ( ! method_exists( $this, 'row_action_' . $action_key ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$action_link = ! empty( $action['link'] ) ? $action['link'] : add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'row_action' => $action_key,\n\t\t\t\t\t'row_id'     => $row_id,\n\t\t\t\t\t'nonce'      => wp_create_nonce( $action_key . '::' . $row_id ),\n\t\t\t\t)\n\t\t\t);\n\t\t\t$span_class  = ! empty( $action['class'] ) ? $action['class'] : $action_key;\n\t\t\t$separator   = ( $action_count < count( $this->row_actions[ $column_name ] ) ) ? ' | ' : '';\n\n\t\t\t$actions .= sprintf( '<span class=\"%s\">', esc_attr( $span_class ) );\n\t\t\t$actions .= sprintf( '<a href=\"%1$s\" title=\"%2$s\">%3$s</a>', esc_url( $action_link ), esc_attr( $action['desc'] ), esc_html( $action['name'] ) );\n\t\t\t$actions .= sprintf( '%s</span>', $separator );\n\t\t}\n\t\t$actions .= '</div>';\n\t\treturn $actions;\n\t}\n\n\t/**\n\t * Process the bulk actions.\n\t *\n\t * @return void\n\t */\n\tprotected function process_row_actions() {\n\t\t$parameters = array( 'row_action', 'row_id', 'nonce' );\n\t\tforeach ( $parameters as $parameter ) {\n\t\t\tif ( empty( $_REQUEST[ $parameter ] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t$action = sanitize_text_field( wp_unslash( $_REQUEST['row_action'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended, WordPress.Security.ValidatedSanitizedInput.InputNotValidated\n\t\t$row_id = sanitize_text_field( wp_unslash( $_REQUEST['row_id'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended, WordPress.Security.ValidatedSanitizedInput.InputNotValidated\n\t\t$nonce  = sanitize_text_field( wp_unslash( $_REQUEST['nonce'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended, WordPress.Security.ValidatedSanitizedInput.InputNotValidated\n\t\t$method = 'row_action_' . $action; // phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\n\t\tif ( wp_verify_nonce( $nonce, $action . '::' . $row_id ) && method_exists( $this, $method ) ) {\n\t\t\t$this->$method( sanitize_text_field( wp_unslash( $row_id ) ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t}\n\n\t\tif ( isset( $_SERVER['REQUEST_URI'] ) ) {\n\t\t\twp_safe_redirect(\n\t\t\t\tremove_query_arg(\n\t\t\t\t\tarray( 'row_id', 'row_action', 'nonce' ),\n\t\t\t\t\tesc_url_raw( wp_unslash( $_SERVER['REQUEST_URI'] ) )\n\t\t\t\t)\n\t\t\t);\n\t\t\texit;\n\t\t}\n\t}\n\n\t/**\n\t * Default column formatting, it will escape everythig for security.\n\t *\n\t * @param array  $item The item array.\n\t * @param string $column_name Column name to display.\n\t *\n\t * @return string\n\t */\n\tpublic function column_default( $item, $column_name ) {\n\t\t$column_html  = esc_html( $item[ $column_name ] );\n\t\t$column_html .= $this->maybe_render_actions( $item, $column_name );\n\t\treturn $column_html;\n\t}\n\n\t/**\n\t * Display the table heading and search query, if any\n\t */\n\tprotected function display_header() {\n\t\techo '<h1 class=\"wp-heading-inline\">' . esc_attr( $this->table_header ) . '</h1>';\n\t\tif ( $this->get_request_search_query() ) {\n\t\t\t/* translators: %s: search query */\n\t\t\techo '<span class=\"subtitle\">' . esc_attr( sprintf( __( 'Search results for \"%s\"', 'action-scheduler' ), $this->get_request_search_query() ) ) . '</span>';\n\t\t}\n\t\techo '<hr class=\"wp-header-end\">';\n\t}\n\n\t/**\n\t * Display the table heading and search query, if any\n\t */\n\tprotected function display_admin_notices() {\n\t\tforeach ( $this->admin_notices as $notice ) {\n\t\t\techo '<div id=\"message\" class=\"' . esc_attr( $notice['class'] ) . '\">';\n\t\t\techo '\t<p>' . wp_kses_post( $notice['message'] ) . '</p>';\n\t\t\techo '</div>';\n\t\t}\n\t}\n\n\t/**\n\t * Prints the available statuses so the user can click to filter.\n\t */\n\tprotected function display_filter_by_status() {\n\n\t\t$status_list_items = array();\n\t\t$request_status    = $this->get_request_status();\n\n\t\t// Helper to set 'all' filter when not set on status counts passed in.\n\t\tif ( ! isset( $this->status_counts['all'] ) ) {\n\t\t\t$this->status_counts = array( 'all' => array_sum( $this->status_counts ) ) + $this->status_counts;\n\t\t}\n\n\t\tforeach ( $this->status_counts as $status_name => $count ) {\n\n\t\t\tif ( 0 === $count ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( $status_name === $request_status || ( empty( $request_status ) && 'all' === $status_name ) ) {\n\t\t\t\t$status_list_item = '<li class=\"%1$s\"><a href=\"%2$s\" class=\"current\">%3$s</a> (%4$d)</li>';\n\t\t\t} else {\n\t\t\t\t$status_list_item = '<li class=\"%1$s\"><a href=\"%2$s\">%3$s</a> (%4$d)</li>';\n\t\t\t}\n\n\t\t\t$status_filter_url   = ( 'all' === $status_name ) ? remove_query_arg( 'status' ) : add_query_arg( 'status', $status_name );\n\t\t\t$status_filter_url   = remove_query_arg( array( 'paged', 's' ), $status_filter_url );\n\t\t\t$status_list_items[] = sprintf( $status_list_item, esc_attr( $status_name ), esc_url( $status_filter_url ), esc_html( ucfirst( $status_name ) ), absint( $count ) );\n\t\t}\n\n\t\tif ( $status_list_items ) {\n\t\t\techo '<ul class=\"subsubsub\">';\n\t\t\techo implode( \" | \\n\", $status_list_items ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t\t\techo '</ul>';\n\t\t}\n\t}\n\n\t/**\n\t * Renders the table list, we override the original class to render the table inside a form\n\t * and to render any needed HTML (like the search box). By doing so the callee of a function can simple\n\t * forget about any extra HTML.\n\t */\n\tprotected function display_table() {\n\t\techo '<form id=\"' . esc_attr( $this->_args['plural'] ) . '-filter\" method=\"get\">';\n\t\tforeach ( $_GET as $key => $value ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\tif ( '_' === $key[0] || 'paged' === $key || 'ID' === $key ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\techo '<input type=\"hidden\" name=\"' . esc_attr( $key ) . '\" value=\"' . esc_attr( $value ) . '\" />';\n\t\t}\n\t\tif ( ! empty( $this->search_by ) ) {\n\t\t\techo $this->search_box( $this->get_search_box_button_text(), 'plugin' ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t\t}\n\t\tparent::display();\n\t\techo '</form>';\n\t}\n\n\t/**\n\t * Process any pending actions.\n\t */\n\tpublic function process_actions() {\n\t\t$this->process_bulk_action();\n\t\t$this->process_row_actions();\n\n\t\tif ( ! empty( $_REQUEST['_wp_http_referer'] ) && ! empty( $_SERVER['REQUEST_URI'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended\n\t\t\t// _wp_http_referer is used only on bulk actions, we remove it to keep the $_GET shorter\n\t\t\twp_safe_redirect( remove_query_arg( array( '_wp_http_referer', '_wpnonce' ), esc_url_raw( wp_unslash( $_SERVER['REQUEST_URI'] ) ) ) );\n\t\t\texit;\n\t\t}\n\t}\n\n\t/**\n\t * Render the list table page, including header, notices, status filters and table.\n\t */\n\tpublic function display_page() {\n\t\t$this->prepare_items();\n\n\t\techo '<div class=\"wrap\">';\n\t\t$this->display_header();\n\t\t$this->display_admin_notices();\n\t\t$this->display_filter_by_status();\n\t\t$this->display_table();\n\t\techo '</div>';\n\t}\n\n\t/**\n\t * Get the text to display in the search box on the list table.\n\t */\n\tprotected function get_search_box_placeholder() {\n\t\treturn esc_html__( 'Search', 'action-scheduler' );\n\t}\n\n\t/**\n\t * Gets the screen per_page option name.\n\t *\n\t * @return string\n\t */\n\tprotected function get_per_page_option_name() {\n\t\treturn $this->package . '_items_per_page';\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_ListTable.php b/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_ListTable.php
--- a/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_ListTable.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_ListTable.php	(date 1675081217917)
@@ -683,7 +683,7 @@
 			}
 
 			if ( $status_name === $request_status || ( empty( $request_status ) && 'all' === $status_name ) ) {
-				$status_list_item = '<li class="%1$s"><a href="%2$s" class="current">%3$s</a> (%4$d)</li>';
+				$status_list_item = '<li class="%1$s"><strong>%3$s</strong> (%4$d)</li>';
 			} else {
 				$status_list_item = '<li class="%1$s"><a href="%2$s">%3$s</a> (%4$d)</li>';
 			}
Index: inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_wpPostStore.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Class ActionScheduler_wpPostStore\n */\nclass ActionScheduler_wpPostStore extends ActionScheduler_Store {\n\tconst POST_TYPE         = 'scheduled-action';\n\tconst GROUP_TAXONOMY    = 'action-group';\n\tconst SCHEDULE_META_KEY = '_action_manager_schedule';\n\tconst DEPENDENCIES_MET  = 'as-post-store-dependencies-met';\n\n\t/**\n\t * Used to share information about the before_date property of claims internally.\n\t *\n\t * This is used in preference to passing the same information as a method param\n\t * for backwards-compatibility reasons.\n\t *\n\t * @var DateTime|null\n\t */\n\tprivate $claim_before_date = null;\n\n\t/**\n\t * Local Timezone.\n\t *\n\t * @var DateTimeZone\n\t */\n\tprotected $local_timezone = null;\n\n\t/**\n\t * Save action.\n\t *\n\t * @param ActionScheduler_Action $action Scheduled Action.\n\t * @param DateTime               $scheduled_date Scheduled Date.\n\t *\n\t * @throws RuntimeException Throws an exception if the action could not be saved.\n\t * @return int\n\t */\n\tpublic function save_action( ActionScheduler_Action $action, DateTime $scheduled_date = null ) {\n\t\ttry {\n\t\t\t$this->validate_action( $action );\n\t\t\t$post_array = $this->create_post_array( $action, $scheduled_date );\n\t\t\t$post_id    = $this->save_post_array( $post_array );\n\t\t\t$this->save_post_schedule( $post_id, $action->get_schedule() );\n\t\t\t$this->save_action_group( $post_id, $action->get_group() );\n\t\t\tdo_action( 'action_scheduler_stored_action', $post_id );\n\t\t\treturn $post_id;\n\t\t} catch ( Exception $e ) {\n\t\t\t/* translators: %s: action error message */\n\t\t\tthrow new RuntimeException( sprintf( __( 'Error saving action: %s', 'action-scheduler' ), $e->getMessage() ), 0 );\n\t\t}\n\t}\n\n\t/**\n\t * Create post array.\n\t *\n\t * @param ActionScheduler_Action $action Scheduled Action.\n\t * @param DateTime               $scheduled_date Scheduled Date.\n\t *\n\t * @return array Returns an array of post data.\n\t */\n\tprotected function create_post_array( ActionScheduler_Action $action, DateTime $scheduled_date = null ) {\n\t\t$post = array(\n\t\t\t'post_type'     => self::POST_TYPE,\n\t\t\t'post_title'    => $action->get_hook(),\n\t\t\t'post_content'  => wp_json_encode( $action->get_args() ),\n\t\t\t'post_status'   => ( $action->is_finished() ? 'publish' : 'pending' ),\n\t\t\t'post_date_gmt' => $this->get_scheduled_date_string( $action, $scheduled_date ),\n\t\t\t'post_date'     => $this->get_scheduled_date_string_local( $action, $scheduled_date ),\n\t\t);\n\t\treturn $post;\n\t}\n\n\t/**\n\t * Save post array.\n\t *\n\t * @param array $post_array Post array.\n\t * @return int Returns the post ID.\n\t * @throws RuntimeException Throws an exception if the action could not be saved.\n\t */\n\tprotected function save_post_array( $post_array ) {\n\t\tadd_filter( 'wp_insert_post_data', array( $this, 'filter_insert_post_data' ), 10, 1 );\n\t\tadd_filter( 'pre_wp_unique_post_slug', array( $this, 'set_unique_post_slug' ), 10, 5 );\n\n\t\t$has_kses = false !== has_filter( 'content_save_pre', 'wp_filter_post_kses' );\n\n\t\tif ( $has_kses ) {\n\t\t\t// Prevent KSES from corrupting JSON in post_content.\n\t\t\tkses_remove_filters();\n\t\t}\n\n\t\t$post_id = wp_insert_post( $post_array );\n\n\t\tif ( $has_kses ) {\n\t\t\tkses_init_filters();\n\t\t}\n\n\t\tremove_filter( 'wp_insert_post_data', array( $this, 'filter_insert_post_data' ), 10 );\n\t\tremove_filter( 'pre_wp_unique_post_slug', array( $this, 'set_unique_post_slug' ), 10 );\n\n\t\tif ( is_wp_error( $post_id ) || empty( $post_id ) ) {\n\t\t\tthrow new RuntimeException( __( 'Unable to save action.', 'action-scheduler' ) );\n\t\t}\n\t\treturn $post_id;\n\t}\n\n\t/**\n\t * Filter insert post data.\n\t *\n\t * @param array $postdata Post data to filter.\n\t *\n\t * @return array\n\t */\n\tpublic function filter_insert_post_data( $postdata ) {\n\t\tif ( self::POST_TYPE === $postdata['post_type'] ) {\n\t\t\t$postdata['post_author'] = 0;\n\t\t\tif ( 'future' === $postdata['post_status'] ) {\n\t\t\t\t$postdata['post_status'] = 'publish';\n\t\t\t}\n\t\t}\n\t\treturn $postdata;\n\t}\n\n\t/**\n\t * Create a (probably unique) post name for scheduled actions in a more performant manner than wp_unique_post_slug().\n\t *\n\t * When an action's post status is transitioned to something other than 'draft', 'pending' or 'auto-draft, like 'publish'\n\t * or 'failed' or 'trash', WordPress will find a unique slug (stored in post_name column) using the wp_unique_post_slug()\n\t * function. This is done to ensure URL uniqueness. The approach taken by wp_unique_post_slug() is to iterate over existing\n\t * post_name values that match, and append a number 1 greater than the largest. This makes sense when manually creating a\n\t * post from the Edit Post screen. It becomes a bottleneck when automatically processing thousands of actions, with a\n\t * database containing thousands of related post_name values.\n\t *\n\t * WordPress 5.1 introduces the 'pre_wp_unique_post_slug' filter for plugins to address this issue.\n\t *\n\t * We can short-circuit WordPress's wp_unique_post_slug() approach using the 'pre_wp_unique_post_slug' filter. This\n\t * method is available to be used as a callback on that filter. It provides a more scalable approach to generating a\n\t * post_name/slug that is probably unique. Because Action Scheduler never actually uses the post_name field, or an\n\t * action's slug, being probably unique is good enough.\n\t *\n\t * For more backstory on this issue, see:\n\t * - https://github.com/woocommerce/action-scheduler/issues/44 and\n\t * - https://core.trac.wordpress.org/ticket/21112\n\t *\n\t * @param string $override_slug Short-circuit return value.\n\t * @param string $slug          The desired slug (post_name).\n\t * @param int    $post_ID       Post ID.\n\t * @param string $post_status   The post status.\n\t * @param string $post_type     Post type.\n\t * @return string\n\t */\n\tpublic function set_unique_post_slug( $override_slug, $slug, $post_ID, $post_status, $post_type ) {\n\t\tif ( self::POST_TYPE === $post_type ) {\n\t\t\t$override_slug = uniqid( self::POST_TYPE . '-', true ) . '-' . wp_generate_password( 32, false );\n\t\t}\n\t\treturn $override_slug;\n\t}\n\n\t/**\n\t * Save post schedule.\n\t *\n\t * @param int    $post_id  Post ID of the scheduled action.\n\t * @param string $schedule Schedule to save.\n\t *\n\t * @return void\n\t */\n\tprotected function save_post_schedule( $post_id, $schedule ) {\n\t\tupdate_post_meta( $post_id, self::SCHEDULE_META_KEY, $schedule );\n\t}\n\n\t/**\n\t * Save action group.\n\t *\n\t * @param int    $post_id Post ID.\n\t * @param string $group   Group to save.\n\t * @return void\n\t */\n\tprotected function save_action_group( $post_id, $group ) {\n\t\tif ( empty( $group ) ) {\n\t\t\twp_set_object_terms( $post_id, array(), self::GROUP_TAXONOMY, false );\n\t\t} else {\n\t\t\twp_set_object_terms( $post_id, array( $group ), self::GROUP_TAXONOMY, false );\n\t\t}\n\t}\n\n\t/**\n\t * Fetch actions.\n\t *\n\t * @param int $action_id Action ID.\n\t * @return object\n\t */\n\tpublic function fetch_action( $action_id ) {\n\t\t$post = $this->get_post( $action_id );\n\t\tif ( empty( $post ) || self::POST_TYPE !== $post->post_type ) {\n\t\t\treturn $this->get_null_action();\n\t\t}\n\n\t\ttry {\n\t\t\t$action = $this->make_action_from_post( $post );\n\t\t} catch ( ActionScheduler_InvalidActionException $exception ) {\n\t\t\tdo_action( 'action_scheduler_failed_fetch_action', $post->ID, $exception );\n\t\t\treturn $this->get_null_action();\n\t\t}\n\n\t\treturn $action;\n\t}\n\n\t/**\n\t * Get post.\n\t *\n\t * @param string $action_id - Action ID.\n\t * @return WP_Post|null\n\t */\n\tprotected function get_post( $action_id ) {\n\t\tif ( empty( $action_id ) ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn get_post( $action_id );\n\t}\n\n\t/**\n\t * Get NULL action.\n\t *\n\t * @return ActionScheduler_NullAction\n\t */\n\tprotected function get_null_action() {\n\t\treturn new ActionScheduler_NullAction();\n\t}\n\n\t/**\n\t * Make action from post.\n\t *\n\t * @param WP_Post $post Post object.\n\t * @return WP_Post\n\t */\n\tprotected function make_action_from_post( $post ) {\n\t\t$hook = $post->post_title;\n\n\t\t$args = json_decode( $post->post_content, true );\n\t\t$this->validate_args( $args, $post->ID );\n\n\t\t$schedule = get_post_meta( $post->ID, self::SCHEDULE_META_KEY, true );\n\t\t$this->validate_schedule( $schedule, $post->ID );\n\n\t\t$group = wp_get_object_terms( $post->ID, self::GROUP_TAXONOMY, array( 'fields' => 'names' ) );\n\t\t$group = empty( $group ) ? '' : reset( $group );\n\n\t\treturn ActionScheduler::factory()->get_stored_action( $this->get_action_status_by_post_status( $post->post_status ), $hook, $args, $schedule, $group );\n\t}\n\n\t/**\n\t * Get action status by post status.\n\t *\n\t * @param string $post_status Post status.\n\t *\n\t * @throws InvalidArgumentException Throw InvalidArgumentException if $post_status not in known status fields returned by $this->get_status_labels().\n\t * @return string\n\t */\n\tprotected function get_action_status_by_post_status( $post_status ) {\n\n\t\tswitch ( $post_status ) {\n\t\t\tcase 'publish':\n\t\t\t\t$action_status = self::STATUS_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase 'trash':\n\t\t\t\t$action_status = self::STATUS_CANCELED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( ! array_key_exists( $post_status, $this->get_status_labels() ) ) {\n\t\t\t\t\tthrow new InvalidArgumentException( sprintf( 'Invalid post status: \"%s\". No matching action status available.', $post_status ) );\n\t\t\t\t}\n\t\t\t\t$action_status = $post_status;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $action_status;\n\t}\n\n\t/**\n\t * Get post status by action status.\n\t *\n\t * @param string $action_status Action status.\n\t *\n\t * @throws InvalidArgumentException Throws InvalidArgumentException if $post_status not in known status fields returned by $this->get_status_labels().\n\t * @return string\n\t */\n\tprotected function get_post_status_by_action_status( $action_status ) {\n\n\t\tswitch ( $action_status ) {\n\t\t\tcase self::STATUS_COMPLETE:\n\t\t\t\t$post_status = 'publish';\n\t\t\t\tbreak;\n\t\t\tcase self::STATUS_CANCELED:\n\t\t\t\t$post_status = 'trash';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( ! array_key_exists( $action_status, $this->get_status_labels() ) ) {\n\t\t\t\t\tthrow new InvalidArgumentException( sprintf( 'Invalid action status: \"%s\".', $action_status ) );\n\t\t\t\t}\n\t\t\t\t$post_status = $action_status;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $post_status;\n\t}\n\n\t/**\n\t * Returns the SQL statement to query (or count) actions.\n\t *\n\t * @param array  $query            - Filtering options.\n\t * @param string $select_or_count  - Whether the SQL should select and return the IDs or just the row count.\n\t *\n\t * @throws InvalidArgumentException - Throw InvalidArgumentException if $select_or_count not count or select.\n\t * @return string SQL statement. The returned SQL is already properly escaped.\n\t */\n\tprotected function get_query_actions_sql( array $query, $select_or_count = 'select' ) {\n\n\t\tif ( ! in_array( $select_or_count, array( 'select', 'count' ), true ) ) {\n\t\t\tthrow new InvalidArgumentException( __( 'Invalid schedule. Cannot save action.', 'action-scheduler' ) );\n\t\t}\n\n\t\t$query = wp_parse_args(\n\t\t\t$query,\n\t\t\tarray(\n\t\t\t\t'hook'             => '',\n\t\t\t\t'args'             => null,\n\t\t\t\t'date'             => null,\n\t\t\t\t'date_compare'     => '<=',\n\t\t\t\t'modified'         => null,\n\t\t\t\t'modified_compare' => '<=',\n\t\t\t\t'group'            => '',\n\t\t\t\t'status'           => '',\n\t\t\t\t'claimed'          => null,\n\t\t\t\t'per_page'         => 5,\n\t\t\t\t'offset'           => 0,\n\t\t\t\t'orderby'          => 'date',\n\t\t\t\t'order'            => 'ASC',\n\t\t\t\t'search'           => '',\n\t\t\t)\n\t\t);\n\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\t\t$sql        = ( 'count' === $select_or_count ) ? 'SELECT count(p.ID)' : 'SELECT p.ID ';\n\t\t$sql       .= \"FROM {$wpdb->posts} p\";\n\t\t$sql_params = array();\n\t\tif ( empty( $query['group'] ) && 'group' === $query['orderby'] ) {\n\t\t\t$sql .= \" LEFT JOIN {$wpdb->term_relationships} tr ON tr.object_id=p.ID\";\n\t\t\t$sql .= \" LEFT JOIN {$wpdb->term_taxonomy} tt ON tr.term_taxonomy_id=tt.term_taxonomy_id\";\n\t\t\t$sql .= \" LEFT JOIN {$wpdb->terms} t ON tt.term_id=t.term_id\";\n\t\t} elseif ( ! empty( $query['group'] ) ) {\n\t\t\t$sql         .= \" INNER JOIN {$wpdb->term_relationships} tr ON tr.object_id=p.ID\";\n\t\t\t$sql         .= \" INNER JOIN {$wpdb->term_taxonomy} tt ON tr.term_taxonomy_id=tt.term_taxonomy_id\";\n\t\t\t$sql         .= \" INNER JOIN {$wpdb->terms} t ON tt.term_id=t.term_id\";\n\t\t\t$sql         .= ' AND t.slug=%s';\n\t\t\t$sql_params[] = $query['group'];\n\t\t}\n\t\t$sql         .= ' WHERE post_type=%s';\n\t\t$sql_params[] = self::POST_TYPE;\n\t\tif ( $query['hook'] ) {\n\t\t\t$sql         .= ' AND p.post_title=%s';\n\t\t\t$sql_params[] = $query['hook'];\n\t\t}\n\t\tif ( ! is_null( $query['args'] ) ) {\n\t\t\t$sql         .= ' AND p.post_content=%s';\n\t\t\t$sql_params[] = wp_json_encode( $query['args'] );\n\t\t}\n\n\t\tif ( $query['status'] ) {\n\t\t\t$post_statuses = array_map( array( $this, 'get_post_status_by_action_status' ), (array) $query['status'] );\n\t\t\t$placeholders  = array_fill( 0, count( $post_statuses ), '%s' );\n\t\t\t$sql          .= ' AND p.post_status IN (' . join( ', ', $placeholders ) . ')';\n\t\t\t$sql_params    = array_merge( $sql_params, array_values( $post_statuses ) );\n\t\t}\n\n\t\tif ( $query['date'] instanceof DateTime ) {\n\t\t\t$date = clone $query['date'];\n\t\t\t$date->setTimezone( new DateTimeZone( 'UTC' ) );\n\t\t\t$date_string  = $date->format( 'Y-m-d H:i:s' );\n\t\t\t$comparator   = $this->validate_sql_comparator( $query['date_compare'] );\n\t\t\t$sql         .= \" AND p.post_date_gmt $comparator %s\";\n\t\t\t$sql_params[] = $date_string;\n\t\t}\n\n\t\tif ( $query['modified'] instanceof DateTime ) {\n\t\t\t$modified = clone $query['modified'];\n\t\t\t$modified->setTimezone( new DateTimeZone( 'UTC' ) );\n\t\t\t$date_string  = $modified->format( 'Y-m-d H:i:s' );\n\t\t\t$comparator   = $this->validate_sql_comparator( $query['modified_compare'] );\n\t\t\t$sql         .= \" AND p.post_modified_gmt $comparator %s\";\n\t\t\t$sql_params[] = $date_string;\n\t\t}\n\n\t\tif ( true === $query['claimed'] ) {\n\t\t\t$sql .= \" AND p.post_password != ''\";\n\t\t} elseif ( false === $query['claimed'] ) {\n\t\t\t$sql .= \" AND p.post_password = ''\";\n\t\t} elseif ( ! is_null( $query['claimed'] ) ) {\n\t\t\t$sql         .= ' AND p.post_password = %s';\n\t\t\t$sql_params[] = $query['claimed'];\n\t\t}\n\n\t\tif ( ! empty( $query['search'] ) ) {\n\t\t\t$sql .= ' AND (p.post_title LIKE %s OR p.post_content LIKE %s OR p.post_password LIKE %s)';\n\t\t\tfor ( $i = 0; $i < 3; $i++ ) {\n\t\t\t\t$sql_params[] = sprintf( '%%%s%%', $query['search'] );\n\t\t\t}\n\t\t}\n\n\t\tif ( 'select' === $select_or_count ) {\n\t\t\tswitch ( $query['orderby'] ) {\n\t\t\t\tcase 'hook':\n\t\t\t\t\t$orderby = 'p.post_title';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'group':\n\t\t\t\t\t$orderby = 't.name';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'status':\n\t\t\t\t\t$orderby = 'p.post_status';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'modified':\n\t\t\t\t\t$orderby = 'p.post_modified';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'claim_id':\n\t\t\t\t\t$orderby = 'p.post_password';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'schedule':\n\t\t\t\tcase 'date':\n\t\t\t\tdefault:\n\t\t\t\t\t$orderby = 'p.post_date_gmt';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( 'ASC' === strtoupper( $query['order'] ) ) {\n\t\t\t\t$order = 'ASC';\n\t\t\t} else {\n\t\t\t\t$order = 'DESC';\n\t\t\t}\n\t\t\t$sql .= \" ORDER BY $orderby $order\";\n\t\t\tif ( $query['per_page'] > 0 ) {\n\t\t\t\t$sql         .= ' LIMIT %d, %d';\n\t\t\t\t$sql_params[] = $query['offset'];\n\t\t\t\t$sql_params[] = $query['per_page'];\n\t\t\t}\n\t\t}\n\n\t\treturn $wpdb->prepare( $sql, $sql_params ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared\n\t}\n\n\t/**\n\t * Query for action count or list of action IDs.\n\t *\n\t * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.\n\t *\n\t * @see ActionScheduler_Store::query_actions for $query arg usage.\n\t *\n\t * @param array  $query      Query filtering options.\n\t * @param string $query_type Whether to select or count the results. Defaults to select.\n\t *\n\t * @return string|array|null The IDs of actions matching the query. Null on failure.\n\t */\n\tpublic function query_actions( $query = array(), $query_type = 'select' ) {\n\t\t/**\n\t\t * Global $wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t$sql = $this->get_query_actions_sql( $query, $query_type );\n\n\t\treturn ( 'count' === $query_type ) ? $wpdb->get_var( $sql ) : $wpdb->get_col( $sql ); // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery,WordPress.DB.DirectDatabaseQuery.NoCaching,WordPress.DB.PreparedSQL.NotPrepared\n\t}\n\n\t/**\n\t * Get a count of all actions in the store, grouped by status\n\t *\n\t * @return array\n\t */\n\tpublic function action_counts() {\n\n\t\t$action_counts_by_status = array();\n\t\t$action_stati_and_labels = $this->get_status_labels();\n\t\t$posts_count_by_status   = (array) wp_count_posts( self::POST_TYPE, 'readable' );\n\n\t\tforeach ( $posts_count_by_status as $post_status_name => $count ) {\n\n\t\t\ttry {\n\t\t\t\t$action_status_name = $this->get_action_status_by_post_status( $post_status_name );\n\t\t\t} catch ( Exception $e ) {\n\t\t\t\t// Ignore any post statuses that aren't for actions.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( array_key_exists( $action_status_name, $action_stati_and_labels ) ) {\n\t\t\t\t$action_counts_by_status[ $action_status_name ] = $count;\n\t\t\t}\n\t\t}\n\n\t\treturn $action_counts_by_status;\n\t}\n\n\t/**\n\t * Cancel action.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @throws InvalidArgumentException If $action_id is not identified.\n\t */\n\tpublic function cancel_action( $action_id ) {\n\t\t$post = get_post( $action_id );\n\t\tif ( empty( $post ) || ( self::POST_TYPE !== $post->post_type ) ) {\n\t\t\t/* translators: %s is the action ID */\n\t\t\tthrow new InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t\tdo_action( 'action_scheduler_canceled_action', $action_id );\n\t\tadd_filter( 'pre_wp_unique_post_slug', array( $this, 'set_unique_post_slug' ), 10, 5 );\n\t\twp_trash_post( $action_id );\n\t\tremove_filter( 'pre_wp_unique_post_slug', array( $this, 'set_unique_post_slug' ), 10 );\n\t}\n\n\t/**\n\t * Delete action.\n\t *\n\t * @param int $action_id Action ID.\n\t * @return void\n\t * @throws InvalidArgumentException If action is not identified.\n\t */\n\tpublic function delete_action( $action_id ) {\n\t\t$post = get_post( $action_id );\n\t\tif ( empty( $post ) || ( self::POST_TYPE !== $post->post_type ) ) {\n\t\t\t/* translators: %s is the action ID */\n\t\t\tthrow new InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t\tdo_action( 'action_scheduler_deleted_action', $action_id );\n\n\t\twp_delete_post( $action_id, true );\n\t}\n\n\t/**\n\t * Get date for claim id.\n\t *\n\t * @param int $action_id Action ID.\n\t * @return ActionScheduler_DateTime The date the action is schedule to run, or the date that it ran.\n\t */\n\tpublic function get_date( $action_id ) {\n\t\t$next = $this->get_date_gmt( $action_id );\n\t\treturn ActionScheduler_TimezoneHelper::set_local_timezone( $next );\n\t}\n\n\t/**\n\t * Get Date GMT.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @throws InvalidArgumentException If $action_id is not identified.\n\t * @return ActionScheduler_DateTime The date the action is schedule to run, or the date that it ran.\n\t */\n\tpublic function get_date_gmt( $action_id ) {\n\t\t$post = get_post( $action_id );\n\t\tif ( empty( $post ) || ( self::POST_TYPE !== $post->post_type ) ) {\n\t\t\t/* translators: %s is the action ID */\n\t\t\tthrow new InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t\tif ( 'publish' === $post->post_status ) {\n\t\t\treturn as_get_datetime_object( $post->post_modified_gmt );\n\t\t} else {\n\t\t\treturn as_get_datetime_object( $post->post_date_gmt );\n\t\t}\n\t}\n\n\t/**\n\t * Stake claim.\n\t *\n\t * @param int      $max_actions Maximum number of actions.\n\t * @param DateTime $before_date Jobs must be schedule before this date. Defaults to now.\n\t * @param array    $hooks       Claim only actions with a hook or hooks.\n\t * @param string   $group       Claim only actions in the given group.\n\t *\n\t * @return ActionScheduler_ActionClaim\n\t * @throws RuntimeException When there is an error staking a claim.\n\t * @throws InvalidArgumentException When the given group is not valid.\n\t */\n\tpublic function stake_claim( $max_actions = 10, DateTime $before_date = null, $hooks = array(), $group = '' ) {\n\t\t$this->claim_before_date = $before_date;\n\t\t$claim_id                = $this->generate_claim_id();\n\t\t$this->claim_actions( $claim_id, $max_actions, $before_date, $hooks, $group );\n\t\t$action_ids              = $this->find_actions_by_claim_id( $claim_id );\n\t\t$this->claim_before_date = null;\n\n\t\treturn new ActionScheduler_ActionClaim( $claim_id, $action_ids );\n\t}\n\n\t/**\n\t * Get claim count.\n\t *\n\t * @return int\n\t */\n\tpublic function get_claim_count() {\n\t\tglobal $wpdb;\n\n\t\t// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery,WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\treturn $wpdb->get_var(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"SELECT COUNT(DISTINCT post_password) FROM {$wpdb->posts} WHERE post_password != '' AND post_type = %s AND post_status IN ('in-progress','pending')\",\n\t\t\t\tarray( self::POST_TYPE )\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Generate claim id.\n\t *\n\t * @return string\n\t */\n\tprotected function generate_claim_id() {\n\t\t$claim_id = md5( microtime( true ) . wp_rand( 0, 1000 ) );\n\t\treturn substr( $claim_id, 0, 20 ); // to fit in db field with 20 char limit.\n\t}\n\n\t/**\n\t * Claim actions.\n\t *\n\t * @param string   $claim_id    Claim ID.\n\t * @param int      $limit       Limit.\n\t * @param DateTime $before_date Should use UTC timezone.\n\t * @param array    $hooks       Claim only actions with a hook or hooks.\n\t * @param string   $group       Claim only actions in the given group.\n\t *\n\t * @return int The number of actions that were claimed.\n\t * @throws RuntimeException  When there is a database error.\n\t */\n\tprotected function claim_actions( $claim_id, $limit, DateTime $before_date = null, $hooks = array(), $group = '' ) {\n\t\t// Set up initial variables.\n\t\t$date      = null === $before_date ? as_get_datetime_object() : clone $before_date;\n\t\t$limit_ids = ! empty( $group );\n\t\t$ids       = $limit_ids ? $this->get_actions_by_group( $group, $limit, $date ) : array();\n\n\t\t// If limiting by IDs and no posts found, then return early since we have nothing to update.\n\t\tif ( $limit_ids && 0 === count( $ids ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t/*\n\t\t * Build up custom query to update the affected posts. Parameters are built as a separate array\n\t\t * to make it easier to identify where they are in the query.\n\t\t *\n\t\t * We can't use $wpdb->update() here because of the \"ID IN ...\" clause.\n\t\t */\n\t\t$update = \"UPDATE {$wpdb->posts} SET post_password = %s, post_modified_gmt = %s, post_modified = %s\";\n\t\t$params = array(\n\t\t\t$claim_id,\n\t\t\tcurrent_time( 'mysql', true ),\n\t\t\tcurrent_time( 'mysql' ),\n\t\t);\n\n\t\t// Build initial WHERE clause.\n\t\t$where    = \"WHERE post_type = %s AND post_status = %s AND post_password = ''\";\n\t\t$params[] = self::POST_TYPE;\n\t\t$params[] = ActionScheduler_Store::STATUS_PENDING;\n\n\t\tif ( ! empty( $hooks ) ) {\n\t\t\t$placeholders = array_fill( 0, count( $hooks ), '%s' );\n\t\t\t$where       .= ' AND post_title IN (' . join( ', ', $placeholders ) . ')';\n\t\t\t$params       = array_merge( $params, array_values( $hooks ) );\n\t\t}\n\n\t\t/*\n\t\t * Add the IDs to the WHERE clause. IDs not escaped because they came directly from a prior DB query.\n\t\t *\n\t\t * If we're not limiting by IDs, then include the post_date_gmt clause.\n\t\t */\n\t\tif ( $limit_ids ) {\n\t\t\t$where .= ' AND ID IN (' . join( ',', $ids ) . ')';\n\t\t} else {\n\t\t\t$where   .= ' AND post_date_gmt <= %s';\n\t\t\t$params[] = $date->format( 'Y-m-d H:i:s' );\n\t\t}\n\n\t\t// Add the ORDER BY clause and,ms limit.\n\t\t$order    = 'ORDER BY menu_order ASC, post_date_gmt ASC, ID ASC LIMIT %d';\n\t\t$params[] = $limit;\n\n\t\t// Run the query and gather results.\n\t\t$rows_affected = $wpdb->query( $wpdb->prepare( \"{$update} {$where} {$order}\", $params ) ); // phpcs:ignore // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare\n\n\t\tif ( false === $rows_affected ) {\n\t\t\tthrow new RuntimeException( __( 'Unable to claim actions. Database error.', 'action-scheduler' ) );\n\t\t}\n\n\t\treturn (int) $rows_affected;\n\t}\n\n\t/**\n\t * Get IDs of actions within a certain group and up to a certain date/time.\n\t *\n\t * @param string   $group The group to use in finding actions.\n\t * @param int      $limit The number of actions to retrieve.\n\t * @param DateTime $date  DateTime object representing cutoff time for actions. Actions retrieved will be\n\t *                        up to and including this DateTime.\n\t *\n\t * @return array IDs of actions in the appropriate group and before the appropriate time.\n\t * @throws InvalidArgumentException When the group does not exist.\n\t */\n\tprotected function get_actions_by_group( $group, $limit, DateTime $date ) {\n\t\t// Ensure the group exists before continuing.\n\t\tif ( ! term_exists( $group, self::GROUP_TAXONOMY ) ) {\n\t\t\t/* translators: %s is the group name */\n\t\t\tthrow new InvalidArgumentException( sprintf( __( 'The group \"%s\" does not exist.', 'action-scheduler' ), $group ) );\n\t\t}\n\n\t\t// Set up a query for post IDs to use later.\n\t\t$query      = new WP_Query();\n\t\t$query_args = array(\n\t\t\t'fields'           => 'ids',\n\t\t\t'post_type'        => self::POST_TYPE,\n\t\t\t'post_status'      => ActionScheduler_Store::STATUS_PENDING,\n\t\t\t'has_password'     => false,\n\t\t\t'posts_per_page'   => $limit * 3,\n\t\t\t'suppress_filters' => true,\n\t\t\t'no_found_rows'    => true,\n\t\t\t'orderby'          => array(\n\t\t\t\t'menu_order' => 'ASC',\n\t\t\t\t'date'       => 'ASC',\n\t\t\t\t'ID'         => 'ASC',\n\t\t\t),\n\t\t\t'date_query'       => array(\n\t\t\t\t'column'    => 'post_date_gmt',\n\t\t\t\t'before'    => $date->format( 'Y-m-d H:i' ),\n\t\t\t\t'inclusive' => true,\n\t\t\t),\n\t\t\t'tax_query'        => array( // phpcs:ignore WordPress.DB.SlowDBQuery\n\t\t\t\tarray(\n\t\t\t\t\t'taxonomy'         => self::GROUP_TAXONOMY,\n\t\t\t\t\t'field'            => 'slug',\n\t\t\t\t\t'terms'            => $group,\n\t\t\t\t\t'include_children' => false,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\treturn $query->query( $query_args );\n\t}\n\n\t/**\n\t * Find actions by claim ID.\n\t *\n\t * @param string $claim_id Claim ID.\n\t * @return array\n\t */\n\tpublic function find_actions_by_claim_id( $claim_id ) {\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t$action_ids  = array();\n\t\t$before_date = isset( $this->claim_before_date ) ? $this->claim_before_date : as_get_datetime_object();\n\t\t$cut_off     = $before_date->format( 'Y-m-d H:i:s' );\n\n\t\t// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\t$results = $wpdb->get_results(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"SELECT ID, post_date_gmt FROM {$wpdb->posts} WHERE post_type = %s AND post_password = %s\",\n\t\t\t\tarray(\n\t\t\t\t\tself::POST_TYPE,\n\t\t\t\t\t$claim_id,\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Verify that the scheduled date for each action is within the expected bounds (in some unusual\n\t\t// cases, we cannot depend on MySQL to honor all of the WHERE conditions we specify).\n\t\tforeach ( $results as $claimed_action ) {\n\t\t\tif ( $claimed_action->post_date_gmt <= $cut_off ) {\n\t\t\t\t$action_ids[] = absint( $claimed_action->ID );\n\t\t\t}\n\t\t}\n\n\t\treturn $action_ids;\n\t}\n\n\t/**\n\t * Release claim.\n\t *\n\t * @param ActionScheduler_ActionClaim $claim Claim object to release.\n\t * @return void\n\t * @throws RuntimeException When the claim is not unlocked.\n\t */\n\tpublic function release_claim( ActionScheduler_ActionClaim $claim ) {\n\t\t$action_ids = $this->find_actions_by_claim_id( $claim->get_id() );\n\t\tif ( empty( $action_ids ) ) {\n\t\t\treturn; // nothing to do.\n\t\t}\n\t\t$action_id_string = implode( ',', array_map( 'intval', $action_ids ) );\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\t$result = $wpdb->query(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"UPDATE {$wpdb->posts} SET post_password = '' WHERE ID IN ($action_id_string) AND post_password = %s\", //phpcs:ignore\n\t\t\t\tarray(\n\t\t\t\t\t$claim->get_id(),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\tif ( false === $result ) {\n\t\t\t/* translators: %s: claim ID */\n\t\t\tthrow new RuntimeException( sprintf( __( 'Unable to unlock claim %s. Database error.', 'action-scheduler' ), $claim->get_id() ) );\n\t\t}\n\t}\n\n\t/**\n\t * Unclaim action.\n\t *\n\t * @param string $action_id Action ID.\n\t * @throws RuntimeException When unable to unlock claim on action ID.\n\t */\n\tpublic function unclaim_action( $action_id ) {\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t//phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\t$result = $wpdb->query(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"UPDATE {$wpdb->posts} SET post_password = '' WHERE ID = %d AND post_type = %s\",\n\t\t\t\t$action_id,\n\t\t\t\tself::POST_TYPE\n\t\t\t)\n\t\t);\n\t\tif ( false === $result ) {\n\t\t\t/* translators: %s: action ID */\n\t\t\tthrow new RuntimeException( sprintf( __( 'Unable to unlock claim on action %s. Database error.', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t}\n\n\t/**\n\t * Mark failure on action.\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return void\n\t * @throws RuntimeException When unable to mark failure on action ID.\n\t */\n\tpublic function mark_failure( $action_id ) {\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\t$result = $wpdb->query(\n\t\t\t$wpdb->prepare( \"UPDATE {$wpdb->posts} SET post_status = %s WHERE ID = %d AND post_type = %s\", self::STATUS_FAILED, $action_id, self::POST_TYPE )\n\t\t);\n\t\tif ( false === $result ) {\n\t\t\t/* translators: %s: action ID */\n\t\t\tthrow new RuntimeException( sprintf( __( 'Unable to mark failure on action %s. Database error.', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t}\n\n\t/**\n\t * Return an action's claim ID, as stored in the post password column\n\t *\n\t * @param int $action_id Action ID.\n\t * @return mixed\n\t */\n\tpublic function get_claim_id( $action_id ) {\n\t\treturn $this->get_post_column( $action_id, 'post_password' );\n\t}\n\n\t/**\n\t * Return an action's status, as stored in the post status column\n\t *\n\t * @param int $action_id Action ID.\n\t *\n\t * @return mixed\n\t * @throws InvalidArgumentException When the action ID is invalid.\n\t */\n\tpublic function get_status( $action_id ) {\n\t\t$status = $this->get_post_column( $action_id, 'post_status' );\n\n\t\tif ( null === $status ) {\n\t\t\tthrow new InvalidArgumentException( __( 'Invalid action ID. No status found.', 'action-scheduler' ) );\n\t\t}\n\n\t\treturn $this->get_action_status_by_post_status( $status );\n\t}\n\n\t/**\n\t * Get post column\n\t *\n\t * @param string $action_id Action ID.\n\t * @param string $column_name Column Name.\n\t *\n\t * @return string|null\n\t */\n\tprivate function get_post_column( $action_id, $column_name ) {\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\treturn $wpdb->get_var(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"SELECT {$column_name} FROM {$wpdb->posts} WHERE ID=%d AND post_type=%s\", // phpcs:ignore\n\t\t\t\t$action_id,\n\t\t\t\tself::POST_TYPE\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Log Execution.\n\t *\n\t * @param string $action_id Action ID.\n\t */\n\tpublic function log_execution( $action_id ) {\n\t\t/**\n\t\t * Global wpdb object.\n\t\t *\n\t\t * @var wpdb $wpdb\n\t\t */\n\t\tglobal $wpdb;\n\n\t\t// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\t$wpdb->query(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"UPDATE {$wpdb->posts} SET menu_order = menu_order+1, post_status=%s, post_modified_gmt = %s, post_modified = %s WHERE ID = %d AND post_type = %s\",\n\t\t\t\tself::STATUS_RUNNING,\n\t\t\t\tcurrent_time( 'mysql', true ),\n\t\t\t\tcurrent_time( 'mysql' ),\n\t\t\t\t$action_id,\n\t\t\t\tself::POST_TYPE\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Record that an action was completed.\n\t *\n\t * @param string $action_id ID of the completed action.\n\t *\n\t * @throws InvalidArgumentException When the action ID is invalid.\n\t * @throws RuntimeException         When there was an error executing the action.\n\t */\n\tpublic function mark_complete( $action_id ) {\n\t\t$post = get_post( $action_id );\n\t\tif ( empty( $post ) || ( self::POST_TYPE !== $post->post_type ) ) {\n\t\t\t/* translators: %s is the action ID */\n\t\t\tthrow new InvalidArgumentException( sprintf( __( 'Unidentified action %s', 'action-scheduler' ), $action_id ) );\n\t\t}\n\t\tadd_filter( 'wp_insert_post_data', array( $this, 'filter_insert_post_data' ), 10, 1 );\n\t\tadd_filter( 'pre_wp_unique_post_slug', array( $this, 'set_unique_post_slug' ), 10, 5 );\n\t\t$result = wp_update_post(\n\t\t\tarray(\n\t\t\t\t'ID'          => $action_id,\n\t\t\t\t'post_status' => 'publish',\n\t\t\t),\n\t\t\ttrue\n\t\t);\n\t\tremove_filter( 'wp_insert_post_data', array( $this, 'filter_insert_post_data' ), 10 );\n\t\tremove_filter( 'pre_wp_unique_post_slug', array( $this, 'set_unique_post_slug' ), 10 );\n\t\tif ( is_wp_error( $result ) ) {\n\t\t\tthrow new RuntimeException( $result->get_error_message() );\n\t\t}\n\n\t\t/**\n\t\t * Fires after a scheduled action has been completed.\n\t\t *\n\t\t * @since 3.4.2\n\t\t *\n\t\t * @param int $action_id Action ID.\n\t\t */\n\t\tdo_action( 'action_scheduler_completed_action', $action_id );\n\t}\n\n\t/**\n\t * Mark action as migrated when there is an error deleting the action.\n\t *\n\t * @param int $action_id Action ID.\n\t */\n\tpublic function mark_migrated( $action_id ) {\n\t\twp_update_post(\n\t\t\tarray(\n\t\t\t\t'ID'          => $action_id,\n\t\t\t\t'post_status' => 'migrated',\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Determine whether the post store can be migrated.\n\t *\n\t * @param [type] $setting - Setting value.\n\t * @return bool\n\t */\n\tpublic function migration_dependencies_met( $setting ) {\n\t\tglobal $wpdb;\n\n\t\t$dependencies_met = get_transient( self::DEPENDENCIES_MET );\n\t\tif ( empty( $dependencies_met ) ) {\n\t\t\t$maximum_args_length = apply_filters( 'action_scheduler_maximum_args_length', 191 );\n\t\t\t$found_action        = $wpdb->get_var( // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching\n\t\t\t\t$wpdb->prepare(\n\t\t\t\t\t\"SELECT ID FROM {$wpdb->posts} WHERE post_type = %s AND CHAR_LENGTH(post_content) > %d LIMIT 1\",\n\t\t\t\t\t$maximum_args_length,\n\t\t\t\t\tself::POST_TYPE\n\t\t\t\t)\n\t\t\t);\n\t\t\t$dependencies_met    = $found_action ? 'no' : 'yes';\n\t\t\tset_transient( self::DEPENDENCIES_MET, $dependencies_met, DAY_IN_SECONDS );\n\t\t}\n\n\t\treturn 'yes' === $dependencies_met ? $setting : false;\n\t}\n\n\t/**\n\t * InnoDB indexes have a maximum size of 767 bytes by default, which is only 191 characters with utf8mb4.\n\t *\n\t * Previously, AS wasn't concerned about args length, as we used the (unindex) post_content column. However,\n\t * as we prepare to move to custom tables, and can use an indexed VARCHAR column instead, we want to warn\n\t * developers of this impending requirement.\n\t *\n\t * @param ActionScheduler_Action $action Action object.\n\t */\n\tprotected function validate_action( ActionScheduler_Action $action ) {\n\t\ttry {\n\t\t\tparent::validate_action( $action );\n\t\t} catch ( Exception $e ) {\n\t\t\t/* translators: %s is the error message */\n\t\t\t$message = sprintf( __( '%s Support for strings longer than this will be removed in a future version.', 'action-scheduler' ), $e->getMessage() );\n\t\t\t_doing_it_wrong( 'ActionScheduler_Action::$args', esc_html( $message ), '2.1.0' );\n\t\t}\n\t}\n\n\t/**\n\t * (@codeCoverageIgnore)\n\t */\n\tpublic function init() {\n\t\tadd_filter( 'action_scheduler_migration_dependencies_met', array( $this, 'migration_dependencies_met' ) );\n\n\t\t$post_type_registrar = new ActionScheduler_wpPostStore_PostTypeRegistrar();\n\t\t$post_type_registrar->register();\n\n\t\t$post_status_registrar = new ActionScheduler_wpPostStore_PostStatusRegistrar();\n\t\t$post_status_registrar->register();\n\n\t\t$taxonomy_registrar = new ActionScheduler_wpPostStore_TaxonomyRegistrar();\n\t\t$taxonomy_registrar->register();\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_wpPostStore.php b/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_wpPostStore.php
--- a/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_wpPostStore.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/data-stores/ActionScheduler_wpPostStore.php	(date 1675081217925)
@@ -452,7 +452,7 @@
 	/**
 	 * Query for action count or list of action IDs.
 	 *
-	 * @since 3.3.0 $query['status'] accepts array of statuses instead of a single status.
+	 * @since x.x.x $query['status'] accepts array of statuses instead of a single status.
 	 *
 	 * @see ActionScheduler_Store::query_actions for $query arg usage.
 	 *
Index: inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_QueueRunner.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\n/**\n * Abstract class with common Queue Cleaner functionality.\n */\nabstract class ActionScheduler_Abstract_QueueRunner extends ActionScheduler_Abstract_QueueRunner_Deprecated {\n\n\t/** @var ActionScheduler_QueueCleaner */\n\tprotected $cleaner;\n\n\t/** @var ActionScheduler_FatalErrorMonitor */\n\tprotected $monitor;\n\n\t/** @var ActionScheduler_Store */\n\tprotected $store;\n\n\t/**\n\t * The created time.\n\t *\n\t * Represents when the queue runner was constructed and used when calculating how long a PHP request has been running.\n\t * For this reason it should be as close as possible to the PHP request start time.\n\t *\n\t * @var int\n\t */\n\tprivate $created_time;\n\n\t/**\n\t * ActionScheduler_Abstract_QueueRunner constructor.\n\t *\n\t * @param ActionScheduler_Store             $store\n\t * @param ActionScheduler_FatalErrorMonitor $monitor\n\t * @param ActionScheduler_QueueCleaner      $cleaner\n\t */\n\tpublic function __construct( ActionScheduler_Store $store = null, ActionScheduler_FatalErrorMonitor $monitor = null, ActionScheduler_QueueCleaner $cleaner = null ) {\n\n\t\t$this->created_time = microtime( true );\n\n\t\t$this->store   = $store ? $store : ActionScheduler_Store::instance();\n\t\t$this->monitor = $monitor ? $monitor : new ActionScheduler_FatalErrorMonitor( $this->store );\n\t\t$this->cleaner = $cleaner ? $cleaner : new ActionScheduler_QueueCleaner( $this->store );\n\t}\n\n\t/**\n\t * Process an individual action.\n\t *\n\t * @param int $action_id The action ID to process.\n\t * @param string $context Optional identifer for the context in which this action is being processed, e.g. 'WP CLI' or 'WP Cron'\n\t *        Generally, this should be capitalised and not localised as it's a proper noun.\n\t */\n\tpublic function process_action( $action_id, $context = '' ) {\n\t\ttry {\n\t\t\t$valid_action = false;\n\t\t\tdo_action( 'action_scheduler_before_execute', $action_id, $context );\n\n\t\t\tif ( ActionScheduler_Store::STATUS_PENDING !== $this->store->get_status( $action_id ) ) {\n\t\t\t\tdo_action( 'action_scheduler_execution_ignored', $action_id, $context );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$valid_action = true;\n\t\t\tdo_action( 'action_scheduler_begin_execute', $action_id, $context );\n\n\t\t\t$action = $this->store->fetch_action( $action_id );\n\t\t\t$this->store->log_execution( $action_id );\n\t\t\t$action->execute();\n\t\t\tdo_action( 'action_scheduler_after_execute', $action_id, $action, $context );\n\t\t\t$this->store->mark_complete( $action_id );\n\t\t} catch ( Exception $e ) {\n\t\t\tif ( $valid_action ) {\n\t\t\t\t$this->store->mark_failure( $action_id );\n\t\t\t\tdo_action( 'action_scheduler_failed_execution', $action_id, $e, $context );\n\t\t\t} else {\n\t\t\t\tdo_action( 'action_scheduler_failed_validation', $action_id, $e, $context );\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $action ) && is_a( $action, 'ActionScheduler_Action' ) && $action->get_schedule()->is_recurring() ) {\n\t\t\t$this->schedule_next_instance( $action, $action_id );\n\t\t}\n\t}\n\n\t/**\n\t * Schedule the next instance of the action if necessary.\n\t *\n\t * @param ActionScheduler_Action $action\n\t * @param int $action_id\n\t */\n\tprotected function schedule_next_instance( ActionScheduler_Action $action, $action_id ) {\n\t\t// If a recurring action has been consistently failing, we may wish to stop rescheduling it.\n\t\tif (\n\t\t\tActionScheduler_Store::STATUS_FAILED === $this->store->get_status( $action_id )\n\t\t\t&& $this->recurring_action_is_consistently_failing( $action, $action_id )\n\t\t) {\n\t\t\tActionScheduler_Logger::instance()->log(\n\t\t\t\t$action_id,\n\t\t\t\t__( 'This action appears to be consistently failing. A new instance will not be scheduled.', 'action-scheduler' )\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tActionScheduler::factory()->repeat( $action );\n\t\t} catch ( Exception $e ) {\n\t\t\tdo_action( 'action_scheduler_failed_to_schedule_next_instance', $action_id, $e, $action );\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the specified recurring action has been consistently failing.\n\t *\n\t * @param ActionScheduler_Action $action    The recurring action to be rescheduled.\n\t * @param int                    $action_id The ID of the recurring action.\n\t *\n\t * @return bool\n\t */\n\tprivate function recurring_action_is_consistently_failing( ActionScheduler_Action $action, $action_id ) {\n\t\t/**\n\t\t * Controls the failure threshold for recurring actions.\n\t\t *\n\t\t * Before rescheduling a recurring action, we look at its status. If it failed, we then check if all of the most\n\t\t * recent actions (upto the threshold set by this filter) sharing the same hook have also failed: if they have,\n\t\t * that is considered consistent failure and a new instance of the action will not be scheduled.\n\t\t *\n\t\t * @param int $failure_threshold Number of actions of the same hook to examine for failure. Defaults to 5.\n\t\t */\n\t\t$consistent_failure_threshold = (int) apply_filters( 'action_scheduler_recurring_action_failure_threshold', 5 );\n\n\t\t// This query should find the earliest *failing* action (for the hook we are interested in) within our threshold.\n\t\t$query_args = array(\n\t\t\t'hook'         => $action->get_hook(),\n\t\t\t'status'       => ActionScheduler_Store::STATUS_FAILED,\n\t\t\t'date'         => date_create( 'now', timezone_open( 'UTC' ) )->format( 'Y-m-d H:i:s' ),\n\t\t\t'date_compare' => '<',\n\t\t\t'per_page'     => 1,\n\t\t\t'offset'       => $consistent_failure_threshold - 1\n\t\t);\n\n\t\t$first_failing_action_id = $this->store->query_actions( $query_args );\n\n\t\t// If we didn't retrieve an action ID, then there haven't been enough failures for us to worry about.\n\t\tif ( empty( $first_failing_action_id ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Now let's fetch the first action (having the same hook) of *any status*ithin the same window.\n\t\tunset( $query_args['status'] );\n\t\t$first_action_id_with_the_same_hook = $this->store->query_actions( $query_args );\n\n\t\t// If the IDs match, then actions for this hook must be consistently failing.\n\t\treturn $first_action_id_with_the_same_hook === $first_failing_action_id;\n\t}\n\n\t/**\n\t * Run the queue cleaner.\n\t *\n\t * @author Jeremy Pry\n\t */\n\tprotected function run_cleanup() {\n\t\t$this->cleaner->clean( 10 * $this->get_time_limit() );\n\t}\n\n\t/**\n\t * Get the number of concurrent batches a runner allows.\n\t *\n\t * @return int\n\t */\n\tpublic function get_allowed_concurrent_batches() {\n\t\treturn apply_filters( 'action_scheduler_queue_runner_concurrent_batches', 1 );\n\t}\n\n\t/**\n\t * Check if the number of allowed concurrent batches is met or exceeded.\n\t *\n\t * @return bool\n\t */\n\tpublic function has_maximum_concurrent_batches() {\n\t\treturn $this->store->get_claim_count() >= $this->get_allowed_concurrent_batches();\n\t}\n\n\t/**\n\t * Get the maximum number of seconds a batch can run for.\n\t *\n\t * @return int The number of seconds.\n\t */\n\tprotected function get_time_limit() {\n\n\t\t$time_limit = 30;\n\n\t\t// Apply deprecated filter from deprecated get_maximum_execution_time() method\n\t\tif ( has_filter( 'action_scheduler_maximum_execution_time' ) ) {\n\t\t\t_deprecated_function( 'action_scheduler_maximum_execution_time', '2.1.1', 'action_scheduler_queue_runner_time_limit' );\n\t\t\t$time_limit = apply_filters( 'action_scheduler_maximum_execution_time', $time_limit );\n\t\t}\n\n\t\treturn absint( apply_filters( 'action_scheduler_queue_runner_time_limit', $time_limit ) );\n\t}\n\n\t/**\n\t * Get the number of seconds the process has been running.\n\t *\n\t * @return int The number of seconds.\n\t */\n\tprotected function get_execution_time() {\n\t\t$execution_time = microtime( true ) - $this->created_time;\n\n\t\t// Get the CPU time if the hosting environment uses it rather than wall-clock time to calculate a process's execution time.\n\t\tif ( function_exists( 'getrusage' ) && apply_filters( 'action_scheduler_use_cpu_execution_time', defined( 'PANTHEON_ENVIRONMENT' ) ) ) {\n\t\t\t$resource_usages = getrusage();\n\n\t\t\tif ( isset( $resource_usages['ru_stime.tv_usec'], $resource_usages['ru_stime.tv_usec'] ) ) {\n\t\t\t\t$execution_time = $resource_usages['ru_stime.tv_sec'] + ( $resource_usages['ru_stime.tv_usec'] / 1000000 );\n\t\t\t}\n\t\t}\n\n\t\treturn $execution_time;\n\t}\n\n\t/**\n\t * Check if the host's max execution time is (likely) to be exceeded if processing more actions.\n\t *\n\t * @param int $processed_actions The number of actions processed so far - used to determine the likelihood of exceeding the time limit if processing another action\n\t * @return bool\n\t */\n\tprotected function time_likely_to_be_exceeded( $processed_actions ) {\n\n\t\t$execution_time        = $this->get_execution_time();\n\t\t$max_execution_time    = $this->get_time_limit();\n\t\t$time_per_action       = $execution_time / $processed_actions;\n\t\t$estimated_time        = $execution_time + ( $time_per_action * 3 );\n\t\t$likely_to_be_exceeded = $estimated_time > $max_execution_time;\n\n\t\treturn apply_filters( 'action_scheduler_maximum_execution_time_likely_to_be_exceeded', $likely_to_be_exceeded, $this, $processed_actions, $execution_time, $max_execution_time );\n\t}\n\n\t/**\n\t * Get memory limit\n\t *\n\t * Based on WP_Background_Process::get_memory_limit()\n\t *\n\t * @return int\n\t */\n\tprotected function get_memory_limit() {\n\t\tif ( function_exists( 'ini_get' ) ) {\n\t\t\t$memory_limit = ini_get( 'memory_limit' );\n\t\t} else {\n\t\t\t$memory_limit = '128M'; // Sensible default, and minimum required by WooCommerce\n\t\t}\n\n\t\tif ( ! $memory_limit || -1 === $memory_limit || '-1' === $memory_limit ) {\n\t\t\t// Unlimited, set to 32GB.\n\t\t\t$memory_limit = '32G';\n\t\t}\n\n\t\treturn ActionScheduler_Compatibility::convert_hr_to_bytes( $memory_limit );\n\t}\n\n\t/**\n\t * Memory exceeded\n\t *\n\t * Ensures the batch process never exceeds 90% of the maximum WordPress memory.\n\t *\n\t * Based on WP_Background_Process::memory_exceeded()\n\t *\n\t * @return bool\n\t */\n\tprotected function memory_exceeded() {\n\n\t\t$memory_limit    = $this->get_memory_limit() * 0.90;\n\t\t$current_memory  = memory_get_usage( true );\n\t\t$memory_exceeded = $current_memory >= $memory_limit;\n\n\t\treturn apply_filters( 'action_scheduler_memory_exceeded', $memory_exceeded, $this );\n\t}\n\n\t/**\n\t * See if the batch limits have been exceeded, which is when memory usage is almost at\n\t * the maximum limit, or the time to process more actions will exceed the max time limit.\n\t *\n\t * Based on WC_Background_Process::batch_limits_exceeded()\n\t *\n\t * @param int $processed_actions The number of actions processed so far - used to determine the likelihood of exceeding the time limit if processing another action\n\t * @return bool\n\t */\n\tprotected function batch_limits_exceeded( $processed_actions ) {\n\t\treturn $this->memory_exceeded() || $this->time_likely_to_be_exceeded( $processed_actions );\n\t}\n\n\t/**\n\t * Process actions in the queue.\n\t *\n\t * @author Jeremy Pry\n\t * @param string $context Optional identifer for the context in which this action is being processed, e.g. 'WP CLI' or 'WP Cron'\n\t *        Generally, this should be capitalised and not localised as it's a proper noun.\n\t * @return int The number of actions processed.\n\t */\n\tabstract public function run( $context = '' );\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_QueueRunner.php b/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_QueueRunner.php
--- a/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_QueueRunner.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/classes/abstracts/ActionScheduler_Abstract_QueueRunner.php	(date 1675081217929)
@@ -86,19 +86,6 @@
 	 * @param int $action_id
 	 */
 	protected function schedule_next_instance( ActionScheduler_Action $action, $action_id ) {
-		// If a recurring action has been consistently failing, we may wish to stop rescheduling it.
-		if (
-			ActionScheduler_Store::STATUS_FAILED === $this->store->get_status( $action_id )
-			&& $this->recurring_action_is_consistently_failing( $action, $action_id )
-		) {
-			ActionScheduler_Logger::instance()->log(
-				$action_id,
-				__( 'This action appears to be consistently failing. A new instance will not be scheduled.', 'action-scheduler' )
-			);
-
-			return;
-		}
-
 		try {
 			ActionScheduler::factory()->repeat( $action );
 		} catch ( Exception $e ) {
@@ -106,51 +93,6 @@
 		}
 	}
 
-	/**
-	 * Determine if the specified recurring action has been consistently failing.
-	 *
-	 * @param ActionScheduler_Action $action    The recurring action to be rescheduled.
-	 * @param int                    $action_id The ID of the recurring action.
-	 *
-	 * @return bool
-	 */
-	private function recurring_action_is_consistently_failing( ActionScheduler_Action $action, $action_id ) {
-		/**
-		 * Controls the failure threshold for recurring actions.
-		 *
-		 * Before rescheduling a recurring action, we look at its status. If it failed, we then check if all of the most
-		 * recent actions (upto the threshold set by this filter) sharing the same hook have also failed: if they have,
-		 * that is considered consistent failure and a new instance of the action will not be scheduled.
-		 *
-		 * @param int $failure_threshold Number of actions of the same hook to examine for failure. Defaults to 5.
-		 */
-		$consistent_failure_threshold = (int) apply_filters( 'action_scheduler_recurring_action_failure_threshold', 5 );
-
-		// This query should find the earliest *failing* action (for the hook we are interested in) within our threshold.
-		$query_args = array(
-			'hook'         => $action->get_hook(),
-			'status'       => ActionScheduler_Store::STATUS_FAILED,
-			'date'         => date_create( 'now', timezone_open( 'UTC' ) )->format( 'Y-m-d H:i:s' ),
-			'date_compare' => '<',
-			'per_page'     => 1,
-			'offset'       => $consistent_failure_threshold - 1
-		);
-
-		$first_failing_action_id = $this->store->query_actions( $query_args );
-
-		// If we didn't retrieve an action ID, then there haven't been enough failures for us to worry about.
-		if ( empty( $first_failing_action_id ) ) {
-			return false;
-		}
-
-		// Now let's fetch the first action (having the same hook) of *any status*ithin the same window.
-		unset( $query_args['status'] );
-		$first_action_id_with_the_same_hook = $this->store->query_actions( $query_args );
-
-		// If the IDs match, then actions for this hook must be consistently failing.
-		return $first_action_id_with_the_same_hook === $first_failing_action_id;
-	}
-
 	/**
 	 * Run the queue cleaner.
 	 *
Index: inc/Dependencies/RocketLazyload/Iframe.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n/**\n * Handles lazyloading of iframes\n *\n * @package WP_Rocket\\Dependencies\\RocketLazyload\n */\n\nnamespace WP_Rocket\\Dependencies\\RocketLazyload;\n\n/**\n * A class to provide the methods needed to lazyload iframes in WP Rocket and Lazyload by WP Rocket\n */\nclass Iframe {\n\n\t/**\n\t * Finds iframes in the HTML provided and call the methods to lazyload them\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @param array  $args   Array of arguments to use.\n\t * @return string\n\t */\n\tpublic function lazyloadIframes( $html, $buffer, $args = [] ) {\n\t\t$defaults = [\n\t\t\t'youtube' => false,\n\t\t];\n\n\t\t$args = wp_parse_args( $args, $defaults );\n\n\t\tif ( ! preg_match_all( '@<iframe(?<atts>\\s.+)>.*</iframe>@iUs', $buffer, $iframes, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$iframes = array_unique( $iframes, SORT_REGULAR );\n\n\t\tforeach ( $iframes as $iframe ) {\n\t\t\tif ( $this->isIframeExcluded( $iframe ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Given the previous regex pattern, $iframe['atts'] starts with a whitespace character.\n\t\t\tif ( ! preg_match( '@\\ssrc\\s*=\\s*(\\'|\")(?<src>.*)\\1@iUs', $iframe['atts'], $atts ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$iframe['src'] = trim( $atts['src'] );\n\n\t\t\tif ( '' === $iframe['src'] ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( $args['youtube'] ) {\n\t\t\t\t$iframe_lazyload = $this->replaceYoutubeThumbnail( $iframe );\n\t\t\t}\n\n\t\t\tif ( empty( $iframe_lazyload ) ) {\n\t\t\t\t$iframe_lazyload = $this->replaceIframe( $iframe );\n\t\t\t}\n\n\t\t\t$html = str_replace( $iframe[0], $iframe_lazyload, $html );\n\n\t\t\tunset( $iframe_lazyload );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Checks if the provided iframe is excluded from lazyload\n\t *\n\t * @param array $iframe Array of matched patterns.\n\t * @return boolean\n\t */\n\tpublic function isIframeExcluded( $iframe ) {\n\n\t\tforeach ( $this->getExcludedPatterns() as $excluded_pattern ) {\n\t\t\tif ( strpos( $iframe[0], $excluded_pattern ) !== false ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Gets patterns excluded from lazyload for iframes\n\t *\n\t * @since 2.1.1\n\t *\n\t * @return array\n\t */\n\tprivate function getExcludedPatterns() {\n\t\t/**\n\t\t * Filters the patterns excluded from lazyload for iframes\n\t\t *\n\t\t * @since 2.1.1\n\t\t *\n\t\t * @param array $excluded_patterns Array of excluded patterns.\n\t\t */\n\t\treturn apply_filters(\n\t\t\t'rocket_lazyload_iframe_excluded_patterns',\n\t\t\t[\n\t\t\t\t'gform_ajax_frame',\n\t\t\t\t'data-no-lazy=',\n\t\t\t\t'recaptcha/api/fallback',\n\t\t\t\t'loading=\"eager\"',\n\t\t\t\t'data-skip-lazy',\n\t\t\t\t'skip-lazy',\n\t\t\t\t'google_ads_iframe_',\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Applies lazyload on the iframe provided\n\t *\n\t * @param array $iframe Array of matched elements.\n\t * @return string\n\t */\n\tprivate function replaceIframe( $iframe ) {\n\t\t/**\n\t\t * Filter the LazyLoad placeholder on src attribute\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param string $placeholder placeholder that will be printed.\n\t\t */\n\t\t$placeholder = apply_filters( 'rocket_lazyload_placeholder', 'about:blank' );\n\n\t\t$placeholder_atts = str_replace( $iframe['src'], $placeholder, $iframe['atts'] );\n\t\t$iframe_lazyload  = str_replace( $iframe['atts'], $placeholder_atts . ' data-rocket-lazyload=\"fitvidscompatible\" data-lazy-src=\"' . esc_url( $iframe['src'] ) . '\"', $iframe[0] );\n\n\t\tif ( ! preg_match( '@\\sloading\\s*=\\s*(\\'|\")(?:lazy|auto)\\1@i', $iframe_lazyload ) ) {\n\t\t\t$iframe_lazyload = str_replace( '<iframe', '<iframe loading=\"lazy\"', $iframe_lazyload );\n\t\t}\n\n\t\t/**\n\t\t * Filter the LazyLoad HTML output on iframes\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param array $html Output that will be printed.\n\t\t */\n\t\t$iframe_lazyload  = apply_filters( 'rocket_lazyload_iframe_html', $iframe_lazyload );\n\t\t$iframe_lazyload .= '<noscript>' . $iframe[0] . '</noscript>';\n\n\t\treturn $iframe_lazyload;\n\t}\n\n\t/**\n\t * Replaces the iframe provided by the Youtube thumbnail\n\t *\n\t * @param array $iframe Array of matched elements.\n\t * @return bool|string\n\t */\n\tprivate function replaceYoutubeThumbnail( $iframe ) {\n\t\t$youtube_id = $this->getYoutubeIDFromURL( $iframe['src'] );\n\n\t\tif ( ! $youtube_id ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$query = wp_parse_url( htmlspecialchars_decode( $iframe['src'] ), PHP_URL_QUERY );\n\n\t\t$youtube_url = $this->changeYoutubeUrlForYoutuDotBe( $iframe['src'] );\n\t\t$youtube_url = $this->cleanYoutubeUrl( $iframe['src'] );\n\t\t/**\n\t\t * Filter the LazyLoad HTML output on Youtube iframes\n\t\t *\n\t\t * @since 2.11\n\t\t *\n\t\t * @param array $html Output that will be printed.\n\t\t */\n\t\t$youtube_lazyload  = apply_filters( 'rocket_lazyload_youtube_html', '<div class=\"rll-youtube-player\" data-src=\"' . esc_attr( $youtube_url ) . '\" data-id=\"' . esc_attr( $youtube_id ) . '\" data-query=\"' . esc_attr( $query ) . '\"></div>' );\n\t\t$youtube_lazyload .= '<noscript>' . $iframe[0] . '</noscript>';\n\n\t\treturn $youtube_lazyload;\n\t}\n\n\t/**\n\t * Gets the Youtube ID from the URL provided\n\t *\n\t * @param string $url URL to search.\n\t * @return bool|string\n\t */\n\tpublic function getYoutubeIDFromURL( $url ) {\n\t\t$pattern = '#^(?:https?:)?(?://)?(?:www\\.)?(?:youtu\\.be|youtube\\.com|youtube-nocookie\\.com)/(?:embed/|v/|watch/?\\?v=)?([\\w-]{11})#iU';\n\t\t$result  = preg_match( $pattern, $url, $matches );\n\n\t\tif ( ! $result ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// exclude playlist.\n\t\tif ( 'videoseries' === $matches[1] ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $matches[1];\n\t}\n\n\t/**\n\t * Changes URL youtu.be/ID to youtube.com/embed/ID\n\t *\n\t * @param  string $url URL to replace.\n\t * @return string      Unchanged URL or modified URL.\n\t */\n\tpublic function changeYoutubeUrlForYoutuDotBe( $url ) {\n\t\t$pattern = '#^(?:https?:)?(?://)?(?:www\\.)?(?:youtu\\.be)/(?:embed/|v/|watch/?\\?v=)?([\\w-]{11})#iU';\n\t\t$result  = preg_match( $pattern, $url, $matches );\n\n\t\tif ( ! $result ) {\n\t\t\treturn $url;\n\t\t}\n\n\t\treturn 'https://www.youtube.com/embed/' . $matches[1];\n\t}\n\n\t/**\n\t * Cleans Youtube URL. Keeps only scheme, host and path.\n\t *\n\t * @param  string $url URL to be cleaned.\n\t * @return string      Cleaned URL\n\t */\n\tpublic function cleanYoutubeUrl( $url ) {\n\t\t$parsed_url = wp_parse_url( $url, -1 );\n\t\t$scheme     = isset( $parsed_url['scheme'] ) ? $parsed_url['scheme'] . '://' : '//';\n\t\t$host       = isset( $parsed_url['host'] ) ? $parsed_url['host'] : '';\n\t\t$path       = isset( $parsed_url['path'] ) ? $parsed_url['path'] : '';\n\n\t\treturn $scheme . $host . $path;\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/RocketLazyload/Iframe.php b/inc/Dependencies/RocketLazyload/Iframe.php
--- a/inc/Dependencies/RocketLazyload/Iframe.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/RocketLazyload/Iframe.php	(date 1675081217933)
@@ -106,7 +106,6 @@
 				'loading="eager"',
 				'data-skip-lazy',
 				'skip-lazy',
-				'google_ads_iframe_',
 			]
 		);
 	}
Index: inc/Dependencies/RocketLazyload/Assets.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\ndeclare(strict_types=1);\n\n/**\n * Handle the lazyload required assets: inline CSS and JS\n *\n * @package WP_Rocket\\Dependencies\\RocketLazyload\n */\n\nnamespace WP_Rocket\\Dependencies\\RocketLazyload;\n\n/**\n * Class containing the methods to return or print the assets needed for lazyloading\n */\nclass Assets {\n\n\t/**\n\t * Inserts the lazyload script in the HTML\n\t *\n\t * @param array $args Array of arguments to populate the lazyload script tag.\n\t * @return void\n\t */\n\tpublic function insertLazyloadScript( $args = [] ) {\n\t\techo $this->getLazyloadScript( $args ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t}\n\n\t/**\n\t * Gets the inline lazyload script configuration\n\t *\n\t * @param array $args Array of arguments to populate the lazyload script options.\n\t * @return string\n\t */\n\tpublic function getInlineLazyloadScript( $args = [] ) {\n\t\t$defaults = [\n\t\t\t'elements'  => [\n\t\t\t\t'iframe',\n\t\t\t],\n\t\t\t'threshold' => 300,\n\t\t\t'options'   => [],\n\t\t];\n\n\t\t$allowed_options = [\n\t\t\t'container'           => 1,\n\t\t\t'thresholds'          => 1,\n\t\t\t'data_bg'             => 1,\n\t\t\t'data_bg_hidpi'       => 1,\n\t\t\t'data_bg_multi'       => 1,\n\t\t\t'data_bg_multi_hidpi' => 1,\n\t\t\t'data_poster'         => 1,\n\t\t\t'class_applied'       => 1,\n\t\t\t'class_error'         => 1,\n\t\t\t'class_entered'       => 1,\n\t\t\t'class_exited'        => 1,\n\t\t\t'cancel_on_exit'      => 1,\n\t\t\t'unobserve_entered'   => 1,\n\t\t\t'unobserve_completed' => 1,\n\t\t\t'callback_enter'      => 1,\n\t\t\t'callback_exit'       => 1,\n\t\t\t'callback_loading'    => 1,\n\t\t\t'callback_cancel'     => 1,\n\t\t\t'callback_loaded'     => 1,\n\t\t\t'callback_error'      => 1,\n\t\t\t'callback_applied'    => 1,\n\t\t\t'callback_finish'     => 1,\n\t\t\t'use_native'          => 1,\n\t\t];\n\n\t\t$args   = wp_parse_args( $args, $defaults );\n\t\t$script = '';\n\n\t\t$args['options'] = array_intersect_key( $args['options'], $allowed_options );\n\t\t$script         .= 'window.lazyLoadOptions = ';\n\n\t\tif ( isset( $args['elements']['background_image'] ) ) {\n\t\t\t$script .= '[';\n\t\t}\n\n\t\t$script .= '{\n                elements_selector: \"' . esc_attr( implode( ',', $args['elements'] ) ) . '\",\n                data_src: \"lazy-src\",\n                data_srcset: \"lazy-srcset\",\n                data_sizes: \"lazy-sizes\",\n                class_loading: \"lazyloading\",\n                class_loaded: \"lazyloaded\",\n                threshold: ' . esc_attr( $args['threshold'] ) . ',\n                callback_loaded: function(element) {\n                    if ( element.tagName === \"IFRAME\" && element.dataset.rocketLazyload == \"fitvidscompatible\" ) {\n                        if (element.classList.contains(\"lazyloaded\") ) {\n                            if (typeof window.jQuery != \"undefined\") {\n                                if (jQuery.fn.fitVids) {\n                                    jQuery(element).parent().fitVids();\n                                }\n                            }\n                        }\n                    }\n                }';\n\n\t\tif ( ! empty( $args['options'] ) ) {\n\t\t\t$script .= ',' . PHP_EOL;\n\n\t\t\tforeach ( $args['options'] as $option => $value ) {\n\t\t\t\t$script .= $option . ': ' . $value . ',';\n\t\t\t}\n\n\t\t\t$script = rtrim( $script, ',' );\n\t\t}\n\n\t\tif ( isset( $args['elements']['background_image'] ) ) {\n\t\t\t$script .= '},{\n\t\t\t\telements_selector: \"' . esc_attr( $args['elements']['background_image'] ) . '\",\n\t\t\t\tdata_src: \"lazy-src\",\n\t\t\t\tdata_srcset: \"lazy-srcset\",\n\t\t\t\tdata_sizes: \"lazy-sizes\",\n\t\t\t\tclass_loading: \"lazyloading\",\n\t\t\t\tclass_loaded: \"lazyloaded\",\n\t\t\t\tthreshold: ' . esc_attr( $args['threshold'] ) . ',\n\t\t\t}];';\n\t\t} else {\n\t\t\t$script .= '};';\n\t\t}\n\n\t\t$script .= '\n        window.addEventListener(\\'LazyLoad::Initialized\\', function (e) {\n            var lazyLoadInstance = e.detail.instance;\n\n            if (window.MutationObserver) {\n                var observer = new MutationObserver(function(mutations) {\n                    var image_count = 0;\n                    var iframe_count = 0;\n                    var rocketlazy_count = 0;\n\n                    mutations.forEach(function(mutation) {\n                        for (var i = 0; i < mutation.addedNodes.length; i++) {\n                            if (typeof mutation.addedNodes[i].getElementsByTagName !== \\'function\\') {\n                                continue;\n                            }\n\n                            if (typeof mutation.addedNodes[i].getElementsByClassName !== \\'function\\') {\n                                continue;\n                            }\n\n                            images = mutation.addedNodes[i].getElementsByTagName(\\'img\\');\n                            is_image = mutation.addedNodes[i].tagName == \"IMG\";\n                            iframes = mutation.addedNodes[i].getElementsByTagName(\\'iframe\\');\n                            is_iframe = mutation.addedNodes[i].tagName == \"IFRAME\";\n                            rocket_lazy = mutation.addedNodes[i].getElementsByClassName(\\'rocket-lazyload\\');\n\n                            image_count += images.length;\n\t\t\t                iframe_count += iframes.length;\n\t\t\t                rocketlazy_count += rocket_lazy.length;\n\n                            if(is_image){\n                                image_count += 1;\n                            }\n\n                            if(is_iframe){\n                                iframe_count += 1;\n                            }\n                        }\n                    } );\n\n                    if(image_count > 0 || iframe_count > 0 || rocketlazy_count > 0){\n                        lazyLoadInstance.update();\n                    }\n                } );\n\n                var b      = document.getElementsByTagName(\"body\")[0];\n                var config = { childList: true, subtree: true };\n\n                observer.observe(b, config);\n            }\n        }, false);';\n\n\t\treturn $script;\n\t}\n\n\t/**\n\t * Returns the lazyload inline script\n\t *\n\t * @param array $args Array of arguments to populate the lazyload script options.\n\t * @return string\n\t */\n\tpublic function getLazyloadScript( $args = [] ) {\n\t\t$defaults = [\n\t\t\t'base_url' => '',\n\t\t\t'version'  => '',\n\t\t];\n\n\t\t$args = wp_parse_args( $args, $defaults );\n\t\t$min  = ( defined( 'SCRIPT_DEBUG' ) && SCRIPT_DEBUG ) ? '' : '.min';\n\n\t\t/**\n\t\t * Filters the script tag for the lazyload script\n\t\t *\n\t\t * @since 2.2.6\n\t\t *\n\t\t * @param $script_tag HTML tag for the lazyload script.\n\t\t */\n\t\treturn apply_filters( 'rocket_lazyload_script_tag', '<script data-no-minify=\"1\" async src=\"' . $args['base_url'] . $args['version'] . '/lazyload' . $min . '.js\"></script>' ); // phpcs:ignore WordPress.WP.EnqueuedResources.NonEnqueuedScript\n\t}\n\n\t/**\n\t * Inserts in the HTML the script to replace the Youtube thumbnail by the iframe.\n\t *\n\t * @param array $args Array of arguments to populate the script options.\n\t * @return void\n\t */\n\tpublic function insertYoutubeThumbnailScript( $args = [] ) {\n\t\techo $this->getYoutubeThumbnailScript( $args ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t}\n\n\t/**\n\t * Returns the Youtube Thumbnail inline script\n\t *\n\t * @param array $args Array of arguments to populate the script options.\n\t * @return string\n\t */\n\tpublic function getYoutubeThumbnailScript( $args = [] ) {\n\t\t$defaults = [\n\t\t\t'resolution' => 'hqdefault',\n\t\t\t'lazy_image' => false,\n\t\t\t'native'     => true,\n\t\t];\n\n\t\t$allowed_resolutions = [\n\t\t\t'default'       => [\n\t\t\t\t'width'  => 120,\n\t\t\t\t'height' => 90,\n\t\t\t],\n\t\t\t'mqdefault'     => [\n\t\t\t\t'width'  => 320,\n\t\t\t\t'height' => 180,\n\t\t\t],\n\t\t\t'hqdefault'     => [\n\t\t\t\t'width'  => 480,\n\t\t\t\t'height' => 360,\n\t\t\t],\n\t\t\t'sddefault'     => [\n\t\t\t\t'width'  => 640,\n\t\t\t\t'height' => 480,\n\t\t\t],\n\n\t\t\t'maxresdefault' => [\n\t\t\t\t'width'  => 1280,\n\t\t\t\t'height' => 720,\n\t\t\t],\n\t\t];\n\n\t\t$args['resolution'] = ( isset( $args['resolution'] ) && isset( $allowed_resolutions[ $args['resolution'] ] ) ) ? $args['resolution'] : 'hqdefault';\n\n\t\t$args = wp_parse_args( $args, $defaults );\n\n\t\t$image = '<img src=\"https://i.ytimg.com/vi/ID/' . $args['resolution'] . '.jpg\" alt=\"\" width=\"' . $allowed_resolutions[ $args['resolution'] ]['width'] . '\" height=\"' . $allowed_resolutions[ $args['resolution'] ]['height'] . '\">';\n\n\t\tif ( isset( $args['lazy_image'] ) && $args['lazy_image'] ) {\n\t\t\t$attributes = 'alt=\"\" width=\"' . $allowed_resolutions[ $args['resolution'] ]['width'] . '\" height=\"' . $allowed_resolutions[ $args['resolution'] ]['height'] . '\"';\n\t\t\t$image_url  = 'https://i.ytimg.com/vi/ID/' . $args['resolution'] . '.jpg';\n\n\t\t\t$image = '<img data-lazy-src=\"' . $image_url . '\" ' . $attributes . '><noscript><img src=\"' . $image_url . '\" ' . $attributes . '></noscript>';\n\n\t\t\tif ( $args['native'] ) {\n\t\t\t\t$image = '<img loading=\"lazy\" src=\"' . $image_url . '\" ' . $attributes . '>';\n\t\t\t}\n\t\t}\n\n\t\treturn \"<script>function lazyLoadThumb(e){var t='{$image}',a='<button class=\\\"play\\\" aria-label=\\\"play Youtube video\\\"></button>';return t.replace(\\\"ID\\\",e)+a}function lazyLoadYoutubeIframe(){var e=document.createElement(\\\"iframe\\\"),t=\\\"ID?autoplay=1\\\";t+=0===this.parentNode.dataset.query.length?'':'&'+this.parentNode.dataset.query;e.setAttribute(\\\"src\\\",t.replace(\\\"ID\\\",this.parentNode.dataset.src)),e.setAttribute(\\\"frameborder\\\",\\\"0\\\"),e.setAttribute(\\\"allowfullscreen\\\",\\\"1\\\"),e.setAttribute(\\\"allow\\\", \\\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\\\"),this.parentNode.parentNode.replaceChild(e,this.parentNode)}document.addEventListener(\\\"DOMContentLoaded\\\",function(){var e,t,p,a=document.getElementsByClassName(\\\"rll-youtube-player\\\");for(t=0;t<a.length;t++)e=document.createElement(\\\"div\\\"),e.setAttribute(\\\"data-id\\\",a[t].dataset.id),e.setAttribute(\\\"data-query\\\", a[t].dataset.query),e.setAttribute(\\\"data-src\\\", a[t].dataset.src),e.innerHTML=lazyLoadThumb(a[t].dataset.id),a[t].appendChild(e),p=e.querySelector('.play'),p.onclick=lazyLoadYoutubeIframe});</script>\";\n\t}\n\n\t/**\n\t * Inserts the CSS to style the Youtube thumbnail container\n\t *\n\t * @param array $args Array of arguments to populate the CSS.\n\t * @return void\n\t */\n\tpublic function insertYoutubeThumbnailCSS( $args = [] ) {\n\t\twp_register_style( 'rocket-lazyload', false ); // phpcs:ignore WordPress.WP.EnqueuedResourceParameters.MissingVersion\n\t\twp_enqueue_style( 'rocket-lazyload' );\n\t\twp_add_inline_style( 'rocket-lazyload', $this->getYoutubeThumbnailCSS( $args ) );\n\t}\n\n\t/**\n\t * Returns the CSS for the Youtube Thumbnail\n\t *\n\t * @param array $args Array of arguments to populate the CSS.\n\t * @return string\n\t */\n\tpublic function getYoutubeThumbnailCSS( $args = [] ) {\n\t\t$defaults = [\n\t\t\t'base_url'          => '',\n\t\t\t'responsive_embeds' => true,\n\t\t];\n\n\t\t$args = wp_parse_args( $args, $defaults );\n\n\t\t$css = '.rll-youtube-player{position:relative;padding-bottom:56.23%;height:0;overflow:hidden;max-width:100%;}.rll-youtube-player:focus-within{outline: 2px solid currentColor;outline-offset: 5px;}.rll-youtube-player iframe{position:absolute;top:0;left:0;width:100%;height:100%;z-index:100;background:0 0}.rll-youtube-player img{bottom:0;display:block;left:0;margin:auto;max-width:100%;width:100%;position:absolute;right:0;top:0;border:none;height:auto;-webkit-transition:.4s all;-moz-transition:.4s all;transition:.4s all}.rll-youtube-player img:hover{-webkit-filter:brightness(75%)}.rll-youtube-player .play{height:100%;width:100%;left:0;top:0;position:absolute;background:url(' . $args['base_url'] . 'img/youtube.png) no-repeat center;background-color: transparent !important;cursor:pointer;border:none;}';\n\n\t\tif ( $args['responsive_embeds'] ) {\n\t\t\t$css .= '.wp-embed-responsive .wp-has-aspect-ratio .rll-youtube-player{position:absolute;padding-bottom:0;width:100%;height:100%;top:0;bottom:0;left:0;right:0}';\n\t\t}\n\n\t\treturn $css;\n\t}\n\n\t/**\n\t * Inserts the CSS needed when Javascript is not enabled to keep the display correct\n\t */\n\tpublic function insertNoJSCSS() {\n\t\techo $this->getNoJSCSS(); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t}\n\n\t/**\n\t * Returns the CSS to correctly display images when JavaScript is disabled\n\t *\n\t * @return string\n\t */\n\tpublic function getNoJSCSS() {\n\t\treturn '<noscript><style id=\"rocket-lazyload-nojs-css\">.rll-youtube-player, [data-lazy-src]{display:none !important;}</style></noscript>';\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/RocketLazyload/Assets.php b/inc/Dependencies/RocketLazyload/Assets.php
--- a/inc/Dependencies/RocketLazyload/Assets.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/RocketLazyload/Assets.php	(date 1675081217937)
@@ -69,13 +69,8 @@
 		$script = '';
 
 		$args['options'] = array_intersect_key( $args['options'], $allowed_options );
-		$script         .= 'window.lazyLoadOptions = ';
 
-		if ( isset( $args['elements']['background_image'] ) ) {
-			$script .= '[';
-		}
-
-		$script .= '{
+		$script .= 'window.lazyLoadOptions = {
                 elements_selector: "' . esc_attr( implode( ',', $args['elements'] ) ) . '",
                 data_src: "lazy-src",
                 data_srcset: "lazy-srcset",
@@ -105,19 +100,7 @@
 			$script = rtrim( $script, ',' );
 		}
 
-		if ( isset( $args['elements']['background_image'] ) ) {
-			$script .= '},{
-				elements_selector: "' . esc_attr( $args['elements']['background_image'] ) . '",
-				data_src: "lazy-src",
-				data_srcset: "lazy-srcset",
-				data_sizes: "lazy-sizes",
-				class_loading: "lazyloading",
-				class_loaded: "lazyloaded",
-				threshold: ' . esc_attr( $args['threshold'] ) . ',
-			}];';
-		} else {
-			$script .= '};';
-		}
+		$script .= '};';
 
 		$script .= '
         window.addEventListener(\'LazyLoad::Initialized\', function (e) {
@@ -135,7 +118,7 @@
                                 continue;
                             }
 
-                            if (typeof mutation.addedNodes[i].getElementsByClassName !== \'function\') {
+                           if (typeof mutation.addedNodes[i].getElementsByClassName !== \'function\') {
                                 continue;
                             }
 
Index: inc/Dependencies/RocketLazyload/Image.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\ndeclare(strict_types=1);\n\n/**\n * Handles lazyloading of images\n *\n * @package WP_Rocket\\Dependencies\\RocketLazyload\n */\n\nnamespace WP_Rocket\\Dependencies\\RocketLazyload;\n\n/**\n * A class to provide the methods needed to lazyload images in WP Rocket and Lazyload by WP Rocket\n */\nclass Image {\n\n\t/**\n\t * Finds the images to be lazyloaded and call the callback method to replace them.\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @param bool   $use_native Use native lazyload.\n\t * @return string\n\t */\n\tpublic function lazyloadImages( $html, $buffer, $use_native = true ) {\n\t\tif ( ! preg_match_all( '#<img(?<atts>\\s.+)\\s?/?>#iUs', $buffer, $images, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$images = array_unique( $images, SORT_REGULAR );\n\n\t\tforeach ( $images as $image ) {\n\t\t\t$image = $this->canLazyload( $image );\n\n\t\t\tif ( ! $image ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$image_lazyload = $this->replaceImage( $image, $use_native );\n\n\t\t\tif ( ! $use_native ) {\n\t\t\t\t$image_lazyload .= $this->noscript( $image[0] );\n\t\t\t}\n\n\t\t\t$html = str_replace( $image[0], $image_lazyload, $html );\n\n\t\t\tunset( $image_lazyload );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Applies lazyload on background images defined in style attributes\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @return string\n\t */\n\tpublic function lazyloadBackgroundImages( $html, $buffer ) {\n\t\tif ( ! preg_match_all( '#<(?<tag>div|figure|section|span|li|a)\\s+(?<before>[^>]+[\\'\"\\s])?style\\s*=\\s*([\\'\"])(?<styles>.*?)\\3(?<after>[^>]*)>#is', $buffer, $elements, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\tforeach ( $elements as $element ) {\n\t\t\tif ( $this->isExcluded( $element['before'] . $element['after'], $this->getExcludedAttributes() ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ! preg_match( '#background-image\\s*:\\s*(?<attr>\\s*url\\s*\\((?<url>[^)]+)\\))\\s*;?#is', $element['styles'], $url ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( preg_match( '#data:image#is', $url['url'], $img ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$url['url'] = esc_url(\n\t\t\t\ttrim(\n\t\t\t\t\twp_strip_all_tags(\n\t\t\t\t\t\thtml_entity_decode(\n\t\t\t\t\t\t\t$url['url'],\n\t\t\t\t\t\t\tENT_QUOTES | ENT_HTML5\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\t'\\'\" '\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tif ( $this->isExcluded( $url['url'], $this->getExcludedSrc() ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$lazy_bg = $this->addLazyCLass( $element[0] );\n\t\t\t$lazy_bg = str_replace( $url[0], '', $lazy_bg );\n\t\t\t$lazy_bg = str_replace( '<' . $element['tag'], '<' . $element['tag'] . ' data-bg=\"' . esc_attr( $url['url'] ) . '\"', $lazy_bg );\n\n\t\t\t$html = str_replace( $element[0], $lazy_bg, $html );\n\t\t\tunset( $lazy_bg );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Add the identifier class to the element\n\t *\n\t * @param string $element Element to add the class to.\n\t * @return string\n\t */\n\tprivate function addLazyClass( $element ) {\n\t\t$class = $this->getClasses( $element );\n\t\tif ( empty( $class ) ) {\n\t\t\treturn preg_replace( '#<(img|div|figure|section|li|span|a)([^>]*)>#is', '<\\1 class=\"rocket-lazyload\"\\2>', $element );\n\t\t}\n\n\t\tif ( empty( $class['attribute'] ) || empty( $class['classes'] ) ) {\n\t\t\treturn str_replace( $class['attribute'], 'class=\"rocket-lazyload\"', $element );\n\t\t}\n\n\t\t$quotes  = $this->getAttributeQuotes( $class['classes'] );\n\t\t$classes = $this->trimOuterQuotes( $class['classes'], $quotes );\n\n\t\tif ( empty( $classes ) ) {\n\t\t\treturn str_replace( $class['attribute'], 'class=\"rocket-lazyload\"', $element );\n\t\t}\n\n\t\t$classes .= ' rocket-lazyload';\n\n\t\treturn str_replace(\n\t\t\t$class['attribute'],\n\t\t\t'class=' . $this->normalizeClasses( $classes, $quotes ),\n\t\t\t$element\n\t\t);\n\t}\n\n\t/**\n\t * Gets the attribute value's outer quotation mark, if one exists, i.e. \" or '.\n\t *\n\t * @param string $attribute_value The target attribute's value.\n\t *\n\t * @return bool|string quotation character; else false when no quotation mark.\n\t */\n\tprivate function getAttributeQuotes( $attribute_value ) {\n\t\t$attribute_value = trim( $attribute_value );\n\t\t$first_char      = $attribute_value[0];\n\n\t\tif ( '\"' === $first_char || \"'\" === $first_char ) {\n\t\t\treturn $first_char;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Gets the class attribute and values from the given element, if it exists.\n\t *\n\t * @param string $element Given HTML element to extract classes from.\n\t *\n\t * @return bool|string[] {\n\t *      @type string $attribute Class attribute and value, e.g. class=\"value\"\n\t *      @type string $classes   String of class attribute's value(s)\n\t * }; else, false when no class attribute exists.\n\t */\n\tprivate function getClasses( $element ) {\n\t\tif ( ! preg_match( '#class\\s*=\\s*(?<classes>[\"\\'].*?[\"\\']|[^\\s]+)#is', $element, $class ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $class ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! isset( $class['classes'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn [\n\t\t\t'attribute' => $class[0],\n\t\t\t'classes'   => $class['classes'],\n\t\t];\n\t}\n\n\t/**\n\t * Removes outer single or double quotations.\n\t *\n\t * @param string $string String to strip quotes from.\n\t * @param string $quotes The outer quotes to remove.\n\t *\n\t * @return string string without quotes.\n\t */\n\tprivate function trimOuterQuotes( $string, $quotes ) {\n\t\t$string = trim( $string );\n\t\tif ( empty( $string ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif ( empty( $quotes ) ) {\n\t\t\treturn $string;\n\t\t}\n\n\t\t$string = ltrim( $string, $quotes );\n\t\t$string = rtrim( $string, $quotes );\n\t\treturn trim( $string );\n\t}\n\n\t/**\n\t * Normalizes the class attribute values to ensure well-formed.\n\t *\n\t * @param string      $classes String of class attribute value(s).\n\t * @param string|bool $quotes  Optional. Quotation mark to wrap around the classes.\n\t *\n\t * @return string well-formed class attributes.\n\t */\n\tprivate function normalizeClasses( $classes, $quotes = '\"' ) {\n\t\t$array_of_classes = $this->stringToArray( $classes );\n\t\t$classes          = implode( ' ', $array_of_classes );\n\n\t\tif ( false === $quotes ) {\n\t\t\t$quotes = '\"';\n\t\t}\n\n\t\treturn $quotes . $classes . $quotes;\n\t}\n\n\t/**\n\t * Converts the given string into an array of strings.\n\t *\n\t * Note:\n\t *  1. Removes empties.\n\t *  2. Trims each string.\n\t *\n\t * @param string $string    The target string to convert.\n\t * @param string $delimiter Optional. Default: ' ' empty string.\n\t *\n\t * @return array An array of trimmed strings.\n\t */\n\tprivate function stringToArray( $string, $delimiter = ' ' ) {\n\t\tif ( empty( $string ) ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t$array = explode( $delimiter, $string );\n\t\t$array = array_map( 'trim', $array );\n\n\t\t// Remove empties.\n\t\treturn array_filter( $array );\n\t}\n\n\t/**\n\t * Applies lazyload on picture elements found in the HTML.\n\t *\n\t * @param string $html   Original HTML.\n\t * @param string $buffer Content to parse.\n\t * @return string\n\t */\n\tpublic function lazyloadPictures( $html, $buffer ) {\n\t\tif ( ! preg_match_all( '#<picture(?:.*)?>(?<sources>.*)</picture>#iUs', $buffer, $pictures, PREG_SET_ORDER ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$pictures = array_unique( $pictures, SORT_REGULAR );\n\t\t$excluded = array_merge( $this->getExcludedAttributes(), $this->getExcludedSrc() );\n\n\t\tforeach ( $pictures as $picture ) {\n\t\t\tif ( $this->isExcluded( $picture[0], $excluded ) ) {\n\t\t\t\tif ( ! preg_match( '#<img(?<atts>\\s.+)\\s?/?>#iUs', $picture[0], $img ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$img = $this->canLazyload( $img );\n\n\t\t\t\tif ( ! $img ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$nolazy_picture = str_replace( '<img', '<img data-no-lazy=\"\"', $picture[0] );\n\t\t\t\t$html           = str_replace( $picture[0], $nolazy_picture, $html );\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( preg_match_all( '#<source(?<atts>\\s.+)>#iUs', $picture['sources'], $sources, PREG_SET_ORDER ) ) {\n\t\t\t\t$lazy_sources = 0;\n\t\t\t\t$sources      = array_unique( $sources, SORT_REGULAR );\n\t\t\t\t$lazy_picture = $picture[0];\n\n\t\t\t\tforeach ( $sources as $source ) {\n\t\t\t\t\t$lazyload_srcset = preg_replace( '/([\\s\"\\'])srcset/i', '\\1data-lazy-srcset', $source[0] );\n\t\t\t\t\t$lazy_picture    = str_replace( $source[0], $lazyload_srcset, $lazy_picture );\n\n\t\t\t\t\tunset( $lazyload_srcset );\n\t\t\t\t\t$lazy_sources++;\n\t\t\t\t}\n\n\t\t\t\tif ( 0 === $lazy_sources ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$html = str_replace( $picture[0], $lazy_picture, $html );\n\t\t\t}\n\n\t\t\tif ( ! preg_match( '#<img(?<atts>\\s.+)\\s?/?>#iUs', $picture[0], $img ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$img = $this->canLazyload( $img );\n\n\t\t\tif ( ! $img ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$img_lazy  = $this->replaceImage( $img, false );\n\t\t\t$img_lazy .= $this->noscript( $img[0] );\n\t\t\t$safe_img  = str_replace( '/', '\\/', preg_quote( $img[0], '#' ) );\n\t\t\t$html      = preg_replace( '#<noscript[^>]*>.*' . $safe_img . '.*<\\/noscript>(*SKIP)(*FAIL)|' . $safe_img . '#i', $img_lazy, $html );\n\n\t\t\tunset( $img_lazy );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Checks if the image can be lazyloaded\n\t *\n\t * @param Array $image Array of image data coming from Regex.\n\t * @return bool|Array\n\t */\n\tprivate function canLazyload( $image ) {\n\t\tif ( $this->isExcluded( $image['atts'], $this->getExcludedAttributes() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Given the previous regex pattern, $image['atts'] starts with a whitespace character.\n\t\tif ( ! preg_match( '@\\ssrc\\s*=\\s*(\\'|\")(?<src>.*)\\1@iUs', $image['atts'], $atts ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$image['src'] = trim( $atts['src'] );\n\n\t\tif ( '' === $image['src'] ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( $this->isExcluded( $image['src'], $this->getExcludedSrc() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $image;\n\t}\n\n\t/**\n\t * Checks if the provided string matches with the provided excluded patterns\n\t *\n\t * @param string $string          String to check.\n\t * @param array  $excluded_values Patterns to match against.\n\t * @return boolean\n\t */\n\tpublic function isExcluded( $string, $excluded_values ) {\n\t\tif ( ! is_array( $excluded_values ) ) {\n\t\t\t$excluded_values = (array) $excluded_values;\n\t\t}\n\n\t\tif ( empty( $excluded_values ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tforeach ( $excluded_values as $excluded_value ) {\n\t\t\tif ( strpos( $string, $excluded_value ) !== false ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the list of excluded attributes\n\t *\n\t * @return array\n\t */\n\tpublic function getExcludedAttributes() {\n\t\t/**\n\t\t * Filters the attributes used to prevent lazylad from being applied\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param array $excluded_attributes An array of excluded attributes.\n\t\t */\n\t\treturn apply_filters(\n\t\t\t'rocket_lazyload_excluded_attributes',\n\t\t\t[\n\t\t\t\t'data-src=',\n\t\t\t\t'data-no-lazy=',\n\t\t\t\t'data-lazy-original=',\n\t\t\t\t'data-lazy-src=',\n\t\t\t\t'data-lazysrc=',\n\t\t\t\t'data-lazyload=',\n\t\t\t\t'data-bgposition=',\n\t\t\t\t'data-envira-src=',\n\t\t\t\t'fullurl=',\n\t\t\t\t'lazy-slider-img=',\n\t\t\t\t'data-srcset=',\n\t\t\t\t'class=\"ls-l',\n\t\t\t\t'class=\"ls-bg',\n\t\t\t\t'soliloquy-image',\n\t\t\t\t'loading=\"eager\"',\n\t\t\t\t'swatch-img',\n\t\t\t\t'data-height-percentage',\n\t\t\t\t'data-large_image',\n\t\t\t\t'avia-bg-style-fixed',\n\t\t\t\t'data-skip-lazy',\n\t\t\t\t'skip-lazy',\n\t\t\t\t'image-compare__',\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Returns the list of excluded src\n\t *\n\t * @return array\n\t */\n\tpublic function getExcludedSrc() {\n\t\t/**\n\t\t * Filters the src used to prevent lazylad from being applied\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param array $excluded_src An array of excluded src.\n\t\t */\n\t\treturn apply_filters(\n\t\t\t'rocket_lazyload_excluded_src',\n\t\t\t[\n\t\t\t\t'/wpcf7_captcha/',\n\t\t\t\t'timthumb.php?src',\n\t\t\t\t'woocommerce/assets/images/placeholder.png',\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Replaces the original image by the lazyload one\n\t *\n\t * @param array $image Array of matches elements.\n\t * @param bool  $use_native Use native lazyload.\n\t *\n\t * @return string\n\t */\n\tprivate function replaceImage( $image, $use_native = true ) {\n\t\tif ( empty( $image ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$native_pattern = '@\\sloading\\s*=\\s*(\\'|\")(?:lazy|auto)\\1@i';\n\t\t$image_lazyload = $image[0];\n\n\t\tif ( $use_native ) {\n\t\t\tif ( preg_match( $native_pattern, $image[0] ) ) {\n\t\t\t\treturn $image[0];\n\t\t\t}\n\n\t\t\t$image_lazyload = str_replace( '<img', '<img loading=\"lazy\"', $image_lazyload );\n\t\t} else {\n\t\t\t$width  = 0;\n\t\t\t$height = 0;\n\n\t\t\tif ( preg_match( '@[\\s\"\\']width\\s*=\\s*(\\'|\")(?<width>.*)\\1@iUs', $image['atts'], $atts ) ) {\n\t\t\t\t$width = absint( $atts['width'] );\n\t\t\t}\n\n\t\t\tif ( preg_match( '@[\\s\"\\']height\\s*=\\s*(\\'|\")(?<height>.*)\\1@iUs', $image['atts'], $atts ) ) {\n\t\t\t\t$height = absint( $atts['height'] );\n\t\t\t}\n\n\t\t\t$placeholder_atts = preg_replace( '@\\ssrc\\s*=\\s*(\\'|\")(?<src>.*)\\1@iUs', ' src=\"' . $this->getPlaceholder( $width, $height ) . '\"', $image['atts'] );\n\n\t\t\t$image_lazyload = str_replace( $image['atts'], $placeholder_atts . ' data-lazy-src=\"' . $image['src'] . '\"', $image_lazyload );\n\n\t\t\tif ( preg_match( $native_pattern, $image_lazyload ) ) {\n\t\t\t\t$image_lazyload = preg_replace( $native_pattern, '', $image_lazyload );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filter the LazyLoad HTML output\n\t\t *\n\t\t * @since 1.0\n\t\t *\n\t\t * @param string $html Output that will be printed\n\t\t */\n\t\t$image_lazyload = apply_filters( 'rocket_lazyload_html', $image_lazyload );\n\n\t\treturn $image_lazyload;\n\t}\n\n\t/**\n\t * Returns the HTML tag wrapped inside noscript tags\n\t *\n\t * @param string $element Element to wrap.\n\t * @return string\n\t */\n\tprivate function noscript( $element ) {\n\t\treturn '<noscript>' . $element . '</noscript>';\n\t}\n\n\t/**\n\t * Applies lazyload on srcset and sizes attributes\n\t *\n\t * @param string $html HTML image tag.\n\t * @return string\n\t */\n\tpublic function lazyloadResponsiveAttributes( $html ) {\n\t\t$html = preg_replace( '/[\\s|\"|\\'](srcset)\\s*=\\s*(\"|\\')([^\"|\\']+)\\2/i', ' data-lazy-$1=$2$3$2', $html );\n\t\t$html = preg_replace( '/[\\s|\"|\\'](sizes)\\s*=\\s*(\"|\\')([^\"|\\']+)\\2/i', ' data-lazy-$1=$2$3$2', $html );\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Finds patterns matching smiley and call the callback method to replace them with the image\n\t *\n\t * @param string $text Content to search in.\n\t * @return string\n\t */\n\tpublic function convertSmilies( $text ) {\n\t\tglobal $wp_smiliessearch;\n\n\t\tif ( empty( $text ) || ! is_string( $text ) ) {\n\t\t\treturn $text;\n\t\t}\n\n\t\tif ( ! get_option( 'use_smilies' ) || empty( $wp_smiliessearch ) ) {\n\t\t\treturn $text;\n\t\t}\n\n\t\t$output = '';\n\t\t// HTML loop taken from texturize function, could possible be consolidated.\n\t\t$textarr = preg_split( '/(<.*>)/U', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // capture the tags as well as in between.\n\t\t$stop    = count( $textarr );// loop stuff.\n\n\t\t// Ignore proessing of specific tags.\n\t\t$tags_to_ignore       = 'code|pre|style|script|textarea';\n\t\t$ignore_block_element = '';\n\n\t\tfor ( $i = 0; $i < $stop; $i++ ) {\n\t\t\t$content = $textarr[ $i ];\n\n\t\t\t// If we're in an ignore block, wait until we find its closing tag.\n\t\t\tif ( '' === $ignore_block_element && preg_match( '/^<(' . $tags_to_ignore . ')>/', $content, $matches ) ) {\n\t\t\t\t$ignore_block_element = $matches[1];\n\t\t\t}\n\n\t\t\t// If it's not a tag and not in ignore block.\n\t\t\tif ( '' === $ignore_block_element && strlen( $content ) > 0 && '<' !== $content[0] ) {\n\t\t\t\t$content = preg_replace_callback( $wp_smiliessearch, [ $this, 'translateSmiley' ], $content );\n\t\t\t}\n\n\t\t\t// did we exit ignore block.\n\t\t\tif ( '' !== $ignore_block_element && '</' . $ignore_block_element . '>' === $content ) {\n\t\t\t\t$ignore_block_element = '';\n\t\t\t}\n\n\t\t\t$output .= $content;\n\t\t}\n\n\t\treturn $output;\n\t}\n\n\t/**\n\t * Replace matches by smiley image, lazyloaded\n\t *\n\t * @param array $matches Array of matches.\n\t * @return string\n\t */\n\tprivate function translateSmiley( $matches ) {\n\t\tglobal $wpsmiliestrans;\n\n\t\tif ( count( $matches ) === 0 ) {\n\t\t\treturn '';\n\t\t}\n\n\t\t$smiley = trim( reset( $matches ) );\n\t\t$img    = $wpsmiliestrans[ $smiley ];\n\n\t\t$matches    = [];\n\t\t$ext        = preg_match( '/\\.([^.]+)$/', $img, $matches ) ? strtolower( $matches[1] ) : false;\n\t\t$image_exts = [ 'jpg', 'jpeg', 'jpe', 'gif', 'png' ];\n\n\t\t// Don't convert smilies that aren't images - they're probably emoji.\n\t\tif ( ! in_array( $ext, $image_exts, true ) ) {\n\t\t\treturn $img;\n\t\t}\n\n\t\t/**\n\t\t * Filter the Smiley image URL before it's used in the image element.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param string $smiley_url URL for the smiley image.\n\t\t * @param string $img        Filename for the smiley image.\n\t\t * @param string $site_url   Site URL, as returned by site_url().\n\t\t */\n\t\t$src_url = apply_filters( 'smilies_src', includes_url( \"images/smilies/$img\" ), $img, site_url() ); // phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedHooknameFound\n\n\t\t// Don't LazyLoad if process is stopped for these reasons.\n\t\tif ( is_feed() || is_preview() ) {\n\t\t\treturn sprintf( ' <img src=\"%s\" alt=\"%s\" class=\"wp-smiley\" /> ', esc_url( $src_url ), esc_attr( $smiley ) );\n\t\t}\n\n\t\treturn sprintf( ' <img src=\"%s\" data-lazy-src=\"%s\" alt=\"%s\" class=\"wp-smiley\" /> ', $this->getPlaceholder(), esc_url( $src_url ), esc_attr( $smiley ) );\n\t}\n\n\t/**\n\t * Returns the placeholder for the src attribute\n\t *\n\t * @since 1.2\n\t *\n\t * @param int $width  Width of the placeholder image. Default 0.\n\t * @param int $height Height of the placeholder image. Default 0.\n\t * @return string\n\t */\n\tpublic function getPlaceholder( $width = 0, $height = 0 ) {\n\t\t$width  = 0 === $width ? 0 : absint( $width );\n\t\t$height = 0 === $height ? 0 : absint( $height );\n\n\t\t$placeholder = str_replace( ' ', '%20', \"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 $width $height'%3E%3C/svg%3E\" );\n\t\t/**\n\t\t * Filter the image lazyLoad placeholder on src attribute\n\t\t *\n\t\t * @since 1.1\n\t\t *\n\t\t * @param string $placeholder Placeholder that will be printed.\n\t\t * @param int    $width Placeholder width.\n\t\t * @param int    $height Placeholder height.\n\t\t */\n\t\treturn apply_filters( 'rocket_lazyload_placeholder', $placeholder, $width, $height );\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/RocketLazyload/Image.php b/inc/Dependencies/RocketLazyload/Image.php
--- a/inc/Dependencies/RocketLazyload/Image.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/RocketLazyload/Image.php	(date 1675081217945)
@@ -71,9 +71,6 @@
 				continue;
 			}
 
-			if ( preg_match( '#data:image#is', $url['url'], $img ) ) {
-				continue;
-			}
 			$url['url'] = esc_url(
 				trim(
 					wp_strip_all_tags(
@@ -358,7 +355,7 @@
 	 */
 	public function isExcluded( $string, $excluded_values ) {
 		if ( ! is_array( $excluded_values ) ) {
-			$excluded_values = (array) $excluded_values;
+			(array) $excluded_values;
 		}
 
 		if ( empty( $excluded_values ) ) {
@@ -448,19 +445,12 @@
 	 * @return string
 	 */
 	private function replaceImage( $image, $use_native = true ) {
-		if ( empty( $image ) ) {
-			return '';
-		}
-
-		$native_pattern = '@\sloading\s*=\s*(\'|")(?:lazy|auto)\1@i';
-		$image_lazyload = $image[0];
-
 		if ( $use_native ) {
-			if ( preg_match( $native_pattern, $image[0] ) ) {
+			if ( preg_match( '@\sloading\s*=\s*(\'|")(?:lazy|auto)\1@i', $image[0] ) ) {
 				return $image[0];
 			}
 
-			$image_lazyload = str_replace( '<img', '<img loading="lazy"', $image_lazyload );
+			$image_lazyload = str_replace( '<img', '<img loading="lazy"', $image[0] );
 		} else {
 			$width  = 0;
 			$height = 0;
@@ -475,11 +465,7 @@
 
 			$placeholder_atts = preg_replace( '@\ssrc\s*=\s*(\'|")(?<src>.*)\1@iUs', ' src="' . $this->getPlaceholder( $width, $height ) . '"', $image['atts'] );
 
-			$image_lazyload = str_replace( $image['atts'], $placeholder_atts . ' data-lazy-src="' . $image['src'] . '"', $image_lazyload );
-
-			if ( preg_match( $native_pattern, $image_lazyload ) ) {
-				$image_lazyload = preg_replace( $native_pattern, '', $image_lazyload );
-			}
+			$image_lazyload = str_replace( $image['atts'], $placeholder_atts . ' data-lazy-src="' . $image['src'] . '"', $image[0] );
 		}
 
 		/**
Index: inc/Dependencies/ActionScheduler/changelog.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>*** Changelog ***\n\n= 3.5.2 - 2022-09-16 =\n* Fix - erroneous 3.5.1 release.\n\n= 3.5.1 - 2022-09-13 =\n* Maintenance on A/S docs.\n* fix: PHP 8.2 deprecated notice.\n\n= 3.5.0 - 2022-08-25 =\n* Add - The active view link within the \"Tools > Scheduled Actions\" screen is now clickable.\n* Add - A warning when there are past-due actions.\n* Enhancement - Added the ability to schedule unique actions via an atomic operation.\n* Enhancement - Improvements to cache invalidation when processing batches (when running on WordPress 6.0+).\n* Enhancement - If a recurring action is found to be consistently failing, it will stop being rescheduled.\n* Enhancement - Adds a new \"Past Due\" view to the scheduled actions list table.\n\n= 3.4.2 - 2022-06-08 =\n* Fix - Change the include for better linting.\n* Fix - update: Added Action scheduler completed action hook.\n\n= 3.4.1 - 2022-05-24 =\n* Fix - Change the include for better linting.\n* Fix - Fix the documented return type.\n\n= 3.4.0 - 2021-10-29 =\n* Enhancement - Number of items per page can now be set for the Scheduled Actions view (props @ovidiul). #771\n* Fix - Do not lower the max_execution_time if it is already set to 0 (unlimited) (props @barryhughes). #755\n* Fix - Avoid triggering autoloaders during the version resolution process (props @olegabr). #731 & #776\n* Dev - ActionScheduler_wcSystemStatus PHPCS fixes (props @ovidiul). #761\n* Dev - ActionScheduler_DBLogger.php PHPCS fixes (props @ovidiul). #768\n* Dev - Fixed phpcs for ActionScheduler_Schedule_Deprecated (props @ovidiul). #762\n* Dev - Improve actions table indicies (props @glagonikas). #774 & #777\n* Dev - PHPCS fixes for ActionScheduler_DBStore.php (props @ovidiul). #769 & #778\n* Dev - PHPCS Fixes for ActionScheduler_Abstract_ListTable (props @ovidiul). #763 & #779\n* Dev - Adds new filter action_scheduler_claim_actions_order_by to allow tuning of the claim query (props @glagonikas). #773\n* Dev - PHPCS fixes for ActionScheduler_WpPostStore class (props @ovidiul). #780\n\n= 3.3.0 - 2021-09-15 =\n* Enhancement - Adds as_has_scheduled_action() to provide a performant way to test for existing actions. #645\n* Fix - Improves compatibility with environments where NO_ZERO_DATE is enabled. #519\n* Fix - Adds safety checks to guard against errors when our database tables cannot be created. #645\n* Dev - Now supports queries that use multiple statuses. #649\n* Dev - Minimum requirements for WordPress and PHP bumped (to 5.2 and 5.6 respectively). #723\n\n= 3.2.1 - 2021-06-21 =\n* Fix - Add extra safety/account for different versions of AS and different loading patterns. #714\n* Fix - Handle hidden columns (Tools → Scheduled Actions) | #600.\n\n= 3.2.0 - 2021-06-03 =\n* Fix - Add \"no ordering\" option to as_next_scheduled_action().\n* Fix - Add secondary scheduled date checks when claiming actions (DBStore) | #634.\n* Fix - Add secondary scheduled date checks when claiming actions (wpPostStore) | #634.\n* Fix - Adds a new index to the action table, reducing the potential for deadlocks (props: @glagonikas).\n* Fix - Fix unit tests infrastructure and adapt tests to PHP 8.\n* Fix - Identify in-use data store.\n* Fix - Improve test_migration_is_scheduled.\n* Fix - PHP notice on list table.\n* Fix - Speed up clean up and batch selects.\n* Fix - Update pending dependencies.\n* Fix - [PHP 8.0] Only pass action arg values through to do_action_ref_array().\n* Fix - [PHP 8] Set the PHP version to 7.1 in composer.json for PHP 8 compatibility.\n* Fix - add is_initialized() to docs.\n* Fix - fix file permissions.\n* Fix - fixes #664 by replacing __ with esc_html__.\n\n= 3.1.6 - 2020-05-12 =\n* Change log starts.\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/changelog.txt b/inc/Dependencies/ActionScheduler/changelog.txt
--- a/inc/Dependencies/ActionScheduler/changelog.txt	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/changelog.txt	(date 1675081217949)
@@ -1,20 +1,5 @@
 *** Changelog ***
 
-= 3.5.2 - 2022-09-16 =
-* Fix - erroneous 3.5.1 release.
-
-= 3.5.1 - 2022-09-13 =
-* Maintenance on A/S docs.
-* fix: PHP 8.2 deprecated notice.
-
-= 3.5.0 - 2022-08-25 =
-* Add - The active view link within the "Tools > Scheduled Actions" screen is now clickable.
-* Add - A warning when there are past-due actions.
-* Enhancement - Added the ability to schedule unique actions via an atomic operation.
-* Enhancement - Improvements to cache invalidation when processing batches (when running on WordPress 6.0+).
-* Enhancement - If a recurring action is found to be consistently failing, it will stop being rescheduled.
-* Enhancement - Adds a new "Past Due" view to the scheduled actions list table.
-
 = 3.4.2 - 2022-06-08 =
 * Fix - Change the include for better linting.
 * Fix - update: Added Action scheduler completed action hook.
Index: inc/Dependencies/ActionScheduler/functions.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n/**\n * General API functions for scheduling actions\n *\n * @package ActionScheduler.\n */\n\n/**\n * Enqueue an action to run one time, as soon as possible\n *\n * @param string $hook The hook to trigger.\n * @param array  $args Arguments to pass when the hook triggers.\n * @param string $group The group to assign this job to.\n * @param bool   $unique Whether the action should be unique.\n *\n * @return int The action ID.\n */\nfunction as_enqueue_async_action( $hook, $args = array(), $group = '', $unique = false ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn 0;\n\t}\n\treturn ActionScheduler::factory()->async_unique( $hook, $args, $group, $unique );\n}\n\n/**\n * Schedule an action to run one time\n *\n * @param int    $timestamp When the job will run.\n * @param string $hook The hook to trigger.\n * @param array  $args Arguments to pass when the hook triggers.\n * @param string $group The group to assign this job to.\n * @param bool   $unique Whether the action should be unique.\n *\n * @return int The action ID.\n */\nfunction as_schedule_single_action( $timestamp, $hook, $args = array(), $group = '', $unique = false ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn 0;\n\t}\n\treturn ActionScheduler::factory()->single_unique( $hook, $args, $timestamp, $group, $unique );\n}\n\n/**\n * Schedule a recurring action\n *\n * @param int    $timestamp When the first instance of the job will run.\n * @param int    $interval_in_seconds How long to wait between runs.\n * @param string $hook The hook to trigger.\n * @param array  $args Arguments to pass when the hook triggers.\n * @param string $group The group to assign this job to.\n * @param bool   $unique Whether the action should be unique.\n *\n * @return int The action ID.\n */\nfunction as_schedule_recurring_action( $timestamp, $interval_in_seconds, $hook, $args = array(), $group = '', $unique = false ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn 0;\n\t}\n\treturn ActionScheduler::factory()->recurring_unique( $hook, $args, $timestamp, $interval_in_seconds, $group, $unique );\n}\n\n/**\n * Schedule an action that recurs on a cron-like schedule.\n *\n * @param int    $timestamp The first instance of the action will be scheduled\n *           to run at a time calculated after this timestamp matching the cron\n *           expression. This can be used to delay the first instance of the action.\n * @param string $schedule A cron-link schedule string.\n * @see http://en.wikipedia.org/wiki/Cron\n *   *    *    *    *    *    *\n *   ┬    ┬    ┬    ┬    ┬    ┬\n *   |    |    |    |    |    |\n *   |    |    |    |    |    + year [optional]\n *   |    |    |    |    +----- day of week (0 - 7) (Sunday=0 or 7)\n *   |    |    |    +---------- month (1 - 12)\n *   |    |    +--------------- day of month (1 - 31)\n *   |    +-------------------- hour (0 - 23)\n *   +------------------------- min (0 - 59)\n * @param string $hook The hook to trigger.\n * @param array  $args Arguments to pass when the hook triggers.\n * @param string $group The group to assign this job to.\n * @param bool   $unique Whether the action should be unique.\n *\n * @return int The action ID.\n */\nfunction as_schedule_cron_action( $timestamp, $schedule, $hook, $args = array(), $group = '', $unique = false ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn 0;\n\t}\n\treturn ActionScheduler::factory()->cron_unique( $hook, $args, $timestamp, $schedule, $group, $unique );\n}\n\n/**\n * Cancel the next occurrence of a scheduled action.\n *\n * While only the next instance of a recurring or cron action is unscheduled by this method, that will also prevent\n * all future instances of that recurring or cron action from being run. Recurring and cron actions are scheduled in\n * a sequence instead of all being scheduled at once. Each successive occurrence of a recurring action is scheduled\n * only after the former action is run. If the next instance is never run, because it's unscheduled by this function,\n * then the following instance will never be scheduled (or exist), which is effectively the same as being unscheduled\n * by this method also.\n *\n * @param string $hook The hook that the job will trigger.\n * @param array  $args Args that would have been passed to the job.\n * @param string $group The group the job is assigned to.\n *\n * @return int|null The scheduled action ID if a scheduled action was found, or null if no matching action found.\n */\nfunction as_unschedule_action( $hook, $args = array(), $group = '' ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn 0;\n\t}\n\t$params = array(\n\t\t'hook'    => $hook,\n\t\t'status'  => ActionScheduler_Store::STATUS_PENDING,\n\t\t'orderby' => 'date',\n\t\t'order'   => 'ASC',\n\t\t'group'   => $group,\n\t);\n\tif ( is_array( $args ) ) {\n\t\t$params['args'] = $args;\n\t}\n\n\t$action_id = ActionScheduler::store()->query_action( $params );\n\n\tif ( $action_id ) {\n\t\ttry {\n\t\t\tActionScheduler::store()->cancel_action( $action_id );\n\t\t} catch ( Exception $exception ) {\n\t\t\tActionScheduler::logger()->log(\n\t\t\t\t$action_id,\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: %s is the name of the hook to be cancelled. */\n\t\t\t\t\t__( 'Caught exception while cancelling action: %s', 'action-scheduler' ),\n\t\t\t\t\tesc_attr( $hook )\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t$action_id = null;\n\t\t}\n\t}\n\n\treturn $action_id;\n}\n\n/**\n * Cancel all occurrences of a scheduled action.\n *\n * @param string $hook The hook that the job will trigger.\n * @param array  $args Args that would have been passed to the job.\n * @param string $group The group the job is assigned to.\n */\nfunction as_unschedule_all_actions( $hook, $args = array(), $group = '' ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn;\n\t}\n\tif ( empty( $args ) ) {\n\t\tif ( ! empty( $hook ) && empty( $group ) ) {\n\t\t\tActionScheduler_Store::instance()->cancel_actions_by_hook( $hook );\n\t\t\treturn;\n\t\t}\n\t\tif ( ! empty( $group ) && empty( $hook ) ) {\n\t\t\tActionScheduler_Store::instance()->cancel_actions_by_group( $group );\n\t\t\treturn;\n\t\t}\n\t}\n\tdo {\n\t\t$unscheduled_action = as_unschedule_action( $hook, $args, $group );\n\t} while ( ! empty( $unscheduled_action ) );\n}\n\n/**\n * Check if there is an existing action in the queue with a given hook, args and group combination.\n *\n * An action in the queue could be pending, in-progress or async. If the is pending for a time in\n * future, its scheduled date will be returned as a timestamp. If it is currently being run, or an\n * async action sitting in the queue waiting to be processed, in which case boolean true will be\n * returned. Or there may be no async, in-progress or pending action for this hook, in which case,\n * boolean false will be the return value.\n *\n * @param string $hook Name of the hook to search for.\n * @param array  $args Arguments of the action to be searched.\n * @param string $group Group of the action to be searched.\n *\n * @return int|bool The timestamp for the next occurrence of a pending scheduled action, true for an async or in-progress action or false if there is no matching action.\n */\nfunction as_next_scheduled_action( $hook, $args = null, $group = '' ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn false;\n\t}\n\n\t$params = array(\n\t\t'hook'    => $hook,\n\t\t'orderby' => 'date',\n\t\t'order'   => 'ASC',\n\t\t'group'   => $group,\n\t);\n\n\tif ( is_array( $args ) ) {\n\t\t$params['args'] = $args;\n\t}\n\n\t$params['status'] = ActionScheduler_Store::STATUS_RUNNING;\n\t$action_id        = ActionScheduler::store()->query_action( $params );\n\tif ( $action_id ) {\n\t\treturn true;\n\t}\n\n\t$params['status'] = ActionScheduler_Store::STATUS_PENDING;\n\t$action_id        = ActionScheduler::store()->query_action( $params );\n\tif ( null === $action_id ) {\n\t\treturn false;\n\t}\n\n\t$action         = ActionScheduler::store()->fetch_action( $action_id );\n\t$scheduled_date = $action->get_schedule()->get_date();\n\tif ( $scheduled_date ) {\n\t\treturn (int) $scheduled_date->format( 'U' );\n\t} elseif ( null === $scheduled_date ) { // pending async action with NullSchedule.\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Check if there is a scheduled action in the queue but more efficiently than as_next_scheduled_action().\n *\n * It's recommended to use this function when you need to know whether a specific action is currently scheduled\n * (pending or in-progress).\n *\n * @since 3.3.0\n *\n * @param string $hook  The hook of the action.\n * @param array  $args  Args that have been passed to the action. Null will matches any args.\n * @param string $group The group the job is assigned to.\n *\n * @return bool True if a matching action is pending or in-progress, false otherwise.\n */\nfunction as_has_scheduled_action( $hook, $args = null, $group = '' ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn false;\n\t}\n\n\t$query_args = array(\n\t\t'hook'    => $hook,\n\t\t'status'  => array( ActionScheduler_Store::STATUS_RUNNING, ActionScheduler_Store::STATUS_PENDING ),\n\t\t'group'   => $group,\n\t\t'orderby' => 'none',\n\t);\n\n\tif ( null !== $args ) {\n\t\t$query_args['args'] = $args;\n\t}\n\n\t$action_id = ActionScheduler::store()->query_action( $query_args );\n\n\treturn null !== $action_id;\n}\n\n/**\n * Find scheduled actions\n *\n * @param array  $args Possible arguments, with their default values.\n *         'hook' => '' - the name of the action that will be triggered.\n *         'args' => NULL - the args array that will be passed with the action.\n *         'date' => NULL - the scheduled date of the action. Expects a DateTime object, a unix timestamp, or a string that can parsed with strtotime(). Used in UTC timezone.\n *         'date_compare' => '<=' - operator for testing \"date\". accepted values are '!=', '>', '>=', '<', '<=', '='.\n *         'modified' => NULL - the date the action was last updated. Expects a DateTime object, a unix timestamp, or a string that can parsed with strtotime(). Used in UTC timezone.\n *         'modified_compare' => '<=' - operator for testing \"modified\". accepted values are '!=', '>', '>=', '<', '<=', '='.\n *         'group' => '' - the group the action belongs to.\n *         'status' => '' - ActionScheduler_Store::STATUS_COMPLETE or ActionScheduler_Store::STATUS_PENDING.\n *         'claimed' => NULL - TRUE to find claimed actions, FALSE to find unclaimed actions, a string to find a specific claim ID.\n *         'per_page' => 5 - Number of results to return.\n *         'offset' => 0.\n *         'orderby' => 'date' - accepted values are 'hook', 'group', 'modified', 'date' or 'none'.\n *         'order' => 'ASC'.\n *\n * @param string $return_format OBJECT, ARRAY_A, or ids.\n *\n * @return array\n */\nfunction as_get_scheduled_actions( $args = array(), $return_format = OBJECT ) {\n\tif ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {\n\t\treturn array();\n\t}\n\t$store = ActionScheduler::store();\n\tforeach ( array( 'date', 'modified' ) as $key ) {\n\t\tif ( isset( $args[ $key ] ) ) {\n\t\t\t$args[ $key ] = as_get_datetime_object( $args[ $key ] );\n\t\t}\n\t}\n\t$ids = $store->query_actions( $args );\n\n\tif ( 'ids' === $return_format || 'int' === $return_format ) {\n\t\treturn $ids;\n\t}\n\n\t$actions = array();\n\tforeach ( $ids as $action_id ) {\n\t\t$actions[ $action_id ] = $store->fetch_action( $action_id );\n\t}\n\n\tif ( ARRAY_A == $return_format ) {\n\t\tforeach ( $actions as $action_id => $action_object ) {\n\t\t\t$actions[ $action_id ] = get_object_vars( $action_object );\n\t\t}\n\t}\n\n\treturn $actions;\n}\n\n/**\n * Helper function to create an instance of DateTime based on a given\n * string and timezone. By default, will return the current date/time\n * in the UTC timezone.\n *\n * Needed because new DateTime() called without an explicit timezone\n * will create a date/time in PHP's timezone, but we need to have\n * assurance that a date/time uses the right timezone (which we almost\n * always want to be UTC), which means we need to always include the\n * timezone when instantiating datetimes rather than leaving it up to\n * the PHP default.\n *\n * @param mixed  $date_string A date/time string. Valid formats are explained in http://php.net/manual/en/datetime.formats.php.\n * @param string $timezone A timezone identifier, like UTC or Europe/Lisbon. The list of valid identifiers is available http://php.net/manual/en/timezones.php.\n *\n * @return ActionScheduler_DateTime\n */\nfunction as_get_datetime_object( $date_string = null, $timezone = 'UTC' ) {\n\tif ( is_object( $date_string ) && $date_string instanceof DateTime ) {\n\t\t$date = new ActionScheduler_DateTime( $date_string->format( 'Y-m-d H:i:s' ), new DateTimeZone( $timezone ) );\n\t} elseif ( is_numeric( $date_string ) ) {\n\t\t$date = new ActionScheduler_DateTime( '@' . $date_string, new DateTimeZone( $timezone ) );\n\t} else {\n\t\t$date = new ActionScheduler_DateTime( null === $date_string ? 'now' : $date_string, new DateTimeZone( $timezone ) );\n\t}\n\treturn $date;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/functions.php b/inc/Dependencies/ActionScheduler/functions.php
--- a/inc/Dependencies/ActionScheduler/functions.php	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/functions.php	(date 1675081217953)
@@ -1,8 +1,7 @@
 <?php
+
 /**
  * General API functions for scheduling actions
- *
- * @package ActionScheduler.
  */
 
 /**
@@ -11,61 +10,57 @@
  * @param string $hook The hook to trigger.
  * @param array  $args Arguments to pass when the hook triggers.
  * @param string $group The group to assign this job to.
- * @param bool   $unique Whether the action should be unique.
- *
  * @return int The action ID.
  */
-function as_enqueue_async_action( $hook, $args = array(), $group = '', $unique = false ) {
+function as_enqueue_async_action( $hook, $args = array(), $group = '' ) {
 	if ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {
 		return 0;
 	}
-	return ActionScheduler::factory()->async_unique( $hook, $args, $group, $unique );
+	return ActionScheduler::factory()->async( $hook, $args, $group );
 }
 
 /**
  * Schedule an action to run one time
  *
- * @param int    $timestamp When the job will run.
+ * @param int $timestamp When the job will run.
  * @param string $hook The hook to trigger.
- * @param array  $args Arguments to pass when the hook triggers.
+ * @param array $args Arguments to pass when the hook triggers.
  * @param string $group The group to assign this job to.
- * @param bool   $unique Whether the action should be unique.
  *
  * @return int The action ID.
  */
-function as_schedule_single_action( $timestamp, $hook, $args = array(), $group = '', $unique = false ) {
+function as_schedule_single_action( $timestamp, $hook, $args = array(), $group = '' ) {
 	if ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {
 		return 0;
 	}
-	return ActionScheduler::factory()->single_unique( $hook, $args, $timestamp, $group, $unique );
+	return ActionScheduler::factory()->single( $hook, $args, $timestamp, $group );
 }
 
 /**
  * Schedule a recurring action
  *
- * @param int    $timestamp When the first instance of the job will run.
- * @param int    $interval_in_seconds How long to wait between runs.
+ * @param int $timestamp When the first instance of the job will run.
+ * @param int $interval_in_seconds How long to wait between runs.
  * @param string $hook The hook to trigger.
- * @param array  $args Arguments to pass when the hook triggers.
+ * @param array $args Arguments to pass when the hook triggers.
  * @param string $group The group to assign this job to.
- * @param bool   $unique Whether the action should be unique.
  *
  * @return int The action ID.
  */
-function as_schedule_recurring_action( $timestamp, $interval_in_seconds, $hook, $args = array(), $group = '', $unique = false ) {
+function as_schedule_recurring_action( $timestamp, $interval_in_seconds, $hook, $args = array(), $group = '' ) {
 	if ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {
 		return 0;
 	}
-	return ActionScheduler::factory()->recurring_unique( $hook, $args, $timestamp, $interval_in_seconds, $group, $unique );
+	return ActionScheduler::factory()->recurring( $hook, $args, $timestamp, $interval_in_seconds, $group );
 }
 
 /**
  * Schedule an action that recurs on a cron-like schedule.
  *
- * @param int    $timestamp The first instance of the action will be scheduled
- *           to run at a time calculated after this timestamp matching the cron
- *           expression. This can be used to delay the first instance of the action.
- * @param string $schedule A cron-link schedule string.
+ * @param int $base_timestamp The first instance of the action will be scheduled
+ *        to run at a time calculated after this timestamp matching the cron
+ *        expression. This can be used to delay the first instance of the action.
+ * @param string $schedule A cron-link schedule string
  * @see http://en.wikipedia.org/wiki/Cron
  *   *    *    *    *    *    *
  *   ┬    ┬    ┬    ┬    ┬    ┬
@@ -77,17 +72,16 @@
  *   |    +-------------------- hour (0 - 23)
  *   +------------------------- min (0 - 59)
  * @param string $hook The hook to trigger.
- * @param array  $args Arguments to pass when the hook triggers.
+ * @param array $args Arguments to pass when the hook triggers.
  * @param string $group The group to assign this job to.
- * @param bool   $unique Whether the action should be unique.
  *
  * @return int The action ID.
  */
-function as_schedule_cron_action( $timestamp, $schedule, $hook, $args = array(), $group = '', $unique = false ) {
+function as_schedule_cron_action( $timestamp, $schedule, $hook, $args = array(), $group = '' ) {
 	if ( ! ActionScheduler::is_initialized( __FUNCTION__ ) ) {
 		return 0;
 	}
-	return ActionScheduler::factory()->cron_unique( $hook, $args, $timestamp, $schedule, $group, $unique );
+	return ActionScheduler::factory()->cron( $hook, $args, $timestamp, $schedule, $group );
 }
 
 /**
@@ -101,7 +95,7 @@
  * by this method also.
  *
  * @param string $hook The hook that the job will trigger.
- * @param array  $args Args that would have been passed to the job.
+ * @param array $args Args that would have been passed to the job.
  * @param string $group The group the job is assigned to.
  *
  * @return int|null The scheduled action ID if a scheduled action was found, or null if no matching action found.
@@ -147,7 +141,7 @@
  * Cancel all occurrences of a scheduled action.
  *
  * @param string $hook The hook that the job will trigger.
- * @param array  $args Args that would have been passed to the job.
+ * @param array $args Args that would have been passed to the job.
  * @param string $group The group the job is assigned to.
  */
 function as_unschedule_all_actions( $hook, $args = array(), $group = '' ) {
@@ -178,9 +172,9 @@
  * returned. Or there may be no async, in-progress or pending action for this hook, in which case,
  * boolean false will be the return value.
  *
- * @param string $hook Name of the hook to search for.
- * @param array  $args Arguments of the action to be searched.
- * @param string $group Group of the action to be searched.
+ * @param string $hook
+ * @param array $args
+ * @param string $group
  *
  * @return int|bool The timestamp for the next occurrence of a pending scheduled action, true for an async or in-progress action or false if there is no matching action.
  */
@@ -216,7 +210,7 @@
 	$scheduled_date = $action->get_schedule()->get_date();
 	if ( $scheduled_date ) {
 		return (int) $scheduled_date->format( 'U' );
-	} elseif ( null === $scheduled_date ) { // pending async action with NullSchedule.
+	} elseif ( null === $scheduled_date ) { // pending async action with NullSchedule
 		return true;
 	}
 
@@ -229,7 +223,7 @@
  * It's recommended to use this function when you need to know whether a specific action is currently scheduled
  * (pending or in-progress).
  *
- * @since 3.3.0
+ * @since x.x.x
  *
  * @param string $hook  The hook of the action.
  * @param array  $args  Args that have been passed to the action. Null will matches any args.
@@ -243,10 +237,10 @@
 	}
 
 	$query_args = array(
-		'hook'    => $hook,
-		'status'  => array( ActionScheduler_Store::STATUS_RUNNING, ActionScheduler_Store::STATUS_PENDING ),
-		'group'   => $group,
-		'orderby' => 'none',
+		'hook'     => $hook,
+		'status'   => array( ActionScheduler_Store::STATUS_RUNNING, ActionScheduler_Store::STATUS_PENDING ),
+		'group'    => $group,
+		'orderby'  => 'none',
 	);
 
 	if ( null !== $args ) {
@@ -255,26 +249,26 @@
 
 	$action_id = ActionScheduler::store()->query_action( $query_args );
 
-	return null !== $action_id;
+	return $action_id !== null;
 }
 
 /**
  * Find scheduled actions
  *
- * @param array  $args Possible arguments, with their default values.
- *         'hook' => '' - the name of the action that will be triggered.
- *         'args' => NULL - the args array that will be passed with the action.
- *         'date' => NULL - the scheduled date of the action. Expects a DateTime object, a unix timestamp, or a string that can parsed with strtotime(). Used in UTC timezone.
- *         'date_compare' => '<=' - operator for testing "date". accepted values are '!=', '>', '>=', '<', '<=', '='.
- *         'modified' => NULL - the date the action was last updated. Expects a DateTime object, a unix timestamp, or a string that can parsed with strtotime(). Used in UTC timezone.
- *         'modified_compare' => '<=' - operator for testing "modified". accepted values are '!=', '>', '>=', '<', '<=', '='.
- *         'group' => '' - the group the action belongs to.
- *         'status' => '' - ActionScheduler_Store::STATUS_COMPLETE or ActionScheduler_Store::STATUS_PENDING.
- *         'claimed' => NULL - TRUE to find claimed actions, FALSE to find unclaimed actions, a string to find a specific claim ID.
- *         'per_page' => 5 - Number of results to return.
- *         'offset' => 0.
- *         'orderby' => 'date' - accepted values are 'hook', 'group', 'modified', 'date' or 'none'.
- *         'order' => 'ASC'.
+ * @param array $args Possible arguments, with their default values:
+ *        'hook' => '' - the name of the action that will be triggered
+ *        'args' => NULL - the args array that will be passed with the action
+ *        'date' => NULL - the scheduled date of the action. Expects a DateTime object, a unix timestamp, or a string that can parsed with strtotime(). Used in UTC timezone.
+ *        'date_compare' => '<=' - operator for testing "date". accepted values are '!=', '>', '>=', '<', '<=', '='
+ *        'modified' => NULL - the date the action was last updated. Expects a DateTime object, a unix timestamp, or a string that can parsed with strtotime(). Used in UTC timezone.
+ *        'modified_compare' => '<=' - operator for testing "modified". accepted values are '!=', '>', '>=', '<', '<=', '='
+ *        'group' => '' - the group the action belongs to
+ *        'status' => '' - ActionScheduler_Store::STATUS_COMPLETE or ActionScheduler_Store::STATUS_PENDING
+ *        'claimed' => NULL - TRUE to find claimed actions, FALSE to find unclaimed actions, a string to find a specific claim ID
+ *        'per_page' => 5 - Number of results to return
+ *        'offset' => 0
+ *        'orderby' => 'date' - accepted values are 'hook', 'group', 'modified', 'date' or 'none'
+ *        'order' => 'ASC'
  *
  * @param string $return_format OBJECT, ARRAY_A, or ids.
  *
@@ -285,25 +279,25 @@
 		return array();
 	}
 	$store = ActionScheduler::store();
-	foreach ( array( 'date', 'modified' ) as $key ) {
-		if ( isset( $args[ $key ] ) ) {
-			$args[ $key ] = as_get_datetime_object( $args[ $key ] );
+	foreach ( array('date', 'modified') as $key ) {
+		if ( isset($args[$key]) ) {
+			$args[$key] = as_get_datetime_object($args[$key]);
 		}
 	}
 	$ids = $store->query_actions( $args );
 
-	if ( 'ids' === $return_format || 'int' === $return_format ) {
+	if ( $return_format == 'ids' || $return_format == 'int' ) {
 		return $ids;
 	}
 
 	$actions = array();
 	foreach ( $ids as $action_id ) {
-		$actions[ $action_id ] = $store->fetch_action( $action_id );
+		$actions[$action_id] = $store->fetch_action( $action_id );
 	}
 
-	if ( ARRAY_A == $return_format ) {
+	if ( $return_format == ARRAY_A ) {
 		foreach ( $actions as $action_id => $action_object ) {
-			$actions[ $action_id ] = get_object_vars( $action_object );
+			$actions[$action_id] = get_object_vars($action_object);
 		}
 	}
 
@@ -322,7 +316,7 @@
  * timezone when instantiating datetimes rather than leaving it up to
  * the PHP default.
  *
- * @param mixed  $date_string A date/time string. Valid formats are explained in http://php.net/manual/en/datetime.formats.php.
+ * @param mixed $date_string A date/time string. Valid formats are explained in http://php.net/manual/en/datetime.formats.php.
  * @param string $timezone A timezone identifier, like UTC or Europe/Lisbon. The list of valid identifiers is available http://php.net/manual/en/timezones.php.
  *
  * @return ActionScheduler_DateTime
Index: inc/Dependencies/ActionScheduler/readme.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>=== Action Scheduler ===\nContributors: Automattic, wpmuguru, claudiosanches, peterfabian1000, vedjain, jamosova, obliviousharmony, konamiman, sadowski, royho, barryhughes-1\nTags: scheduler, cron\nRequires at least: 5.2\nTested up to: 6.0\nStable tag: 3.5.2\nLicense: GPLv3\nRequires PHP: 5.6\n\nAction Scheduler - Job Queue for WordPress\n\n== Description ==\n\nAction Scheduler is a scalable, traceable job queue for background processing large sets of actions in WordPress. It's specially designed to be distributed in WordPress plugins.\n\nAction Scheduler works by triggering an action hook to run at some time in the future. Each hook can be scheduled with unique data, to allow callbacks to perform operations on that data. The hook can also be scheduled to run on one or more occassions.\n\nThink of it like an extension to `do_action()` which adds the ability to delay and repeat a hook.\n\n## Battle-Tested Background Processing\n\nEvery month, Action Scheduler processes millions of payments for [Subscriptions](https://woocommerce.com/products/woocommerce-subscriptions/), webhooks for [WooCommerce](https://wordpress.org/plugins/woocommerce/), as well as emails and other events for a range of other plugins.\n\nIt's been seen on live sites processing queues in excess of 50,000 jobs and doing resource intensive operations, like processing payments and creating orders, at a sustained rate of over 10,000 / hour without negatively impacting normal site operations.\n\nThis is all on infrastructure and WordPress sites outside the control of the plugin author.\n\nIf your plugin needs background processing, especially of large sets of tasks, Action Scheduler can help.\n\n## Learn More\n\nTo learn more about how to Action Scheduler works, and how to use it in your plugin, check out the docs on [ActionScheduler.org](https://actionscheduler.org).\n\nThere you will find:\n\n* [Usage guide](https://actionscheduler.org/usage/): instructions on installing and using Action Scheduler\n* [WP CLI guide](https://actionscheduler.org/wp-cli/): instructions on running Action Scheduler at scale via WP CLI\n* [API Reference](https://actionscheduler.org/api/): complete reference guide for all API functions\n* [Administration Guide](https://actionscheduler.org/admin/): guide to managing scheduled actions via the administration screen\n* [Guide to Background Processing at Scale](https://actionscheduler.org/perf/): instructions for running Action Scheduler at scale via the default WP Cron queue runner\n\n## Credits\n\nAction Scheduler is developed and maintained by [Automattic](http://automattic.com/) with significant early development completed by [Flightless](https://flightless.us/).\n\nCollaboration is cool. We'd love to work with you to improve Action Scheduler. [Pull Requests](https://github.com/woocommerce/action-scheduler/pulls) welcome.\n\n== Changelog ==\n\n= 3.5.2 - 2022-09-16 =\n* Fix - erroneous 3.5.1 release.\n\n= 3.5.1 - 2022-09-13 =\n* Maintenance on A/S docs.\n* fix: PHP 8.2 deprecated notice.\n\n= 3.5.0 - 2022-08-25 =\n* Add - The active view link within the \"Tools > Scheduled Actions\" screen is now clickable.\n* Add - A warning when there are past-due actions.\n* Enhancement - Added the ability to schedule unique actions via an atomic operation.\n* Enhancement - Improvements to cache invalidation when processing batches (when running on WordPress 6.0+).\n* Enhancement - If a recurring action is found to be consistently failing, it will stop being rescheduled.\n* Enhancement - Adds a new \"Past Due\" view to the scheduled actions list table.\n\n= 3.4.2 - 2022-06-08 =\n* Fix - Change the include for better linting.\n* Fix - update: Added Action scheduler completed action hook.\n\n= 3.4.1 - 2022-05-24 =\n* Fix - Change the include for better linting.\n* Fix - Fix the documented return type.\n\n= 3.4.0 - 2021-10-29 =\n* Enhancement - Number of items per page can now be set for the Scheduled Actions view (props @ovidiul). #771\n* Fix - Do not lower the max_execution_time if it is already set to 0 (unlimited) (props @barryhughes). #755\n* Fix - Avoid triggering autoloaders during the version resolution process (props @olegabr). #731 & #776\n* Dev - ActionScheduler_wcSystemStatus PHPCS fixes (props @ovidiul). #761\n* Dev - ActionScheduler_DBLogger.php PHPCS fixes (props @ovidiul). #768\n* Dev - Fixed phpcs for ActionScheduler_Schedule_Deprecated (props @ovidiul). #762\n* Dev - Improve actions table indicies (props @glagonikas). #774 & #777\n* Dev - PHPCS fixes for ActionScheduler_DBStore.php (props @ovidiul). #769 & #778\n* Dev - PHPCS Fixes for ActionScheduler_Abstract_ListTable (props @ovidiul). #763 & #779\n* Dev - Adds new filter action_scheduler_claim_actions_order_by to allow tuning of the claim query (props @glagonikas). #773\n* Dev - PHPCS fixes for ActionScheduler_WpPostStore class (props @ovidiul). #780\n\n= 3.3.0 - 2021-09-15 =\n* Enhancement - Adds as_has_scheduled_action() to provide a performant way to test for existing actions. #645\n* Fix - Improves compatibility with environments where NO_ZERO_DATE is enabled. #519\n* Fix - Adds safety checks to guard against errors when our database tables cannot be created. #645\n* Dev - Now supports queries that use multiple statuses. #649\n* Dev - Minimum requirements for WordPress and PHP bumped (to 5.2 and 5.6 respectively). #723\n\n= 3.2.1 - 2021-06-21 =\n* Fix - Add extra safety/account for different versions of AS and different loading patterns. #714\n* Fix - Handle hidden columns (Tools → Scheduled Actions) | #600.\n\n= 3.2.0 - 2021-06-03 =\n* Fix - Add \"no ordering\" option to as_next_scheduled_action().\n* Fix - Add secondary scheduled date checks when claiming actions (DBStore) | #634.\n* Fix - Add secondary scheduled date checks when claiming actions (wpPostStore) | #634.\n* Fix - Adds a new index to the action table, reducing the potential for deadlocks (props: @glagonikas).\n* Fix - Fix unit tests infrastructure and adapt tests to PHP 8.\n* Fix - Identify in-use data store.\n* Fix - Improve test_migration_is_scheduled.\n* Fix - PHP notice on list table.\n* Fix - Speed up clean up and batch selects.\n* Fix - Update pending dependencies.\n* Fix - [PHP 8.0] Only pass action arg values through to do_action_ref_array().\n* Fix - [PHP 8] Set the PHP version to 7.1 in composer.json for PHP 8 compatibility.\n* Fix - add is_initialized() to docs.\n* Fix - fix file permissions.\n* Fix - fixes #664 by replacing __ with esc_html__.\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/Dependencies/ActionScheduler/readme.txt b/inc/Dependencies/ActionScheduler/readme.txt
--- a/inc/Dependencies/ActionScheduler/readme.txt	(revision aefad82d38d976331f73238065ea0587bc281943)
+++ b/inc/Dependencies/ActionScheduler/readme.txt	(date 1675081217957)
@@ -2,8 +2,8 @@
 Contributors: Automattic, wpmuguru, claudiosanches, peterfabian1000, vedjain, jamosova, obliviousharmony, konamiman, sadowski, royho, barryhughes-1
 Tags: scheduler, cron
 Requires at least: 5.2
-Tested up to: 6.0
-Stable tag: 3.5.2
+Tested up to: 5.7
+Stable tag: 3.4.2
 License: GPLv3
 Requires PHP: 5.6
 
@@ -47,21 +47,6 @@
 
 == Changelog ==
 
-= 3.5.2 - 2022-09-16 =
-* Fix - erroneous 3.5.1 release.
-
-= 3.5.1 - 2022-09-13 =
-* Maintenance on A/S docs.
-* fix: PHP 8.2 deprecated notice.
-
-= 3.5.0 - 2022-08-25 =
-* Add - The active view link within the "Tools > Scheduled Actions" screen is now clickable.
-* Add - A warning when there are past-due actions.
-* Enhancement - Added the ability to schedule unique actions via an atomic operation.
-* Enhancement - Improvements to cache invalidation when processing batches (when running on WordPress 6.0+).
-* Enhancement - If a recurring action is found to be consistently failing, it will stop being rescheduled.
-* Enhancement - Adds a new "Past Due" view to the scheduled actions list table.
-
 = 3.4.2 - 2022-06-08 =
 * Fix - Change the include for better linting.
 * Fix - update: Added Action scheduler completed action hook.
